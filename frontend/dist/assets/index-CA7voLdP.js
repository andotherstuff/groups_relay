var pe=Object.defineProperty;var ye=(t,e,n)=>e in t?pe(t,e,{enumerable:!0,configurable:!0,writable:!0,value:n}):t[e]=n;var x=(t,e,n)=>ye(t,typeof e!="symbol"?e+"":e,n);(function(){const e=document.createElement("link").relList;if(e&&e.supports&&e.supports("modulepreload"))return;for(const s of document.querySelectorAll('link[rel="modulepreload"]'))r(s);new MutationObserver(s=>{for(const o of s)if(o.type==="childList")for(const a of o.addedNodes)a.tagName==="LINK"&&a.rel==="modulepreload"&&r(a)}).observe(document,{childList:!0,subtree:!0});function n(s){const o={};return s.integrity&&(o.integrity=s.integrity),s.referrerPolicy&&(o.referrerPolicy=s.referrerPolicy),s.crossOrigin==="use-credentials"?o.credentials="include":s.crossOrigin==="anonymous"?o.credentials="omit":o.credentials="same-origin",o}function r(s){if(s.ep)return;s.ep=!0;const o=n(s);fetch(s.href,o)}})();function number$2(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function bytes$2(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function hash$1(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$2(t.outputLen),number$2(t.blockLen)}function exists$1(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function output$1(t,e){bytes$2(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const crypto$3=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a$2=t=>t instanceof Uint8Array,createView$3=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),rotr$3=(t,e)=>t<<32-e|t>>>e,isLE$2=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$2)throw new Error("Non little-endian hardware is not supported");function utf8ToBytes$5(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function toBytes$3(t){if(typeof t=="string"&&(t=utf8ToBytes$5(t)),!u8a$2(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function concatBytes$4(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!u8a$2(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}let Hash$3=class{clone(){return this._cloneInto()}};function wrapConstructor$3(t){const e=r=>t().update(toBytes$3(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function randomBytes$2(t=32){if(crypto$3&&typeof crypto$3.getRandomValues=="function")return crypto$3.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function setBigUint64$3(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(n>>s&o),c=Number(n&o),l=r?4:0,h=r?0:4;t.setUint32(e+l,a,r),t.setUint32(e+h,c,r)}let SHA2$1=class extends Hash$3{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView$3(this.buffer)}update(e){exists$1(this);const{view:n,buffer:r,blockLen:s}=this;e=toBytes$3(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView$3(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){exists$1(this),output$1(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let u=a;u<s;u++)n[u]=0;setBigUint64$3(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView$3(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=l/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<h;u++)c.setUint32(4*u,f[u],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%n&&e.buffer.set(r),e}};const Chi$3=(t,e,n)=>t&e^~t&n,Maj$3=(t,e,n)=>t&e^t&n^e&n,SHA256_K$3=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$3=new Uint32Array(64);let SHA256$3=class extends SHA2$1{constructor(){super(64,32,8,!1),this.A=IV$1[0]|0,this.B=IV$1[1]|0,this.C=IV$1[2]|0,this.D=IV$1[3]|0,this.E=IV$1[4]|0,this.F=IV$1[5]|0,this.G=IV$1[6]|0,this.H=IV$1[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,n,r,s,o,a,c,l]}set(e,n,r,s,o,a,c,l){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,n){for(let u=0;u<16;u++,n+=4)SHA256_W$3[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const p=SHA256_W$3[u-15],g=SHA256_W$3[u-2],A=rotr$3(p,7)^rotr$3(p,18)^p>>>3,w=rotr$3(g,17)^rotr$3(g,19)^g>>>10;SHA256_W$3[u]=w+SHA256_W$3[u-7]+A+SHA256_W$3[u-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:h,H:f}=this;for(let u=0;u<64;u++){const p=rotr$3(c,6)^rotr$3(c,11)^rotr$3(c,25),g=f+p+Chi$3(c,l,h)+SHA256_K$3[u]+SHA256_W$3[u]|0,w=(rotr$3(r,2)^rotr$3(r,13)^rotr$3(r,22))+Maj$3(r,s,o)|0;f=h,h=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+w|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,h=h+this.G|0,f=f+this.H|0,this.set(r,s,o,a,c,l,h,f)}roundClean(){SHA256_W$3.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$3=wrapConstructor$3(()=>new SHA256$3);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$9=BigInt(0),_1n$9=BigInt(1),_2n$5=BigInt(2),u8a$1=t=>t instanceof Uint8Array,hexes$3=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$3(t){if(!u8a$1(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=hexes$3[t[n]];return e}function numberToHexUnpadded$1(t){const e=t.toString(16);return e.length&1?`0${e}`:e}function hexToNumber$1(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return BigInt(t===""?"0":`0x${t}`)}function hexToBytes$3(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const s=r*2,o=t.slice(s,s+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function bytesToNumberBE$1(t){return hexToNumber$1(bytesToHex$3(t))}function bytesToNumberLE$1(t){if(!u8a$1(t))throw new Error("Uint8Array expected");return hexToNumber$1(bytesToHex$3(Uint8Array.from(t).reverse()))}function numberToBytesBE$1(t,e){return hexToBytes$3(t.toString(16).padStart(e*2,"0"))}function numberToBytesLE$1(t,e){return numberToBytesBE$1(t,e).reverse()}function numberToVarBytesBE$1(t){return hexToBytes$3(numberToHexUnpadded$1(t))}function ensureBytes$1(t,e,n){let r;if(typeof e=="string")try{r=hexToBytes$3(e)}catch(o){throw new Error(`${t} must be valid hex string, got "${e}". Cause: ${o}`)}else if(u8a$1(e))r=Uint8Array.from(e);else throw new Error(`${t} must be hex string or Uint8Array`);const s=r.length;if(typeof n=="number"&&s!==n)throw new Error(`${t} expected ${n} bytes, got ${s}`);return r}function concatBytes$3(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!u8a$1(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}function equalBytes$2(t,e){if(t.length!==e.length)return!1;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return!1;return!0}function utf8ToBytes$4(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function bitLen$1(t){let e;for(e=0;t>_0n$9;t>>=_1n$9,e+=1);return e}function bitGet$1(t,e){return t>>BigInt(e)&_1n$9}const bitSet$1=(t,e,n)=>t|(n?_1n$9:_0n$9)<<BigInt(e),bitMask$1=t=>(_2n$5<<BigInt(t-1))-_1n$9,u8n$1=t=>new Uint8Array(t),u8fr$1=t=>Uint8Array.from(t);function createHmacDrbg$1(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=u8n$1(t),s=u8n$1(t),o=0;const a=()=>{r.fill(1),s.fill(0),o=0},c=(...u)=>n(s,r,...u),l=(u=u8n$1())=>{s=c(u8fr$1([0]),u),r=c(),u.length!==0&&(s=c(u8fr$1([1]),u),r=c())},h=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const p=[];for(;u<e;){r=c();const g=r.slice();p.push(g),u+=r.length}return concatBytes$3(...p)};return(u,p)=>{a(),l(u);let g;for(;!(g=p(h()));)l();return a(),g}}const validatorFns$1={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||t instanceof Uint8Array,isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function validateObject$1(t,e,n={}){const r=(s,o,a)=>{const c=validatorFns$1[o];if(typeof c!="function")throw new Error(`Invalid validator "${o}", expected function`);const l=t[s];if(!(a&&l===void 0)&&!c(l,t))throw new Error(`Invalid param ${String(s)}=${l} (${typeof l}), expected ${o}`)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(n))r(s,o,!0);return t}const ut$1=Object.freeze(Object.defineProperty({__proto__:null,bitGet:bitGet$1,bitLen:bitLen$1,bitMask:bitMask$1,bitSet:bitSet$1,bytesToHex:bytesToHex$3,bytesToNumberBE:bytesToNumberBE$1,bytesToNumberLE:bytesToNumberLE$1,concatBytes:concatBytes$3,createHmacDrbg:createHmacDrbg$1,ensureBytes:ensureBytes$1,equalBytes:equalBytes$2,hexToBytes:hexToBytes$3,hexToNumber:hexToNumber$1,numberToBytesBE:numberToBytesBE$1,numberToBytesLE:numberToBytesLE$1,numberToHexUnpadded:numberToHexUnpadded$1,numberToVarBytesBE:numberToVarBytesBE$1,utf8ToBytes:utf8ToBytes$4,validateObject:validateObject$1},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$8=BigInt(0),_1n$8=BigInt(1),_2n$4=BigInt(2),_3n$3=BigInt(3),_4n$1=BigInt(4),_5n$1=BigInt(5),_8n$1=BigInt(8);BigInt(9);BigInt(16);function mod$1(t,e){const n=t%e;return n>=_0n$8?n:e+n}function pow$1(t,e,n){if(n<=_0n$8||e<_0n$8)throw new Error("Expected power/modulo > 0");if(n===_1n$8)return _0n$8;let r=_1n$8;for(;e>_0n$8;)e&_1n$8&&(r=r*t%n),t=t*t%n,e>>=_1n$8;return r}function pow2$1(t,e,n){let r=t;for(;e-- >_0n$8;)r*=r,r%=n;return r}function invert$1(t,e){if(t===_0n$8||e<=_0n$8)throw new Error(`invert: expected positive integers, got n=${t} mod=${e}`);let n=mod$1(t,e),r=e,s=_0n$8,o=_1n$8;for(;n!==_0n$8;){const c=r/n,l=r%n,h=s-o*c;r=n,n=l,s=o,o=h}if(r!==_1n$8)throw new Error("invert: does not exist");return mod$1(s,e)}function tonelliShanks$1(t){const e=(t-_1n$8)/_2n$4;let n,r,s;for(n=t-_1n$8,r=0;n%_2n$4===_0n$8;n/=_2n$4,r++);for(s=_2n$4;s<t&&pow$1(s,e,t)!==t-_1n$8;s++);if(r===1){const a=(t+_1n$8)/_4n$1;return function(l,h){const f=l.pow(h,a);if(!l.eql(l.sqr(f),h))throw new Error("Cannot find square root");return f}}const o=(n+_1n$8)/_2n$4;return function(c,l){if(c.pow(l,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let h=r,f=c.pow(c.mul(c.ONE,s),n),u=c.pow(l,o),p=c.pow(l,n);for(;!c.eql(p,c.ONE);){if(c.eql(p,c.ZERO))return c.ZERO;let g=1;for(let w=c.sqr(p);g<h&&!c.eql(w,c.ONE);g++)w=c.sqr(w);const A=c.pow(f,_1n$8<<BigInt(h-g-1));f=c.sqr(A),u=c.mul(u,A),p=c.mul(p,f),h=g}return u}}function FpSqrt$1(t){if(t%_4n$1===_3n$3){const e=(t+_1n$8)/_4n$1;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%_8n$1===_5n$1){const e=(t-_5n$1)/_8n$1;return function(r,s){const o=r.mul(s,_2n$4),a=r.pow(o,e),c=r.mul(s,a),l=r.mul(r.mul(c,_2n$4),a),h=r.mul(c,r.sub(l,r.ONE));if(!r.eql(r.sqr(h),s))throw new Error("Cannot find square root");return h}}return tonelliShanks$1(t)}const FIELD_FIELDS$1=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField$1(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=FIELD_FIELDS$1.reduce((r,s)=>(r[s]="function",r),e);return validateObject$1(t,n)}function FpPow$1(t,e,n){if(n<_0n$8)throw new Error("Expected power > 0");if(n===_0n$8)return t.ONE;if(n===_1n$8)return e;let r=t.ONE,s=e;for(;n>_0n$8;)n&_1n$8&&(r=t.mul(r,s)),s=t.sqr(s),n>>=_1n$8;return r}function FpInvertBatch$1(t,e){const n=new Array(e.length),r=e.reduce((o,a,c)=>t.is0(a)?o:(n[c]=o,t.mul(o,a)),t.ONE),s=t.inv(r);return e.reduceRight((o,a,c)=>t.is0(a)?o:(n[c]=t.mul(o,n[c]),t.mul(o,a)),s),n}function nLength$1(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Field$1(t,e,n=!1,r={}){if(t<=_0n$8)throw new Error(`Expected Field ORDER > 0, got ${t}`);const{nBitLength:s,nByteLength:o}=nLength$1(t,e);if(o>2048)throw new Error("Field lengths over 2048 bytes are not supported");const a=FpSqrt$1(t),c=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:bitMask$1(s),ZERO:_0n$8,ONE:_1n$8,create:l=>mod$1(l,t),isValid:l=>{if(typeof l!="bigint")throw new Error(`Invalid field element: expected bigint, got ${typeof l}`);return _0n$8<=l&&l<t},is0:l=>l===_0n$8,isOdd:l=>(l&_1n$8)===_1n$8,neg:l=>mod$1(-l,t),eql:(l,h)=>l===h,sqr:l=>mod$1(l*l,t),add:(l,h)=>mod$1(l+h,t),sub:(l,h)=>mod$1(l-h,t),mul:(l,h)=>mod$1(l*h,t),pow:(l,h)=>FpPow$1(c,l,h),div:(l,h)=>mod$1(l*invert$1(h,t),t),sqrN:l=>l*l,addN:(l,h)=>l+h,subN:(l,h)=>l-h,mulN:(l,h)=>l*h,inv:l=>invert$1(l,t),sqrt:r.sqrt||(l=>a(c,l)),invertBatch:l=>FpInvertBatch$1(c,l),cmov:(l,h,f)=>f?h:l,toBytes:l=>n?numberToBytesLE$1(l,o):numberToBytesBE$1(l,o),fromBytes:l=>{if(l.length!==o)throw new Error(`Fp.fromBytes: expected ${o}, got ${l.length}`);return n?bytesToNumberLE$1(l):bytesToNumberBE$1(l)}});return Object.freeze(c)}function getFieldBytesLength$1(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function getMinHashLength$1(t){const e=getFieldBytesLength$1(t);return e+Math.ceil(e/2)}function mapHashToField$1(t,e,n=!1){const r=t.length,s=getFieldBytesLength$1(e),o=getMinHashLength$1(e);if(r<16||r<o||r>1024)throw new Error(`expected ${o}-1024 bytes of input, got ${r}`);const a=n?bytesToNumberBE$1(t):bytesToNumberLE$1(t),c=mod$1(a,e-_1n$8)+_1n$8;return n?numberToBytesLE$1(c,s):numberToBytesBE$1(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$7=BigInt(0),_1n$7=BigInt(1);function wNAF$1(t,e){const n=(s,o)=>{const a=o.negate();return s?a:o},r=s=>{const o=Math.ceil(e/s)+1,a=2**(s-1);return{windows:o,windowSize:a}};return{constTimeNegate:n,unsafeLadder(s,o){let a=t.ZERO,c=s;for(;o>_0n$7;)o&_1n$7&&(a=a.add(c)),c=c.double(),o>>=_1n$7;return a},precomputeWindow(s,o){const{windows:a,windowSize:c}=r(o),l=[];let h=s,f=h;for(let u=0;u<a;u++){f=h,l.push(f);for(let p=1;p<c;p++)f=f.add(h),l.push(f);h=f.double()}return l},wNAF(s,o,a){const{windows:c,windowSize:l}=r(s);let h=t.ZERO,f=t.BASE;const u=BigInt(2**s-1),p=2**s,g=BigInt(s);for(let A=0;A<c;A++){const w=A*l;let y=Number(a&u);a>>=g,y>l&&(y-=p,a+=_1n$7);const _=w,N=w+Math.abs(y)-1,C=A%2!==0,U=y<0;y===0?f=f.add(n(C,o[_])):h=h.add(n(U,o[N]))}return{p:h,f}},wNAFCached(s,o,a,c){const l=s._WINDOW_SIZE||1;let h=o.get(s);return h||(h=this.precomputeWindow(s,l),l!==1&&o.set(s,c(h))),this.wNAF(l,h,a)}}}function validateBasic$1(t){return validateField$1(t.Fp),validateObject$1(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength$1(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validatePointOpts$1(t){const e=validateBasic$1(t);validateObject$1(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:s}=e;if(n){if(!r.eql(s,r.ZERO))throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("Expected endomorphism with beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:b2n$1,hexToBytes:h2b$1}=ut$1,DER$1={Err:class extends Error{constructor(e=""){super(e)}},_parseInt(t){const{Err:e}=DER$1;if(t.length<2||t[0]!==2)throw new e("Invalid signature integer tag");const n=t[1],r=t.subarray(2,n+2);if(!n||r.length!==n)throw new e("Invalid signature integer: wrong length");if(r[0]&128)throw new e("Invalid signature integer: negative");if(r[0]===0&&!(r[1]&128))throw new e("Invalid signature integer: unnecessary leading zero");return{d:b2n$1(r),l:t.subarray(n+2)}},toSig(t){const{Err:e}=DER$1,n=typeof t=="string"?h2b$1(t):t;if(!(n instanceof Uint8Array))throw new Error("ui8a expected");let r=n.length;if(r<2||n[0]!=48)throw new e("Invalid signature tag");if(n[1]!==r-2)throw new e("Invalid signature: incorrect length");const{d:s,l:o}=DER$1._parseInt(n.subarray(2)),{d:a,l:c}=DER$1._parseInt(o);if(c.length)throw new e("Invalid signature: left bytes after parsing");return{r:s,s:a}},hexFromSig(t){const e=h=>Number.parseInt(h[0],16)&8?"00"+h:h,n=h=>{const f=h.toString(16);return f.length&1?`0${f}`:f},r=e(n(t.s)),s=e(n(t.r)),o=r.length/2,a=s.length/2,c=n(o),l=n(a);return`30${n(a+o+4)}02${l}${s}02${c}${r}`}},_0n$6=BigInt(0),_1n$6=BigInt(1);BigInt(2);const _3n$2=BigInt(3);BigInt(4);function weierstrassPoints$1(t){const e=validatePointOpts$1(t),{Fp:n}=e,r=e.toBytes||((A,w,y)=>{const _=w.toAffine();return concatBytes$3(Uint8Array.from([4]),n.toBytes(_.x),n.toBytes(_.y))}),s=e.fromBytes||(A=>{const w=A.subarray(1),y=n.fromBytes(w.subarray(0,n.BYTES)),_=n.fromBytes(w.subarray(n.BYTES,2*n.BYTES));return{x:y,y:_}});function o(A){const{a:w,b:y}=e,_=n.sqr(A),N=n.mul(_,A);return n.add(n.add(N,n.mul(A,w)),y)}if(!n.eql(n.sqr(e.Gy),o(e.Gx)))throw new Error("bad generator point: equation left != right");function a(A){return typeof A=="bigint"&&_0n$6<A&&A<e.n}function c(A){if(!a(A))throw new Error("Expected valid bigint: 0 < bigint < curve.n")}function l(A){const{allowedPrivateKeyLengths:w,nByteLength:y,wrapPrivateKey:_,n:N}=e;if(w&&typeof A!="bigint"){if(A instanceof Uint8Array&&(A=bytesToHex$3(A)),typeof A!="string"||!w.includes(A.length))throw new Error("Invalid key");A=A.padStart(y*2,"0")}let C;try{C=typeof A=="bigint"?A:bytesToNumberBE$1(ensureBytes$1("private key",A,y))}catch{throw new Error(`private key must be ${y} bytes, hex or bigint, not ${typeof A}`)}return _&&(C=mod$1(C,N)),c(C),C}const h=new Map;function f(A){if(!(A instanceof u))throw new Error("ProjectivePoint expected")}class u{constructor(w,y,_){if(this.px=w,this.py=y,this.pz=_,w==null||!n.isValid(w))throw new Error("x required");if(y==null||!n.isValid(y))throw new Error("y required");if(_==null||!n.isValid(_))throw new Error("z required")}static fromAffine(w){const{x:y,y:_}=w||{};if(!w||!n.isValid(y)||!n.isValid(_))throw new Error("invalid affine point");if(w instanceof u)throw new Error("projective point not allowed");const N=C=>n.eql(C,n.ZERO);return N(y)&&N(_)?u.ZERO:new u(y,_,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(w){const y=n.invertBatch(w.map(_=>_.pz));return w.map((_,N)=>_.toAffine(y[N])).map(u.fromAffine)}static fromHex(w){const y=u.fromAffine(s(ensureBytes$1("pointHex",w)));return y.assertValidity(),y}static fromPrivateKey(w){return u.BASE.multiply(l(w))}_setWindowSize(w){this._WINDOW_SIZE=w,h.delete(this)}assertValidity(){if(this.is0()){if(e.allowInfinityPoint&&!n.is0(this.py))return;throw new Error("bad point: ZERO")}const{x:w,y}=this.toAffine();if(!n.isValid(w)||!n.isValid(y))throw new Error("bad point: x or y not FE");const _=n.sqr(y),N=o(w);if(!n.eql(_,N))throw new Error("bad point: equation left != right");if(!this.isTorsionFree())throw new Error("bad point: not in prime-order subgroup")}hasEvenY(){const{y:w}=this.toAffine();if(n.isOdd)return!n.isOdd(w);throw new Error("Field doesn't support isOdd")}equals(w){f(w);const{px:y,py:_,pz:N}=this,{px:C,py:U,pz:b}=w,v=n.eql(n.mul(y,b),n.mul(C,N)),$=n.eql(n.mul(_,b),n.mul(U,N));return v&&$}negate(){return new u(this.px,n.neg(this.py),this.pz)}double(){const{a:w,b:y}=e,_=n.mul(y,_3n$2),{px:N,py:C,pz:U}=this;let b=n.ZERO,v=n.ZERO,$=n.ZERO,S=n.mul(N,N),I=n.mul(C,C),P=n.mul(U,U),E=n.mul(N,C);return E=n.add(E,E),$=n.mul(N,U),$=n.add($,$),b=n.mul(w,$),v=n.mul(_,P),v=n.add(b,v),b=n.sub(I,v),v=n.add(I,v),v=n.mul(b,v),b=n.mul(E,b),$=n.mul(_,$),P=n.mul(w,P),E=n.sub(S,P),E=n.mul(w,E),E=n.add(E,$),$=n.add(S,S),S=n.add($,S),S=n.add(S,P),S=n.mul(S,E),v=n.add(v,S),P=n.mul(C,U),P=n.add(P,P),S=n.mul(P,E),b=n.sub(b,S),$=n.mul(P,I),$=n.add($,$),$=n.add($,$),new u(b,v,$)}add(w){f(w);const{px:y,py:_,pz:N}=this,{px:C,py:U,pz:b}=w;let v=n.ZERO,$=n.ZERO,S=n.ZERO;const I=e.a,P=n.mul(e.b,_3n$2);let E=n.mul(y,C),R=n.mul(_,U),T=n.mul(N,b),B=n.add(y,_),m=n.add(C,U);B=n.mul(B,m),m=n.add(E,R),B=n.sub(B,m),m=n.add(y,N);let k=n.add(C,b);return m=n.mul(m,k),k=n.add(E,T),m=n.sub(m,k),k=n.add(_,N),v=n.add(U,b),k=n.mul(k,v),v=n.add(R,T),k=n.sub(k,v),S=n.mul(I,m),v=n.mul(P,T),S=n.add(v,S),v=n.sub(R,S),S=n.add(R,S),$=n.mul(v,S),R=n.add(E,E),R=n.add(R,E),T=n.mul(I,T),m=n.mul(P,m),R=n.add(R,T),T=n.sub(E,T),T=n.mul(I,T),m=n.add(m,T),E=n.mul(R,m),$=n.add($,E),E=n.mul(k,m),v=n.mul(B,v),v=n.sub(v,E),E=n.mul(B,R),S=n.mul(k,S),S=n.add(S,E),new u(v,$,S)}subtract(w){return this.add(w.negate())}is0(){return this.equals(u.ZERO)}wNAF(w){return g.wNAFCached(this,h,w,y=>{const _=n.invertBatch(y.map(N=>N.pz));return y.map((N,C)=>N.toAffine(_[C])).map(u.fromAffine)})}multiplyUnsafe(w){const y=u.ZERO;if(w===_0n$6)return y;if(c(w),w===_1n$6)return this;const{endo:_}=e;if(!_)return g.unsafeLadder(this,w);let{k1neg:N,k1:C,k2neg:U,k2:b}=_.splitScalar(w),v=y,$=y,S=this;for(;C>_0n$6||b>_0n$6;)C&_1n$6&&(v=v.add(S)),b&_1n$6&&($=$.add(S)),S=S.double(),C>>=_1n$6,b>>=_1n$6;return N&&(v=v.negate()),U&&($=$.negate()),$=new u(n.mul($.px,_.beta),$.py,$.pz),v.add($)}multiply(w){c(w);let y=w,_,N;const{endo:C}=e;if(C){const{k1neg:U,k1:b,k2neg:v,k2:$}=C.splitScalar(y);let{p:S,f:I}=this.wNAF(b),{p:P,f:E}=this.wNAF($);S=g.constTimeNegate(U,S),P=g.constTimeNegate(v,P),P=new u(n.mul(P.px,C.beta),P.py,P.pz),_=S.add(P),N=I.add(E)}else{const{p:U,f:b}=this.wNAF(y);_=U,N=b}return u.normalizeZ([_,N])[0]}multiplyAndAddUnsafe(w,y,_){const N=u.BASE,C=(b,v)=>v===_0n$6||v===_1n$6||!b.equals(N)?b.multiplyUnsafe(v):b.multiply(v),U=C(this,y).add(C(w,_));return U.is0()?void 0:U}toAffine(w){const{px:y,py:_,pz:N}=this,C=this.is0();w==null&&(w=C?n.ONE:n.inv(N));const U=n.mul(y,w),b=n.mul(_,w),v=n.mul(N,w);if(C)return{x:n.ZERO,y:n.ZERO};if(!n.eql(v,n.ONE))throw new Error("invZ was invalid");return{x:U,y:b}}isTorsionFree(){const{h:w,isTorsionFree:y}=e;if(w===_1n$6)return!0;if(y)return y(u,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:w,clearCofactor:y}=e;return w===_1n$6?this:y?y(u,this):this.multiplyUnsafe(e.h)}toRawBytes(w=!0){return this.assertValidity(),r(u,this,w)}toHex(w=!0){return bytesToHex$3(this.toRawBytes(w))}}u.BASE=new u(e.Gx,e.Gy,n.ONE),u.ZERO=new u(n.ZERO,n.ONE,n.ZERO);const p=e.nBitLength,g=wNAF$1(u,e.endo?Math.ceil(p/2):p);return{CURVE:e,ProjectivePoint:u,normPrivateKeyToScalar:l,weierstrassEquation:o,isWithinCurveOrder:a}}function validateOpts$1(t){const e=validateBasic$1(t);return validateObject$1(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function weierstrass$1(t){const e=validateOpts$1(t),{Fp:n,n:r}=e,s=n.BYTES+1,o=2*n.BYTES+1;function a(m){return _0n$6<m&&m<n.ORDER}function c(m){return mod$1(m,r)}function l(m){return invert$1(m,r)}const{ProjectivePoint:h,normPrivateKeyToScalar:f,weierstrassEquation:u,isWithinCurveOrder:p}=weierstrassPoints$1({...e,toBytes(m,k,L){const H=k.toAffine(),D=n.toBytes(H.x),M=concatBytes$3;return L?M(Uint8Array.from([k.hasEvenY()?2:3]),D):M(Uint8Array.from([4]),D,n.toBytes(H.y))},fromBytes(m){const k=m.length,L=m[0],H=m.subarray(1);if(k===s&&(L===2||L===3)){const D=bytesToNumberBE$1(H);if(!a(D))throw new Error("Point is not on curve");const M=u(D);let O=n.sqrt(M);const F=(O&_1n$6)===_1n$6;return(L&1)===1!==F&&(O=n.neg(O)),{x:D,y:O}}else if(k===o&&L===4){const D=n.fromBytes(H.subarray(0,n.BYTES)),M=n.fromBytes(H.subarray(n.BYTES,2*n.BYTES));return{x:D,y:M}}else throw new Error(`Point of length ${k} was invalid. Expected ${s} compressed bytes or ${o} uncompressed bytes`)}}),g=m=>bytesToHex$3(numberToBytesBE$1(m,e.nByteLength));function A(m){const k=r>>_1n$6;return m>k}function w(m){return A(m)?c(-m):m}const y=(m,k,L)=>bytesToNumberBE$1(m.slice(k,L));class _{constructor(k,L,H){this.r=k,this.s=L,this.recovery=H,this.assertValidity()}static fromCompact(k){const L=e.nByteLength;return k=ensureBytes$1("compactSignature",k,L*2),new _(y(k,0,L),y(k,L,2*L))}static fromDER(k){const{r:L,s:H}=DER$1.toSig(ensureBytes$1("DER",k));return new _(L,H)}assertValidity(){if(!p(this.r))throw new Error("r must be 0 < r < CURVE.n");if(!p(this.s))throw new Error("s must be 0 < s < CURVE.n")}addRecoveryBit(k){return new _(this.r,this.s,k)}recoverPublicKey(k){const{r:L,s:H,recovery:D}=this,M=$(ensureBytes$1("msgHash",k));if(D==null||![0,1,2,3].includes(D))throw new Error("recovery id invalid");const O=D===2||D===3?L+e.n:L;if(O>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const F=D&1?"03":"02",K=h.fromHex(F+g(O)),z=l(O),q=c(-M*z),V=c(H*z),j=h.BASE.multiplyAndAddUnsafe(K,q,V);if(!j)throw new Error("point at infinify");return j.assertValidity(),j}hasHighS(){return A(this.s)}normalizeS(){return this.hasHighS()?new _(this.r,c(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes$3(this.toDERHex())}toDERHex(){return DER$1.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes$3(this.toCompactHex())}toCompactHex(){return g(this.r)+g(this.s)}}const N={isValidPrivateKey(m){try{return f(m),!0}catch{return!1}},normPrivateKeyToScalar:f,randomPrivateKey:()=>{const m=getMinHashLength$1(e.n);return mapHashToField$1(e.randomBytes(m),e.n)},precompute(m=8,k=h.BASE){return k._setWindowSize(m),k.multiply(BigInt(3)),k}};function C(m,k=!0){return h.fromPrivateKey(m).toRawBytes(k)}function U(m){const k=m instanceof Uint8Array,L=typeof m=="string",H=(k||L)&&m.length;return k?H===s||H===o:L?H===2*s||H===2*o:m instanceof h}function b(m,k,L=!0){if(U(m))throw new Error("first arg must be private key");if(!U(k))throw new Error("second arg must be public key");return h.fromHex(k).multiply(f(m)).toRawBytes(L)}const v=e.bits2int||function(m){const k=bytesToNumberBE$1(m),L=m.length*8-e.nBitLength;return L>0?k>>BigInt(L):k},$=e.bits2int_modN||function(m){return c(v(m))},S=bitMask$1(e.nBitLength);function I(m){if(typeof m!="bigint")throw new Error("bigint expected");if(!(_0n$6<=m&&m<S))throw new Error(`bigint expected < 2^${e.nBitLength}`);return numberToBytesBE$1(m,e.nByteLength)}function P(m,k,L=E){if(["recovered","canonical"].some(Z=>Z in L))throw new Error("sign() legacy options not supported");const{hash:H,randomBytes:D}=e;let{lowS:M,prehash:O,extraEntropy:F}=L;M==null&&(M=!0),m=ensureBytes$1("msgHash",m),O&&(m=ensureBytes$1("prehashed msgHash",H(m)));const K=$(m),z=f(k),q=[I(z),I(K)];if(F!=null){const Z=F===!0?D(n.BYTES):F;q.push(ensureBytes$1("extraEntropy",Z))}const V=concatBytes$3(...q),j=K;function G(Z){const X=v(Z);if(!p(X))return;const te=l(X),Y=h.BASE.multiply(X).toAffine(),W=c(Y.x);if(W===_0n$6)return;const J=c(te*c(j+W*z));if(J===_0n$6)return;let Q=(Y.x===W?0:2)|Number(Y.y&_1n$6),oe=J;return M&&A(J)&&(oe=w(J),Q^=1),new _(W,oe,Q)}return{seed:V,k2sig:G}}const E={lowS:e.lowS,prehash:!1},R={lowS:e.lowS,prehash:!1};function T(m,k,L=E){const{seed:H,k2sig:D}=P(m,k,L),M=e;return createHmacDrbg$1(M.hash.outputLen,M.nByteLength,M.hmac)(H,D)}h.BASE._setWindowSize(8);function B(m,k,L,H=R){var Y;const D=m;if(k=ensureBytes$1("msgHash",k),L=ensureBytes$1("publicKey",L),"strict"in H)throw new Error("options.strict was renamed to lowS");const{lowS:M,prehash:O}=H;let F,K;try{if(typeof D=="string"||D instanceof Uint8Array)try{F=_.fromDER(D)}catch(W){if(!(W instanceof DER$1.Err))throw W;F=_.fromCompact(D)}else if(typeof D=="object"&&typeof D.r=="bigint"&&typeof D.s=="bigint"){const{r:W,s:J}=D;F=new _(W,J)}else throw new Error("PARSE");K=h.fromHex(L)}catch(W){if(W.message==="PARSE")throw new Error("signature must be Signature instance, Uint8Array or hex string");return!1}if(M&&F.hasHighS())return!1;O&&(k=e.hash(k));const{r:z,s:q}=F,V=$(k),j=l(q),G=c(V*j),Z=c(z*j),X=(Y=h.BASE.multiplyAndAddUnsafe(K,G,Z))==null?void 0:Y.toAffine();return X?c(X.x)===z:!1}return{CURVE:e,getPublicKey:C,getSharedSecret:b,sign:T,verify:B,ProjectivePoint:h,Signature:_,utils:N}}let HMAC$2=class extends Hash$3{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,hash$1(e);const r=toBytes$3(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return exists$1(this),this.iHash.update(e),this}digestInto(e){exists$1(this),bytes$2(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$2=(t,e,n)=>new HMAC$2(t,e).update(n).digest();hmac$2.create=(t,e)=>new HMAC$2(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash$1(t){return{hash:t,hmac:(e,...n)=>hmac$2(t,e,concatBytes$4(...n)),randomBytes:randomBytes$2}}function createCurve$1(t,e){const n=r=>weierstrass$1({...t,...getHash$1(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P$1=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N$1=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n$5=BigInt(1),_2n$3=BigInt(2),divNearest$1=(t,e)=>(t+e/_2n$3)/e;function sqrtMod$1(t){const e=secp256k1P$1,n=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),l=BigInt(88),h=t*t*t%e,f=h*h*t%e,u=pow2$1(f,n,e)*f%e,p=pow2$1(u,n,e)*f%e,g=pow2$1(p,_2n$3,e)*h%e,A=pow2$1(g,s,e)*g%e,w=pow2$1(A,o,e)*A%e,y=pow2$1(w,c,e)*w%e,_=pow2$1(y,l,e)*y%e,N=pow2$1(_,c,e)*w%e,C=pow2$1(N,n,e)*f%e,U=pow2$1(C,a,e)*A%e,b=pow2$1(U,r,e)*h%e,v=pow2$1(b,_2n$3,e);if(!Fp.eql(Fp.sqr(v),t))throw new Error("Cannot find square root");return v}const Fp=Field$1(secp256k1P$1,void 0,void 0,{sqrt:sqrtMod$1}),secp256k1$1=createCurve$1({a:BigInt(0),b:BigInt(7),Fp,n:secp256k1N$1,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=secp256k1N$1,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_1n$5*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,a=BigInt("0x100000000000000000000000000000000"),c=divNearest$1(o*t,e),l=divNearest$1(-r*t,e);let h=mod$1(t-c*n-l*s,e),f=mod$1(-c*r-l*o,e);const u=h>a,p=f>a;if(u&&(h=e-h),p&&(f=e-f),h>a||f>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:h,k2neg:p,k2:f}}}},sha256$3),_0n$5=BigInt(0),fe=t=>typeof t=="bigint"&&_0n$5<t&&t<secp256k1P$1,ge=t=>typeof t=="bigint"&&_0n$5<t&&t<secp256k1N$1,TAGGED_HASH_PREFIXES$1={};function taggedHash$1(t,...e){let n=TAGGED_HASH_PREFIXES$1[t];if(n===void 0){const r=sha256$3(Uint8Array.from(t,s=>s.charCodeAt(0)));n=concatBytes$3(r,r),TAGGED_HASH_PREFIXES$1[t]=n}return sha256$3(concatBytes$3(n,...e))}const pointToBytes$1=t=>t.toRawBytes(!0).slice(1),numTo32b$1=t=>numberToBytesBE$1(t,32),modP$1=t=>mod$1(t,secp256k1P$1),modN$1=t=>mod$1(t,secp256k1N$1),Point$1=secp256k1$1.ProjectivePoint,GmulAdd$1=(t,e,n)=>Point$1.BASE.multiplyAndAddUnsafe(t,e,n);function schnorrGetExtPubKey$1(t){let e=secp256k1$1.utils.normPrivateKeyToScalar(t),n=Point$1.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:modN$1(-e),bytes:pointToBytes$1(n)}}function lift_x$1(t){if(!fe(t))throw new Error("bad x: need 0 < x < p");const e=modP$1(t*t),n=modP$1(e*t+BigInt(7));let r=sqrtMod$1(n);r%_2n$3!==_0n$5&&(r=modP$1(-r));const s=new Point$1(t,r,_1n$5);return s.assertValidity(),s}function challenge$1(...t){return modN$1(bytesToNumberBE$1(taggedHash$1("BIP0340/challenge",...t)))}function schnorrGetPublicKey$1(t){return schnorrGetExtPubKey$1(t).bytes}function schnorrSign$1(t,e,n=randomBytes$2(32)){const r=ensureBytes$1("message",t),{bytes:s,scalar:o}=schnorrGetExtPubKey$1(e),a=ensureBytes$1("auxRand",n,32),c=numTo32b$1(o^bytesToNumberBE$1(taggedHash$1("BIP0340/aux",a))),l=taggedHash$1("BIP0340/nonce",c,s,r),h=modN$1(bytesToNumberBE$1(l));if(h===_0n$5)throw new Error("sign failed: k is zero");const{bytes:f,scalar:u}=schnorrGetExtPubKey$1(h),p=challenge$1(f,s,r),g=new Uint8Array(64);if(g.set(f,0),g.set(numTo32b$1(modN$1(u+p*o)),32),!schnorrVerify$1(g,r,s))throw new Error("sign: Invalid signature produced");return g}function schnorrVerify$1(t,e,n){const r=ensureBytes$1("signature",t,64),s=ensureBytes$1("message",e),o=ensureBytes$1("publicKey",n,32);try{const a=lift_x$1(bytesToNumberBE$1(o)),c=bytesToNumberBE$1(r.subarray(0,32));if(!fe(c))return!1;const l=bytesToNumberBE$1(r.subarray(32,64));if(!ge(l))return!1;const h=challenge$1(numTo32b$1(c),pointToBytes$1(a),s),f=GmulAdd$1(a,l,modN$1(-h));return!(!f||!f.hasEvenY()||f.toAffine().x!==c)}catch{return!1}}const schnorr$1={getPublicKey:schnorrGetPublicKey$1,sign:schnorrSign$1,verify:schnorrVerify$1,utils:{randomPrivateKey:secp256k1$1.utils.randomPrivateKey,lift_x:lift_x$1,pointToBytes:pointToBytes$1,numberToBytesBE:numberToBytesBE$1,bytesToNumberBE:bytesToNumberBE$1,taggedHash:taggedHash$1,mod:mod$1}},crypto$2=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const u8a=t=>t instanceof Uint8Array,createView$2=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),rotr$2=(t,e)=>t<<32-e|t>>>e,isLE$1=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE$1)throw new Error("Non little-endian hardware is not supported");const hexes$2=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$2(t){if(!u8a(t))throw new Error("Uint8Array expected");let e="";for(let n=0;n<t.length;n++)e+=hexes$2[t[n]];return e}function hexToBytes$2(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length;if(e%2)throw new Error("padded hex string expected, got unpadded hex of length "+e);const n=new Uint8Array(e/2);for(let r=0;r<n.length;r++){const s=r*2,o=t.slice(s,s+2),a=Number.parseInt(o,16);if(Number.isNaN(a)||a<0)throw new Error("Invalid byte sequence");n[r]=a}return n}function utf8ToBytes$3(t){if(typeof t!="string")throw new Error(`utf8ToBytes expected string, got ${typeof t}`);return new Uint8Array(new TextEncoder().encode(t))}function toBytes$2(t){if(typeof t=="string"&&(t=utf8ToBytes$3(t)),!u8a(t))throw new Error(`expected Uint8Array, got ${typeof t}`);return t}function concatBytes$2(...t){const e=new Uint8Array(t.reduce((r,s)=>r+s.length,0));let n=0;return t.forEach(r=>{if(!u8a(r))throw new Error("Uint8Array expected");e.set(r,n),n+=r.length}),e}let Hash$2=class{clone(){return this._cloneInto()}};function wrapConstructor$2(t){const e=r=>t().update(toBytes$2(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function randomBytes$1(t=32){if(crypto$2&&typeof crypto$2.getRandomValues=="function")return crypto$2.getRandomValues(new Uint8Array(t));throw new Error("crypto.getRandomValues must be defined")}function number$1(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`Wrong positive integer: ${t}`)}function bool$1(t){if(typeof t!="boolean")throw new Error(`Expected boolean, not ${t}`)}function bytes$1(t,...e){if(!(t instanceof Uint8Array))throw new Error("Expected Uint8Array");if(e.length>0&&!e.includes(t.length))throw new Error(`Expected Uint8Array of length ${e}, not of length=${t.length}`)}function hash(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");number$1(t.outputLen),number$1(t.blockLen)}function exists(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function output(t,e){bytes$1(t);const n=e.outputLen;if(t.length<n)throw new Error(`digestInto() expects output buffer of length at least ${n}`)}const assert={number:number$1,bool:bool$1,bytes:bytes$1,hash,exists,output};function setBigUint64$2(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(n>>s&o),c=Number(n&o),l=r?4:0,h=r?0:4;t.setUint32(e+l,a,r),t.setUint32(e+h,c,r)}class SHA2 extends Hash$2{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView$2(this.buffer)}update(e){assert.exists(this);const{view:n,buffer:r,blockLen:s}=this;e=toBytes$2(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView$2(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){assert.exists(this),assert.output(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let u=a;u<s;u++)n[u]=0;setBigUint64$2(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView$2(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=l/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<h;u++)c.setUint32(4*u,f[u],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%n&&e.buffer.set(r),e}}const Chi$2=(t,e,n)=>t&e^~t&n,Maj$2=(t,e,n)=>t&e^t&n^e&n,SHA256_K$2=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$2=new Uint32Array(64);let SHA256$2=class extends SHA2{constructor(){super(64,32,8,!1),this.A=IV[0]|0,this.B=IV[1]|0,this.C=IV[2]|0,this.D=IV[3]|0,this.E=IV[4]|0,this.F=IV[5]|0,this.G=IV[6]|0,this.H=IV[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,n,r,s,o,a,c,l]}set(e,n,r,s,o,a,c,l){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,n){for(let u=0;u<16;u++,n+=4)SHA256_W$2[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const p=SHA256_W$2[u-15],g=SHA256_W$2[u-2],A=rotr$2(p,7)^rotr$2(p,18)^p>>>3,w=rotr$2(g,17)^rotr$2(g,19)^g>>>10;SHA256_W$2[u]=w+SHA256_W$2[u-7]+A+SHA256_W$2[u-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:h,H:f}=this;for(let u=0;u<64;u++){const p=rotr$2(c,6)^rotr$2(c,11)^rotr$2(c,25),g=f+p+Chi$2(c,l,h)+SHA256_K$2[u]+SHA256_W$2[u]|0,w=(rotr$2(r,2)^rotr$2(r,13)^rotr$2(r,22))+Maj$2(r,s,o)|0;f=h,h=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+w|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,h=h+this.G|0,f=f+this.H|0,this.set(r,s,o,a,c,l,h,f)}roundClean(){SHA256_W$2.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};class SHA224 extends SHA256$2{constructor(){super(),this.A=-1056596264,this.B=914150663,this.C=812702999,this.D=-150054599,this.E=-4191439,this.F=1750603025,this.G=1694076839,this.H=-1090891868,this.outputLen=28}}const sha256$2=wrapConstructor$2(()=>new SHA256$2);wrapConstructor$2(()=>new SHA224);/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function assertNumber(t){if(!Number.isSafeInteger(t))throw new Error(`Wrong integer: ${t}`)}function chain$1(...t){const e=(s,o)=>a=>s(o(a)),n=Array.from(t).reverse().reduce((s,o)=>s?e(s,o.encode):o.encode,void 0),r=t.reduce((s,o)=>s?e(s,o.decode):o.decode,void 0);return{encode:n,decode:r}}function alphabet$1(t){return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return e.map(n=>{if(assertNumber(n),n<0||n>=t.length)throw new Error(`Digit index outside alphabet: ${n} (alphabet: ${t.length})`);return t[n]})},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("alphabet.decode input should be array of strings");return e.map(n=>{if(typeof n!="string")throw new Error(`alphabet.decode: not string element=${n}`);const r=t.indexOf(n);if(r===-1)throw new Error(`Unknown letter: "${n}". Allowed: ${t}`);return r})}}}function join$1(t=""){if(typeof t!="string")throw new Error("join separator should be string");return{encode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="string")throw new Error("join.encode input should be array of strings");for(let n of e)if(typeof n!="string")throw new Error(`join.encode: non-string input=${n}`);return e.join(t)},decode:e=>{if(typeof e!="string")throw new Error("join.decode input should be string");return e.split(t)}}}function padding(t,e="="){if(assertNumber(t),typeof e!="string")throw new Error("padding chr should be string");return{encode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let r of n)if(typeof r!="string")throw new Error(`padding.encode: non-string input=${r}`);for(;n.length*t%8;)n.push(e);return n},decode(n){if(!Array.isArray(n)||n.length&&typeof n[0]!="string")throw new Error("padding.encode input should be array of strings");for(let s of n)if(typeof s!="string")throw new Error(`padding.decode: non-string input=${s}`);let r=n.length;if(r*t%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;r>0&&n[r-1]===e;r--)if(!((r-1)*t%8))throw new Error("Invalid padding: string has too much padding");return n.slice(0,r)}}}function normalize$1(t){if(typeof t!="function")throw new Error("normalize fn should be function");return{encode:e=>e,decode:e=>t(e)}}function convertRadix(t,e,n){if(e<2)throw new Error(`convertRadix: wrong from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: wrong to=${n}, base cannot be less than 2`);if(!Array.isArray(t))throw new Error("convertRadix: data should be array");if(!t.length)return[];let r=0;const s=[],o=Array.from(t);for(o.forEach(a=>{if(assertNumber(a),a<0||a>=e)throw new Error(`Wrong integer: ${a}`)});;){let a=0,c=!0;for(let l=r;l<o.length;l++){const h=o[l],f=e*a+h;if(!Number.isSafeInteger(f)||e*a/e!==a||f-h!==e*a)throw new Error("convertRadix: carry overflow");if(a=f%n,o[l]=Math.floor(f/n),!Number.isSafeInteger(o[l])||o[l]*n+a!==f)throw new Error("convertRadix: carry overflow");if(c)o[l]?c=!1:r=l;else continue}if(s.push(a),c)break}for(let a=0;a<t.length-1&&t[a]===0;a++)s.push(0);return s.reverse()}const gcd$1=(t,e)=>e?gcd$1(e,t%e):t,radix2carry$1=(t,e)=>t+(e-gcd$1(t,e));function convertRadix2$1(t,e,n,r){if(!Array.isArray(t))throw new Error("convertRadix2: data should be array");if(e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(radix2carry$1(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${radix2carry$1(e,n)}`);let s=0,o=0;const a=2**n-1,c=[];for(const l of t){if(assertNumber(l),l>=2**e)throw new Error(`convertRadix2: invalid data word=${l} from=${e}`);if(s=s<<e|l,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=n;o-=n)c.push((s>>o-n&a)>>>0);s&=2**o-1}if(s=s<<n-o&a,!r&&o>=e)throw new Error("Excess padding");if(!r&&s)throw new Error(`Non-zero padding: ${s}`);return r&&o>0&&c.push(s>>>0),c}function radix(t){return assertNumber(t),{encode:e=>{if(!(e instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return convertRadix(Array.from(e),2**8,t)},decode:e=>{if(!Array.isArray(e)||e.length&&typeof e[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(convertRadix(e,t,2**8))}}}function radix2$1(t,e=!1){if(assertNumber(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry$1(8,t)>32||radix2carry$1(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!(n instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2$1(Array.from(n),8,t,!e)},decode:n=>{if(!Array.isArray(n)||n.length&&typeof n[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(convertRadix2$1(n,t,8,e))}}}function unsafeWrapper$1(t){if(typeof t!="function")throw new Error("unsafeWrapper fn should be function");return function(...e){try{return t.apply(null,e)}catch{}}}const base16=chain$1(radix2$1(4),alphabet$1("0123456789ABCDEF"),join$1("")),base32=chain$1(radix2$1(5),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),padding(5),join$1(""));chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHIJKLMNOPQRSTUV"),padding(5),join$1(""));chain$1(radix2$1(5),alphabet$1("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),join$1(""),normalize$1(t=>t.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1")));const base64=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),padding(6),join$1("")),base64url=chain$1(radix2$1(6),alphabet$1("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),padding(6),join$1("")),genBase58=t=>chain$1(radix(58),alphabet$1(t),join$1("")),base58=genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const XMR_BLOCK_LEN=[0,2,3,5,6,7,9,10,11],base58xmr={encode(t){let e="";for(let n=0;n<t.length;n+=8){const r=t.subarray(n,n+8);e+=base58.encode(r).padStart(XMR_BLOCK_LEN[r.length],"1")}return e},decode(t){let e=[];for(let n=0;n<t.length;n+=11){const r=t.slice(n,n+11),s=XMR_BLOCK_LEN.indexOf(r.length),o=base58.decode(r);for(let a=0;a<o.length-s;a++)if(o[a]!==0)throw new Error("base58xmr: wrong padding");e=e.concat(Array.from(o.slice(o.length-s)))}return Uint8Array.from(e)}},BECH_ALPHABET$1=chain$1(alphabet$1("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join$1("")),POLYMOD_GENERATORS$1=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod$1(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<POLYMOD_GENERATORS$1.length;r++)(e>>r&1)===1&&(n^=POLYMOD_GENERATORS$1[r]);return n}function bechChecksum$1(t,e,n=1){const r=t.length;let s=1;for(let o=0;o<r;o++){const a=t.charCodeAt(o);if(a<33||a>126)throw new Error(`Invalid prefix (${t})`);s=bech32Polymod$1(s)^a>>5}s=bech32Polymod$1(s);for(let o=0;o<r;o++)s=bech32Polymod$1(s)^t.charCodeAt(o)&31;for(let o of e)s=bech32Polymod$1(s)^o;for(let o=0;o<6;o++)s=bech32Polymod$1(s);return s^=n,BECH_ALPHABET$1.encode(convertRadix2$1([s%2**30],30,5,!1))}function genBech32$1(t){const e=t==="bech32"?1:734539939,n=radix2$1(5),r=n.decode,s=n.encode,o=unsafeWrapper$1(r);function a(f,u,p=90){if(typeof f!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof f}`);if(!Array.isArray(u)||u.length&&typeof u[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof u}`);const g=f.length+7+u.length;if(p!==!1&&g>p)throw new TypeError(`Length ${g} exceeds limit ${p}`);return f=f.toLowerCase(),`${f}1${BECH_ALPHABET$1.encode(u)}${bechChecksum$1(f,u,e)}`}function c(f,u=90){if(typeof f!="string")throw new Error(`bech32.decode input should be string, not ${typeof f}`);if(f.length<8||u!==!1&&f.length>u)throw new TypeError(`Wrong string length: ${f.length} (${f}). Expected (8..${u})`);const p=f.toLowerCase();if(f!==p&&f!==f.toUpperCase())throw new Error("String must be lowercase or uppercase");f=p;const g=f.lastIndexOf("1");if(g===0||g===-1)throw new Error('Letter "1" must be present between prefix and data only');const A=f.slice(0,g),w=f.slice(g+1);if(w.length<6)throw new Error("Data must be at least 6 characters long");const y=BECH_ALPHABET$1.decode(w).slice(0,-6),_=bechChecksum$1(A,y,e);if(!w.endsWith(_))throw new Error(`Invalid checksum in ${f}: expected "${_}"`);return{prefix:A,words:y}}const l=unsafeWrapper$1(c);function h(f){const{prefix:u,words:p}=c(f,!1);return{prefix:u,words:p,bytes:r(p)}}return{encode:a,decode:c,decodeToBytes:h,decodeUnsafe:l,fromWords:r,fromWordsUnsafe:o,toWords:s}}const bech32$1=genBech32$1("bech32");genBech32$1("bech32m");const utf8={encode:t=>new TextDecoder().decode(t),decode:t=>new TextEncoder().encode(t)},hex=chain$1(radix2$1(4),alphabet$1("0123456789abcdef"),join$1(""),normalize$1(t=>{if(typeof t!="string"||t.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof t} with length ${t.length}`);return t.toLowerCase()})),CODERS={utf8,hex,base16,base32,base64,base64url,base58,base58xmr};`${Object.keys(CODERS).join(", ")}`;function number(t){if(!Number.isSafeInteger(t)||t<0)throw new Error(`positive integer expected, not ${t}`)}function bool(t){if(typeof t!="boolean")throw new Error(`boolean expected, not ${t}`)}function isBytes$4(t){return t instanceof Uint8Array||t!=null&&typeof t=="object"&&t.constructor.name==="Uint8Array"}function bytes(t,...e){if(!isBytes$4(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error(`Uint8Array expected of length ${e}, not of length=${t.length}`)}/*! noble-ciphers - MIT License (c) 2023 Paul Miller (paulmillr.com) */const u32=t=>new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4)),isLE=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;if(!isLE)throw new Error("Non little-endian hardware is not supported");function checkOpts(t,e){if(e==null||typeof e!="object")throw new Error("options must be defined");return Object.assign(t,e)}function equalBytes$1(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}const wrapCipher=(t,e)=>(Object.assign(e,t),e),BLOCK_SIZE=16,POLY=283;function mul2(t){return t<<1^POLY&-(t>>7)}function mul(t,e){let n=0;for(;e>0;e>>=1)n^=t&-(e&1),t=mul2(t);return n}const sbox=(()=>{let t=new Uint8Array(256);for(let n=0,r=1;n<256;n++,r^=mul2(r))t[n]=r;const e=new Uint8Array(256);e[0]=99;for(let n=0;n<255;n++){let r=t[255-n];r|=r<<8,e[t[n]]=(r^r>>4^r>>5^r>>6^r>>7^99)&255}return e})(),invSbox=sbox.map((t,e)=>sbox.indexOf(e)),rotr32_8=t=>t<<24|t>>>8,rotl32_8=t=>t<<8|t>>>24;function genTtable(t,e){if(t.length!==256)throw new Error("Wrong sbox length");const n=new Uint32Array(256).map((h,f)=>e(t[f])),r=n.map(rotl32_8),s=r.map(rotl32_8),o=s.map(rotl32_8),a=new Uint32Array(256*256),c=new Uint32Array(256*256),l=new Uint16Array(256*256);for(let h=0;h<256;h++)for(let f=0;f<256;f++){const u=h*256+f;a[u]=n[h]^r[f],c[u]=s[h]^o[f],l[u]=t[h]<<8|t[f]}return{sbox:t,sbox2:l,T0:n,T1:r,T2:s,T3:o,T01:a,T23:c}}const tableEncoding=genTtable(sbox,t=>mul(t,3)<<24|t<<16|t<<8|mul(t,2)),tableDecoding=genTtable(invSbox,t=>mul(t,11)<<24|mul(t,13)<<16|mul(t,9)<<8|mul(t,14)),xPowers=(()=>{const t=new Uint8Array(16);for(let e=0,n=1;e<16;e++,n=mul2(n))t[e]=n;return t})();function expandKeyLE(t){bytes(t);const e=t.length;if(![16,24,32].includes(e))throw new Error(`aes: wrong key size: should be 16, 24 or 32, got: ${e}`);const{sbox2:n}=tableEncoding,r=u32(t),s=r.length,o=c=>applySbox(n,c,c,c,c),a=new Uint32Array(e+28);a.set(r);for(let c=s;c<a.length;c++){let l=a[c-1];c%s===0?l=o(rotr32_8(l))^xPowers[c/s-1]:s>6&&c%s===4&&(l=o(l)),a[c]=a[c-s]^l}return a}function expandKeyDecLE(t){const e=expandKeyLE(t),n=e.slice(),r=e.length,{sbox2:s}=tableEncoding,{T0:o,T1:a,T2:c,T3:l}=tableDecoding;for(let h=0;h<r;h+=4)for(let f=0;f<4;f++)n[h+f]=e[r-h-4+f];e.fill(0);for(let h=4;h<r-4;h++){const f=n[h],u=applySbox(s,f,f,f,f);n[h]=o[u&255]^a[u>>>8&255]^c[u>>>16&255]^l[u>>>24]}return n}function apply0123(t,e,n,r,s,o){return t[n<<8&65280|r>>>8&255]^e[s>>>8&65280|o>>>24&255]}function applySbox(t,e,n,r,s){return t[e&255|n&65280]|t[r>>>16&255|s>>>16&65280]<<16}function encrypt$2(t,e,n,r,s){const{sbox2:o,T01:a,T23:c}=tableEncoding;let l=0;e^=t[l++],n^=t[l++],r^=t[l++],s^=t[l++];const h=t.length/4-2;for(let A=0;A<h;A++){const w=t[l++]^apply0123(a,c,e,n,r,s),y=t[l++]^apply0123(a,c,n,r,s,e),_=t[l++]^apply0123(a,c,r,s,e,n),N=t[l++]^apply0123(a,c,s,e,n,r);e=w,n=y,r=_,s=N}const f=t[l++]^applySbox(o,e,n,r,s),u=t[l++]^applySbox(o,n,r,s,e),p=t[l++]^applySbox(o,r,s,e,n),g=t[l++]^applySbox(o,s,e,n,r);return{s0:f,s1:u,s2:p,s3:g}}function decrypt$2(t,e,n,r,s){const{sbox2:o,T01:a,T23:c}=tableDecoding;let l=0;e^=t[l++],n^=t[l++],r^=t[l++],s^=t[l++];const h=t.length/4-2;for(let A=0;A<h;A++){const w=t[l++]^apply0123(a,c,e,s,r,n),y=t[l++]^apply0123(a,c,n,e,s,r),_=t[l++]^apply0123(a,c,r,n,e,s),N=t[l++]^apply0123(a,c,s,r,n,e);e=w,n=y,r=_,s=N}const f=t[l++]^applySbox(o,e,s,r,n),u=t[l++]^applySbox(o,n,e,s,r),p=t[l++]^applySbox(o,r,n,e,s),g=t[l++]^applySbox(o,s,r,n,e);return{s0:f,s1:u,s2:p,s3:g}}function getDst(t,e){if(!e)return new Uint8Array(t);if(bytes(e),e.length<t)throw new Error(`aes: wrong destination length, expected at least ${t}, got: ${e.length}`);return e}function validateBlockDecrypt(t){if(bytes(t),t.length%BLOCK_SIZE!==0)throw new Error(`aes/(cbc-ecb).decrypt ciphertext should consist of blocks with size ${BLOCK_SIZE}`)}function validateBlockEncrypt(t,e,n){let r=t.length;const s=r%BLOCK_SIZE;if(!e&&s!==0)throw new Error("aec/(cbc-ecb): unpadded plaintext with disabled padding");const o=u32(t);if(e){let l=BLOCK_SIZE-s;l||(l=BLOCK_SIZE),r=r+l}const a=getDst(r,n),c=u32(a);return{b:o,o:c,out:a}}function validatePCKS(t,e){if(!e)return t;const n=t.length;if(!n)throw new Error("aes/pcks5: empty ciphertext not allowed");const r=t[n-1];if(r<=0||r>16)throw new Error(`aes/pcks5: wrong padding byte: ${r}`);const s=t.subarray(0,-r);for(let o=0;o<r;o++)if(t[n-o-1]!==r)throw new Error("aes/pcks5: wrong padding");return s}function padPCKS(t){const e=new Uint8Array(16),n=u32(e);e.set(t);const r=BLOCK_SIZE-t.length;for(let s=BLOCK_SIZE-r;s<BLOCK_SIZE;s++)e[s]=r;return n}const cbc=wrapCipher({blockSize:16,nonceLength:16},function(e,n,r={}){bytes(e),bytes(n,16);const s=!r.disablePadding;return{encrypt:(o,a)=>{const c=expandKeyLE(e),{b:l,o:h,out:f}=validateBlockEncrypt(o,s,a),u=u32(n);let p=u[0],g=u[1],A=u[2],w=u[3],y=0;for(;y+4<=l.length;)p^=l[y+0],g^=l[y+1],A^=l[y+2],w^=l[y+3],{s0:p,s1:g,s2:A,s3:w}=encrypt$2(c,p,g,A,w),h[y++]=p,h[y++]=g,h[y++]=A,h[y++]=w;if(s){const _=padPCKS(o.subarray(y*4));p^=_[0],g^=_[1],A^=_[2],w^=_[3],{s0:p,s1:g,s2:A,s3:w}=encrypt$2(c,p,g,A,w),h[y++]=p,h[y++]=g,h[y++]=A,h[y++]=w}return c.fill(0),f},decrypt:(o,a)=>{validateBlockDecrypt(o);const c=expandKeyDecLE(e),l=u32(n),h=getDst(o.length,a),f=u32(o),u=u32(h);let p=l[0],g=l[1],A=l[2],w=l[3];for(let y=0;y+4<=f.length;){const _=p,N=g,C=A,U=w;p=f[y+0],g=f[y+1],A=f[y+2],w=f[y+3];const{s0:b,s1:v,s2:$,s3:S}=decrypt$2(c,p,g,A,w);u[y++]=b^_,u[y++]=v^N,u[y++]=$^C,u[y++]=S^U}return c.fill(0),validatePCKS(h,s)}}}),_utf8ToBytes=t=>Uint8Array.from(t.split("").map(e=>e.charCodeAt(0))),sigma16=_utf8ToBytes("expand 16-byte k"),sigma32=_utf8ToBytes("expand 32-byte k"),sigma16_32=u32(sigma16),sigma32_32=u32(sigma32);sigma32_32.slice();function rotl(t,e){return t<<e|t>>>32-e}function isAligned32(t){return t.byteOffset%4===0}const BLOCK_LEN=64,BLOCK_LEN32=16,MAX_COUNTER=2**32-1,U32_EMPTY=new Uint32Array;function runCipher(t,e,n,r,s,o,a,c){const l=s.length,h=new Uint8Array(BLOCK_LEN),f=u32(h),u=isAligned32(s)&&isAligned32(o),p=u?u32(s):U32_EMPTY,g=u?u32(o):U32_EMPTY;for(let A=0;A<l;a++){if(t(e,n,r,f,a,c),a>=MAX_COUNTER)throw new Error("arx: counter overflow");const w=Math.min(BLOCK_LEN,l-A);if(u&&w===BLOCK_LEN){const y=A/4;if(A%4!==0)throw new Error("arx: invalid block position");for(let _=0,N;_<BLOCK_LEN32;_++)N=y+_,g[N]=p[N]^f[_];A+=BLOCK_LEN;continue}for(let y=0,_;y<w;y++)_=A+y,o[_]=s[_]^h[y];A+=w}}function createCipher(t,e){const{allowShortKeys:n,extendNonceFn:r,counterLength:s,counterRight:o,rounds:a}=checkOpts({allowShortKeys:!1,counterLength:8,counterRight:!1,rounds:20},e);if(typeof t!="function")throw new Error("core must be a function");return number(s),number(a),bool(o),bool(n),(c,l,h,f,u=0)=>{bytes(c),bytes(l),bytes(h);const p=h.length;if(f||(f=new Uint8Array(p)),bytes(f),number(u),u<0||u>=MAX_COUNTER)throw new Error("arx: counter overflow");if(f.length<p)throw new Error(`arx: output (${f.length}) is shorter than data (${p})`);const g=[];let A=c.length,w,y;if(A===32)w=c.slice(),g.push(w),y=sigma32_32;else if(A===16&&n)w=new Uint8Array(32),w.set(c),w.set(c,16),y=sigma16_32,g.push(w);else throw new Error(`arx: invalid 32-byte key, got length=${A}`);isAligned32(l)||(l=l.slice(),g.push(l));const _=u32(w);if(r){if(l.length!==24)throw new Error("arx: extended nonce must be 24 bytes");r(y,_,u32(l.subarray(0,16)),_),l=l.subarray(16)}const N=16-s;if(N!==l.length)throw new Error(`arx: nonce must be ${N} or 16 bytes`);if(N!==12){const U=new Uint8Array(12);U.set(l,o?0:12-l.length),l=U,g.push(l)}const C=u32(l);for(runCipher(t,y,_,C,h,f,u,a);g.length>0;)g.pop().fill(0);return f}}function chachaCore(t,e,n,r,s,o=20){let a=t[0],c=t[1],l=t[2],h=t[3],f=e[0],u=e[1],p=e[2],g=e[3],A=e[4],w=e[5],y=e[6],_=e[7],N=s,C=n[0],U=n[1],b=n[2],v=a,$=c,S=l,I=h,P=f,E=u,R=p,T=g,B=A,m=w,k=y,L=_,H=N,D=C,M=U,O=b;for(let K=0;K<o;K+=2)v=v+P|0,H=rotl(H^v,16),B=B+H|0,P=rotl(P^B,12),v=v+P|0,H=rotl(H^v,8),B=B+H|0,P=rotl(P^B,7),$=$+E|0,D=rotl(D^$,16),m=m+D|0,E=rotl(E^m,12),$=$+E|0,D=rotl(D^$,8),m=m+D|0,E=rotl(E^m,7),S=S+R|0,M=rotl(M^S,16),k=k+M|0,R=rotl(R^k,12),S=S+R|0,M=rotl(M^S,8),k=k+M|0,R=rotl(R^k,7),I=I+T|0,O=rotl(O^I,16),L=L+O|0,T=rotl(T^L,12),I=I+T|0,O=rotl(O^I,8),L=L+O|0,T=rotl(T^L,7),v=v+E|0,O=rotl(O^v,16),k=k+O|0,E=rotl(E^k,12),v=v+E|0,O=rotl(O^v,8),k=k+O|0,E=rotl(E^k,7),$=$+R|0,H=rotl(H^$,16),L=L+H|0,R=rotl(R^L,12),$=$+R|0,H=rotl(H^$,8),L=L+H|0,R=rotl(R^L,7),S=S+T|0,D=rotl(D^S,16),B=B+D|0,T=rotl(T^B,12),S=S+T|0,D=rotl(D^S,8),B=B+D|0,T=rotl(T^B,7),I=I+P|0,M=rotl(M^I,16),m=m+M|0,P=rotl(P^m,12),I=I+P|0,M=rotl(M^I,8),m=m+M|0,P=rotl(P^m,7);let F=0;r[F++]=a+v|0,r[F++]=c+$|0,r[F++]=l+S|0,r[F++]=h+I|0,r[F++]=f+P|0,r[F++]=u+E|0,r[F++]=p+R|0,r[F++]=g+T|0,r[F++]=A+B|0,r[F++]=w+m|0,r[F++]=y+k|0,r[F++]=_+L|0,r[F++]=N+H|0,r[F++]=C+D|0,r[F++]=U+M|0,r[F++]=b+O|0}const chacha20=createCipher(chachaCore,{counterRight:!1,counterLength:4,allowShortKeys:!1});let HMAC$1=class extends Hash$2{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,assert.hash(e);const r=toBytes$2(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return assert.exists(this),this.iHash.update(e),this}digestInto(e){assert.exists(this),assert.bytes(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}};const hmac$1=(t,e,n)=>new HMAC$1(t,e).update(n).digest();hmac$1.create=(t,e)=>new HMAC$1(t,e);function extract(t,e,n){return assert.hash(t),hmac$1(t,toBytes$2(n),toBytes$2(e))}const HKDF_COUNTER=new Uint8Array([0]),EMPTY_BUFFER=new Uint8Array;function expand(t,e,n,r=32){if(assert.hash(t),assert.number(r),r>255*t.outputLen)throw new Error("Length should be <= 255*HashLen");const s=Math.ceil(r/t.outputLen);n===void 0&&(n=EMPTY_BUFFER);const o=new Uint8Array(s*t.outputLen),a=hmac$1.create(t,e),c=a._cloneInto(),l=new Uint8Array(a.outputLen);for(let h=0;h<s;h++)HKDF_COUNTER[0]=h+1,c.update(h===0?EMPTY_BUFFER:l).update(n).update(HKDF_COUNTER).digestInto(l),o.set(l,t.outputLen*h),a._cloneInto(c);return a.destroy(),c.destroy(),l.fill(0),HKDF_COUNTER.fill(0),o.slice(0,r)}var __defProp=Object.defineProperty,__export=(t,e)=>{for(var n in e)__defProp(t,n,{get:e[n],enumerable:!0})},verifiedSymbol=Symbol("verified"),isRecord=t=>t instanceof Object;function validateEvent(t){if(!isRecord(t)||typeof t.kind!="number"||typeof t.content!="string"||typeof t.created_at!="number"||typeof t.pubkey!="string"||!t.pubkey.match(/^[a-f0-9]{64}$/)||!Array.isArray(t.tags))return!1;for(let e=0;e<t.tags.length;e++){let n=t.tags[e];if(!Array.isArray(n))return!1;for(let r=0;r<n.length;r++)if(typeof n[r]=="object")return!1}return!0}var utils_exports={};__export(utils_exports,{Queue:()=>Queue$1,QueueNode:()=>QueueNode,binarySearch:()=>binarySearch,insertEventIntoAscendingList:()=>insertEventIntoAscendingList,insertEventIntoDescendingList:()=>insertEventIntoDescendingList,normalizeURL:()=>normalizeURL,utf8Decoder:()=>utf8Decoder,utf8Encoder:()=>utf8Encoder});var utf8Decoder=new TextDecoder("utf-8"),utf8Encoder=new TextEncoder;function normalizeURL(t){t.indexOf("://")===-1&&(t="wss://"+t);let e=new URL(t);return e.pathname=e.pathname.replace(/\/+/g,"/"),e.pathname.endsWith("/")&&(e.pathname=e.pathname.slice(0,-1)),(e.port==="80"&&e.protocol==="ws:"||e.port==="443"&&e.protocol==="wss:")&&(e.port=""),e.searchParams.sort(),e.hash="",e.toString()}function insertEventIntoDescendingList(t,e){const[n,r]=binarySearch(t,s=>e.id===s.id?0:e.created_at===s.created_at?-1:s.created_at-e.created_at);return r||t.splice(n,0,e),t}function insertEventIntoAscendingList(t,e){const[n,r]=binarySearch(t,s=>e.id===s.id?0:e.created_at===s.created_at?-1:e.created_at-s.created_at);return r||t.splice(n,0,e),t}function binarySearch(t,e){let n=0,r=t.length-1;for(;n<=r;){const s=Math.floor((n+r)/2),o=e(t[s]);if(o===0)return[s,!0];o<0?r=s-1:n=s+1}return[n,!1]}var QueueNode=class{constructor(t){x(this,"value");x(this,"next",null);x(this,"prev",null);this.value=t}},Queue$1=class{constructor(){x(this,"first");x(this,"last");this.first=null,this.last=null}enqueue(e){const n=new QueueNode(e);return this.last?this.last===this.first?(this.last=n,this.last.prev=this.first,this.first.next=n):(n.prev=this.last,this.last.next=n,this.last=n):(this.first=n,this.last=n),!0}dequeue(){if(!this.first)return null;if(this.first===this.last){const n=this.first;return this.first=null,this.last=null,n.value}const e=this.first;return this.first=e.next,e.value}},JS=class{generateSecretKey(){return schnorr$1.utils.randomPrivateKey()}getPublicKey(t){return bytesToHex$2(schnorr$1.getPublicKey(t))}finalizeEvent(t,e){const n=t;return n.pubkey=bytesToHex$2(schnorr$1.getPublicKey(e)),n.id=getEventHash$1(n),n.sig=bytesToHex$2(schnorr$1.sign(getEventHash$1(n),e)),n[verifiedSymbol]=!0,n}verifyEvent(t){if(typeof t[verifiedSymbol]=="boolean")return t[verifiedSymbol];const e=getEventHash$1(t);if(e!==t.id)return t[verifiedSymbol]=!1,!1;try{const n=schnorr$1.verify(t.sig,e,t.pubkey);return t[verifiedSymbol]=n,n}catch{return t[verifiedSymbol]=!1,!1}}};function serializeEvent(t){if(!validateEvent(t))throw new Error("can't serialize event with wrong or missing properties");return JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content])}function getEventHash$1(t){let e=sha256$2(utf8Encoder.encode(serializeEvent(t)));return bytesToHex$2(e)}var i=new JS,generateSecretKey=i.generateSecretKey,getPublicKey=i.getPublicKey,finalizeEvent=i.finalizeEvent,verifyEvent=i.verifyEvent,kinds_exports={};__export(kinds_exports,{Application:()=>Application,BadgeAward:()=>BadgeAward,BadgeDefinition:()=>BadgeDefinition,BlockedRelaysList:()=>BlockedRelaysList,BookmarkList:()=>BookmarkList,Bookmarksets:()=>Bookmarksets,Calendar:()=>Calendar,CalendarEventRSVP:()=>CalendarEventRSVP,ChannelCreation:()=>ChannelCreation,ChannelHideMessage:()=>ChannelHideMessage,ChannelMessage:()=>ChannelMessage,ChannelMetadata:()=>ChannelMetadata,ChannelMuteUser:()=>ChannelMuteUser,ClassifiedListing:()=>ClassifiedListing,ClientAuth:()=>ClientAuth,CommunitiesList:()=>CommunitiesList,CommunityDefinition:()=>CommunityDefinition,CommunityPostApproval:()=>CommunityPostApproval,Contacts:()=>Contacts,CreateOrUpdateProduct:()=>CreateOrUpdateProduct,CreateOrUpdateStall:()=>CreateOrUpdateStall,Curationsets:()=>Curationsets,Date:()=>Date2,DirectMessageRelaysList:()=>DirectMessageRelaysList,DraftClassifiedListing:()=>DraftClassifiedListing,DraftLong:()=>DraftLong,Emojisets:()=>Emojisets,EncryptedDirectMessage:()=>EncryptedDirectMessage,EventDeletion:()=>EventDeletion,FileMetadata:()=>FileMetadata,FileServerPreference:()=>FileServerPreference,Followsets:()=>Followsets,GenericRepost:()=>GenericRepost,Genericlists:()=>Genericlists,GiftWrap:()=>GiftWrap,HTTPAuth:()=>HTTPAuth,Handlerinformation:()=>Handlerinformation,Handlerrecommendation:()=>Handlerrecommendation,Highlights:()=>Highlights,InterestsList:()=>InterestsList,Interestsets:()=>Interestsets,JobFeedback:()=>JobFeedback,JobRequest:()=>JobRequest,JobResult:()=>JobResult,Label:()=>Label,LightningPubRPC:()=>LightningPubRPC,LiveChatMessage:()=>LiveChatMessage,LiveEvent:()=>LiveEvent,LongFormArticle:()=>LongFormArticle,Metadata:()=>Metadata,Mutelist:()=>Mutelist,NWCWalletInfo:()=>NWCWalletInfo,NWCWalletRequest:()=>NWCWalletRequest,NWCWalletResponse:()=>NWCWalletResponse,NostrConnect:()=>NostrConnect,OpenTimestamps:()=>OpenTimestamps,Pinlist:()=>Pinlist,PrivateDirectMessage:()=>PrivateDirectMessage,ProblemTracker:()=>ProblemTracker,ProfileBadges:()=>ProfileBadges,PublicChatsList:()=>PublicChatsList,Reaction:()=>Reaction,RecommendRelay:()=>RecommendRelay,RelayList:()=>RelayList,Relaysets:()=>Relaysets,Report:()=>Report,Reporting:()=>Reporting,Repost:()=>Repost,Seal:()=>Seal,SearchRelaysList:()=>SearchRelaysList,ShortTextNote:()=>ShortTextNote,Time:()=>Time,UserEmojiList:()=>UserEmojiList,UserStatuses:()=>UserStatuses,Zap:()=>Zap,ZapGoal:()=>ZapGoal,ZapRequest:()=>ZapRequest,classifyKind:()=>classifyKind,isEphemeralKind:()=>isEphemeralKind,isKind:()=>isKind,isParameterizedReplaceableKind:()=>isParameterizedReplaceableKind,isRegularKind:()=>isRegularKind,isReplaceableKind:()=>isReplaceableKind});function isRegularKind(t){return 1e3<=t&&t<1e4||[1,2,4,5,6,7,8,16,40,41,42,43,44].includes(t)}function isReplaceableKind(t){return[0,3].includes(t)||1e4<=t&&t<2e4}function isEphemeralKind(t){return 2e4<=t&&t<3e4}function isParameterizedReplaceableKind(t){return 3e4<=t&&t<4e4}function classifyKind(t){return isRegularKind(t)?"regular":isReplaceableKind(t)?"replaceable":isEphemeralKind(t)?"ephemeral":isParameterizedReplaceableKind(t)?"parameterized":"unknown"}function isKind(t,e){const n=e instanceof Array?e:[e];return validateEvent(t)&&n.includes(t.kind)||!1}var Metadata=0,ShortTextNote=1,RecommendRelay=2,Contacts=3,EncryptedDirectMessage=4,EventDeletion=5,Repost=6,Reaction=7,BadgeAward=8,Seal=13,PrivateDirectMessage=14,GenericRepost=16,ChannelCreation=40,ChannelMetadata=41,ChannelMessage=42,ChannelHideMessage=43,ChannelMuteUser=44,OpenTimestamps=1040,GiftWrap=1059,FileMetadata=1063,LiveChatMessage=1311,ProblemTracker=1971,Report=1984,Reporting=1984,Label=1985,CommunityPostApproval=4550,JobRequest=5999,JobResult=6999,JobFeedback=7e3,ZapGoal=9041,ZapRequest=9734,Zap=9735,Highlights=9802,Mutelist=1e4,Pinlist=10001,RelayList=10002,BookmarkList=10003,CommunitiesList=10004,PublicChatsList=10005,BlockedRelaysList=10006,SearchRelaysList=10007,InterestsList=10015,UserEmojiList=10030,DirectMessageRelaysList=10050,FileServerPreference=10096,NWCWalletInfo=13194,LightningPubRPC=21e3,ClientAuth=22242,NWCWalletRequest=23194,NWCWalletResponse=23195,NostrConnect=24133,HTTPAuth=27235,Followsets=3e4,Genericlists=30001,Relaysets=30002,Bookmarksets=30003,Curationsets=30004,ProfileBadges=30008,BadgeDefinition=30009,Interestsets=30015,CreateOrUpdateStall=30017,CreateOrUpdateProduct=30018,LongFormArticle=30023,DraftLong=30024,Emojisets=30030,Application=30078,LiveEvent=30311,UserStatuses=30315,ClassifiedListing=30402,DraftClassifiedListing=30403,Date2=31922,Time=31923,Calendar=31924,CalendarEventRSVP=31925,Handlerrecommendation=31989,Handlerinformation=31990,CommunityDefinition=34550;function matchFilter(t,e){if(t.ids&&t.ids.indexOf(e.id)===-1||t.kinds&&t.kinds.indexOf(e.kind)===-1||t.authors&&t.authors.indexOf(e.pubkey)===-1)return!1;for(let n in t)if(n[0]==="#"){let r=n.slice(1),s=t[`#${r}`];if(s&&!e.tags.find(([o,a])=>o===n.slice(1)&&s.indexOf(a)!==-1))return!1}return!(t.since&&e.created_at<t.since||t.until&&e.created_at>t.until)}function matchFilters(t,e){for(let n=0;n<t.length;n++)if(matchFilter(t[n],e))return!0;return!1}var fakejson_exports={};__export(fakejson_exports,{getHex64:()=>getHex64,getInt:()=>getInt,getSubscriptionId:()=>getSubscriptionId,matchEventId:()=>matchEventId,matchEventKind:()=>matchEventKind,matchEventPubkey:()=>matchEventPubkey});function getHex64(t,e){let n=e.length+3,r=t.indexOf(`"${e}":`)+n,s=t.slice(r).indexOf('"')+r+1;return t.slice(s,s+64)}function getInt(t,e){let n=e.length,r=t.indexOf(`"${e}":`)+n+3,s=t.slice(r),o=Math.min(s.indexOf(","),s.indexOf("}"));return parseInt(s.slice(0,o),10)}function getSubscriptionId(t){let e=t.slice(0,22).indexOf('"EVENT"');if(e===-1)return null;let n=t.slice(e+7+1).indexOf('"');if(n===-1)return null;let r=e+7+1+n,s=t.slice(r+1,80).indexOf('"');if(s===-1)return null;let o=r+1+s;return t.slice(r+1,o)}function matchEventId(t,e){return e===getHex64(t,"id")}function matchEventPubkey(t,e){return e===getHex64(t,"pubkey")}function matchEventKind(t,e){return e===getInt(t,"kind")}var nip42_exports={};__export(nip42_exports,{makeAuthEvent:()=>makeAuthEvent});function makeAuthEvent(t,e){return{kind:ClientAuth,created_at:Math.floor(Date.now()/1e3),tags:[["relay",t],["challenge",e]],content:""}}var _WebSocket;try{_WebSocket=WebSocket}catch{}var _WebSocket2;try{_WebSocket2=WebSocket}catch{}var nip19_exports={};__export(nip19_exports,{BECH32_REGEX:()=>BECH32_REGEX$1,Bech32MaxSize:()=>Bech32MaxSize,NostrTypeGuard:()=>NostrTypeGuard,decode:()=>decode,encodeBytes:()=>encodeBytes,naddrEncode:()=>naddrEncode,neventEncode:()=>neventEncode,noteEncode:()=>noteEncode,nprofileEncode:()=>nprofileEncode,npubEncode:()=>npubEncode,nsecEncode:()=>nsecEncode});var NostrTypeGuard={isNProfile:t=>/^nprofile1[a-z\d]+$/.test(t||""),isNEvent:t=>/^nevent1[a-z\d]+$/.test(t||""),isNAddr:t=>/^naddr1[a-z\d]+$/.test(t||""),isNSec:t=>/^nsec1[a-z\d]{58}$/.test(t||""),isNPub:t=>/^npub1[a-z\d]{58}$/.test(t||""),isNote:t=>/^note1[a-z\d]+$/.test(t||""),isNcryptsec:t=>/^ncryptsec1[a-z\d]+$/.test(t||"")},Bech32MaxSize=5e3,BECH32_REGEX$1=/[\x21-\x7E]{1,83}1[023456789acdefghjklmnpqrstuvwxyz]{6,}/;function integerToUint8Array(t){const e=new Uint8Array(4);return e[0]=t>>24&255,e[1]=t>>16&255,e[2]=t>>8&255,e[3]=t&255,e}function decode(t){var s,o,a,c,l,h,f;let{prefix:e,words:n}=bech32$1.decode(t,Bech32MaxSize),r=new Uint8Array(bech32$1.fromWords(n));switch(e){case"nprofile":{let u=parseTLV(r);if(!((s=u[0])!=null&&s[0]))throw new Error("missing TLV 0 for nprofile");if(u[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");return{type:"nprofile",data:{pubkey:bytesToHex$2(u[0][0]),relays:u[1]?u[1].map(p=>utf8Decoder.decode(p)):[]}}}case"nevent":{let u=parseTLV(r);if(!((o=u[0])!=null&&o[0]))throw new Error("missing TLV 0 for nevent");if(u[0][0].length!==32)throw new Error("TLV 0 should be 32 bytes");if(u[2]&&u[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(u[3]&&u[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"nevent",data:{id:bytesToHex$2(u[0][0]),relays:u[1]?u[1].map(p=>utf8Decoder.decode(p)):[],author:(a=u[2])!=null&&a[0]?bytesToHex$2(u[2][0]):void 0,kind:(c=u[3])!=null&&c[0]?parseInt(bytesToHex$2(u[3][0]),16):void 0}}}case"naddr":{let u=parseTLV(r);if(!((l=u[0])!=null&&l[0]))throw new Error("missing TLV 0 for naddr");if(!((h=u[2])!=null&&h[0]))throw new Error("missing TLV 2 for naddr");if(u[2][0].length!==32)throw new Error("TLV 2 should be 32 bytes");if(!((f=u[3])!=null&&f[0]))throw new Error("missing TLV 3 for naddr");if(u[3][0].length!==4)throw new Error("TLV 3 should be 4 bytes");return{type:"naddr",data:{identifier:utf8Decoder.decode(u[0][0]),pubkey:bytesToHex$2(u[2][0]),kind:parseInt(bytesToHex$2(u[3][0]),16),relays:u[1]?u[1].map(p=>utf8Decoder.decode(p)):[]}}}case"nsec":return{type:e,data:r};case"npub":case"note":return{type:e,data:bytesToHex$2(r)};default:throw new Error(`unknown prefix ${e}`)}}function parseTLV(t){let e={},n=t;for(;n.length>0;){let r=n[0],s=n[1],o=n.slice(2,2+s);if(n=n.slice(2+s),o.length<s)throw new Error(`not enough data to read on TLV ${r}`);e[r]=e[r]||[],e[r].push(o)}return e}function nsecEncode(t){return encodeBytes("nsec",t)}function npubEncode(t){return encodeBytes("npub",hexToBytes$2(t))}function noteEncode(t){return encodeBytes("note",hexToBytes$2(t))}function encodeBech32(t,e){let n=bech32$1.toWords(e);return bech32$1.encode(t,n,Bech32MaxSize)}function encodeBytes(t,e){return encodeBech32(t,e)}function nprofileEncode(t){let e=encodeTLV({0:[hexToBytes$2(t.pubkey)],1:(t.relays||[]).map(n=>utf8Encoder.encode(n))});return encodeBech32("nprofile",e)}function neventEncode(t){let e;t.kind!==void 0&&(e=integerToUint8Array(t.kind));let n=encodeTLV({0:[hexToBytes$2(t.id)],1:(t.relays||[]).map(r=>utf8Encoder.encode(r)),2:t.author?[hexToBytes$2(t.author)]:[],3:e?[new Uint8Array(e)]:[]});return encodeBech32("nevent",n)}function naddrEncode(t){let e=new ArrayBuffer(4);new DataView(e).setUint32(0,t.kind,!1);let n=encodeTLV({0:[utf8Encoder.encode(t.identifier)],1:(t.relays||[]).map(r=>utf8Encoder.encode(r)),2:[hexToBytes$2(t.pubkey)],3:[new Uint8Array(e)]});return encodeBech32("naddr",n)}function encodeTLV(t){let e=[];return Object.entries(t).reverse().forEach(([n,r])=>{r.forEach(s=>{let o=new Uint8Array(s.length+2);o.set([parseInt(n)],0),o.set([s.length],1),o.set(s,2),e.push(o)})}),concatBytes$2(...e)}var nip04_exports={};__export(nip04_exports,{decrypt:()=>decrypt$1,encrypt:()=>encrypt$1});async function encrypt$1(t,e,n){const r=t instanceof Uint8Array?bytesToHex$2(t):t,s=secp256k1$1.getSharedSecret(r,"02"+e),o=getNormalizedX(s);let a=Uint8Array.from(randomBytes$1(16)),c=utf8Encoder.encode(n),l=cbc(o,a).encrypt(c),h=base64.encode(new Uint8Array(l)),f=base64.encode(new Uint8Array(a.buffer));return`${h}?iv=${f}`}async function decrypt$1(t,e,n){const r=t instanceof Uint8Array?bytesToHex$2(t):t;let[s,o]=n.split("?iv="),a=secp256k1$1.getSharedSecret(r,"02"+e),c=getNormalizedX(a),l=base64.decode(o),h=base64.decode(s),f=cbc(c,l).decrypt(h);return utf8Decoder.decode(f)}function getNormalizedX(t){return t.slice(1,33)}var nip05_exports={};__export(nip05_exports,{NIP05_REGEX:()=>NIP05_REGEX$1,isNip05:()=>isNip05,isValid:()=>isValid,queryProfile:()=>queryProfile,searchDomain:()=>searchDomain,useFetchImplementation:()=>useFetchImplementation});var NIP05_REGEX$1=/^(?:([\w.+-]+)@)?([\w_-]+(\.[\w_-]+)+)$/,isNip05=t=>NIP05_REGEX$1.test(t||""),_fetch;try{_fetch=fetch}catch{}function useFetchImplementation(t){_fetch=t}async function searchDomain(t,e=""){try{const n=`https://${t}/.well-known/nostr.json?name=${e}`,r=await _fetch(n,{redirect:"manual"});if(r.status!==200)throw Error("Wrong response code");return(await r.json()).names}catch{return{}}}async function queryProfile(t){var s;const e=t.match(NIP05_REGEX$1);if(!e)return null;const[,n="_",r]=e;try{const o=`https://${r}/.well-known/nostr.json?name=${n}`,a=await _fetch(o,{redirect:"manual"});if(a.status!==200)throw Error("Wrong response code");const c=await a.json(),l=c.names[n];return l?{pubkey:l,relays:(s=c.relays)==null?void 0:s[l]}:null}catch{return null}}async function isValid(t,e){const n=await queryProfile(e);return n?n.pubkey===t:!1}var nip10_exports={};__export(nip10_exports,{parse:()=>parse});function parse(t){const e={reply:void 0,root:void 0,mentions:[],profiles:[],quotes:[]};let n,r;for(let s=t.tags.length-1;s>=0;s--){const o=t.tags[s];if(o[0]==="e"&&o[1]){const[a,c,l,h,f]=o,u={id:c,relays:l?[l]:[],author:f};if(h==="root"){e.root=u;continue}if(h==="reply"){e.reply=u;continue}if(h==="mention"){e.mentions.push(u);continue}n?r=u:n=u,e.mentions.push(u);continue}if(o[0]==="q"&&o[1]){const[a,c,l]=o;e.quotes.push({id:c,relays:l?[l]:[]})}if(o[0]==="p"&&o[1]){e.profiles.push({pubkey:o[1],relays:o[2]?[o[2]]:[]});continue}}return e.root||(e.root=r||n||e.reply),e.reply||(e.reply=n||e.root),[e.reply,e.root].forEach(s=>{if(!s)return;let o=e.mentions.indexOf(s);if(o!==-1&&e.mentions.splice(o,1),s.author){let a=e.profiles.find(c=>c.pubkey===s.author);a&&a.relays&&(s.relays||(s.relays=[]),a.relays.forEach(c=>{var l;((l=s.relays)==null?void 0:l.indexOf(c))===-1&&s.relays.push(c)}),a.relays=s.relays)}}),e.mentions.forEach(s=>{if(s.author){let o=e.profiles.find(a=>a.pubkey===s.author);o&&o.relays&&(s.relays||(s.relays=[]),o.relays.forEach(a=>{s.relays.indexOf(a)===-1&&s.relays.push(a)}),o.relays=s.relays)}}),e}var nip11_exports={};__export(nip11_exports,{fetchRelayInformation:()=>fetchRelayInformation,useFetchImplementation:()=>useFetchImplementation2});var _fetch2;try{_fetch2=fetch}catch{}function useFetchImplementation2(t){_fetch2=t}async function fetchRelayInformation(t){return await(await fetch(t.replace("ws://","http://").replace("wss://","https://"),{headers:{Accept:"application/nostr+json"}})).json()}var nip13_exports={};__export(nip13_exports,{fastEventHash:()=>fastEventHash,getPow:()=>getPow,minePow:()=>minePow});function getPow(t){let e=0;for(let n=0;n<64;n+=8){const r=parseInt(t.substring(n,n+8),16);if(r===0)e+=32;else{e+=Math.clz32(r);break}}return e}function minePow(t,e){let n=0;const r=t,s=["nonce",n.toString(),e.toString()];for(r.tags.push(s);;){const o=Math.floor(new Date().getTime()/1e3);if(o!==r.created_at&&(n=0,r.created_at=o),s[1]=(++n).toString(),r.id=fastEventHash(r),getPow(r.id)>=e)break}return r}function fastEventHash(t){return bytesToHex$2(sha256$2(utf8Encoder.encode(JSON.stringify([0,t.pubkey,t.created_at,t.kind,t.tags,t.content]))))}var nip18_exports={};__export(nip18_exports,{finishRepostEvent:()=>finishRepostEvent,getRepostedEvent:()=>getRepostedEvent,getRepostedEventPointer:()=>getRepostedEventPointer});function finishRepostEvent(t,e,n,r){return finalizeEvent({kind:Repost,tags:[...t.tags??[],["e",e.id,n],["p",e.pubkey]],content:t.content===""?"":JSON.stringify(e),created_at:t.created_at},r)}function getRepostedEventPointer(t){if(t.kind!==Repost)return;let e,n;for(let r=t.tags.length-1;r>=0&&(e===void 0||n===void 0);r--){const s=t.tags[r];s.length>=2&&(s[0]==="e"&&e===void 0?e=s:s[0]==="p"&&n===void 0&&(n=s))}if(e!==void 0)return{id:e[1],relays:[e[2],n==null?void 0:n[2]].filter(r=>typeof r=="string"),author:n==null?void 0:n[1]}}function getRepostedEvent(t,{skipVerification:e}={}){const n=getRepostedEventPointer(t);if(n===void 0||t.content==="")return;let r;try{r=JSON.parse(t.content)}catch{return}if(r.id===n.id&&!(!e&&!verifyEvent(r)))return r}var nip21_exports={};__export(nip21_exports,{NOSTR_URI_REGEX:()=>NOSTR_URI_REGEX,parse:()=>parse2,test:()=>test});var NOSTR_URI_REGEX=new RegExp(`nostr:(${BECH32_REGEX$1.source})`);function test(t){return typeof t=="string"&&new RegExp(`^${NOSTR_URI_REGEX.source}$`).test(t)}function parse2(t){const e=t.match(new RegExp(`^${NOSTR_URI_REGEX.source}$`));if(!e)throw new Error(`Invalid Nostr URI: ${t}`);return{uri:e[0],value:e[1],decoded:decode(e[1])}}var nip25_exports={};__export(nip25_exports,{finishReactionEvent:()=>finishReactionEvent,getReactedEventPointer:()=>getReactedEventPointer});function finishReactionEvent(t,e,n){const r=e.tags.filter(s=>s.length>=2&&(s[0]==="e"||s[0]==="p"));return finalizeEvent({...t,kind:Reaction,tags:[...t.tags??[],...r,["e",e.id],["p",e.pubkey]],content:t.content??"+"},n)}function getReactedEventPointer(t){if(t.kind!==Reaction)return;let e,n;for(let r=t.tags.length-1;r>=0&&(e===void 0||n===void 0);r--){const s=t.tags[r];s.length>=2&&(s[0]==="e"&&e===void 0?e=s:s[0]==="p"&&n===void 0&&(n=s))}if(!(e===void 0||n===void 0))return{id:e[1],relays:[e[2],n[2]].filter(r=>r!==void 0),author:n[1]}}var nip27_exports={};__export(nip27_exports,{matchAll:()=>matchAll,regex:()=>regex,replaceAll:()=>replaceAll});var regex=()=>new RegExp(`\\b${NOSTR_URI_REGEX.source}\\b`,"g");function*matchAll(t){const e=t.matchAll(regex());for(const n of e)try{const[r,s]=n;yield{uri:r,value:s,decoded:decode(s),start:n.index,end:n.index+r.length}}catch{}}function replaceAll(t,e){return t.replaceAll(regex(),(n,r)=>e({uri:n,value:r,decoded:decode(r)}))}var nip28_exports={};__export(nip28_exports,{channelCreateEvent:()=>channelCreateEvent,channelHideMessageEvent:()=>channelHideMessageEvent,channelMessageEvent:()=>channelMessageEvent,channelMetadataEvent:()=>channelMetadataEvent,channelMuteUserEvent:()=>channelMuteUserEvent});var channelCreateEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelCreation,tags:[...t.tags??[]],content:n,created_at:t.created_at},e)},channelMetadataEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelMetadata,tags:[["e",t.channel_create_event_id],...t.tags??[]],content:n,created_at:t.created_at},e)},channelMessageEvent=(t,e)=>{const n=[["e",t.channel_create_event_id,t.relay_url,"root"]];return t.reply_to_channel_message_event_id&&n.push(["e",t.reply_to_channel_message_event_id,t.relay_url,"reply"]),finalizeEvent({kind:ChannelMessage,tags:[...n,...t.tags??[]],content:t.content,created_at:t.created_at},e)},channelHideMessageEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelHideMessage,tags:[["e",t.channel_message_event_id],...t.tags??[]],content:n,created_at:t.created_at},e)},channelMuteUserEvent=(t,e)=>{let n;if(typeof t.content=="object")n=JSON.stringify(t.content);else if(typeof t.content=="string")n=t.content;else return;return finalizeEvent({kind:ChannelMuteUser,tags:[["p",t.pubkey_to_mute],...t.tags??[]],content:n,created_at:t.created_at},e)},nip30_exports={};__export(nip30_exports,{EMOJI_SHORTCODE_REGEX:()=>EMOJI_SHORTCODE_REGEX,matchAll:()=>matchAll2,regex:()=>regex2,replaceAll:()=>replaceAll2});var EMOJI_SHORTCODE_REGEX=/:(\w+):/,regex2=()=>new RegExp(`\\B${EMOJI_SHORTCODE_REGEX.source}\\B`,"g");function*matchAll2(t){const e=t.matchAll(regex2());for(const n of e)try{const[r,s]=n;yield{shortcode:r,name:s,start:n.index,end:n.index+r.length}}catch{}}function replaceAll2(t,e){return t.replaceAll(regex2(),(n,r)=>e({shortcode:n,name:r}))}var nip39_exports={};__export(nip39_exports,{useFetchImplementation:()=>useFetchImplementation3,validateGithub:()=>validateGithub});var _fetch3;try{_fetch3=fetch}catch{}function useFetchImplementation3(t){_fetch3=t}async function validateGithub(t,e,n){try{return await(await _fetch3(`https://gist.github.com/${e}/${n}/raw`)).text()===`Verifying that I control the following Nostr public key: ${t}`}catch{return!1}}var nip44_exports={};__export(nip44_exports,{decrypt:()=>decrypt2,encrypt:()=>encrypt2,getConversationKey:()=>getConversationKey,v2:()=>v2});var minPlaintextSize=1,maxPlaintextSize=65535;function getConversationKey(t,e){const n=secp256k1$1.getSharedSecret(t,"02"+e).subarray(1,33);return extract(sha256$2,n,"nip44-v2")}function getMessageKeys(t,e){const n=expand(sha256$2,t,e,76);return{chacha_key:n.subarray(0,32),chacha_nonce:n.subarray(32,44),hmac_key:n.subarray(44,76)}}function calcPaddedLen(t){if(!Number.isSafeInteger(t)||t<1)throw new Error("expected positive integer");if(t<=32)return 32;const e=1<<Math.floor(Math.log2(t-1))+1,n=e<=256?32:e/8;return n*(Math.floor((t-1)/n)+1)}function writeU16BE(t){if(!Number.isSafeInteger(t)||t<minPlaintextSize||t>maxPlaintextSize)throw new Error("invalid plaintext size: must be between 1 and 65535 bytes");const e=new Uint8Array(2);return new DataView(e.buffer).setUint16(0,t,!1),e}function pad(t){const e=utf8Encoder.encode(t),n=e.length,r=writeU16BE(n),s=new Uint8Array(calcPaddedLen(n)-n);return concatBytes$2(r,e,s)}function unpad(t){const e=new DataView(t.buffer).getUint16(0),n=t.subarray(2,2+e);if(e<minPlaintextSize||e>maxPlaintextSize||n.length!==e||t.length!==2+calcPaddedLen(e))throw new Error("invalid padding");return utf8Decoder.decode(n)}function hmacAad(t,e,n){if(n.length!==32)throw new Error("AAD associated data must be 32 bytes");const r=concatBytes$2(n,e);return hmac$1(sha256$2,t,r)}function decodePayload(t){if(typeof t!="string")throw new Error("payload must be a valid string");const e=t.length;if(e<132||e>87472)throw new Error("invalid payload length: "+e);if(t[0]==="#")throw new Error("unknown encryption version");let n;try{n=base64.decode(t)}catch(o){throw new Error("invalid base64: "+o.message)}const r=n.length;if(r<99||r>65603)throw new Error("invalid data length: "+r);const s=n[0];if(s!==2)throw new Error("unknown encryption version "+s);return{nonce:n.subarray(1,33),ciphertext:n.subarray(33,-32),mac:n.subarray(-32)}}function encrypt2(t,e,n=randomBytes$1(32)){const{chacha_key:r,chacha_nonce:s,hmac_key:o}=getMessageKeys(e,n),a=pad(t),c=chacha20(r,s,a),l=hmacAad(o,c,n);return base64.encode(concatBytes$2(new Uint8Array([2]),n,c,l))}function decrypt2(t,e){const{nonce:n,ciphertext:r,mac:s}=decodePayload(t),{chacha_key:o,chacha_nonce:a,hmac_key:c}=getMessageKeys(e,n),l=hmacAad(c,r,n);if(!equalBytes$1(l,s))throw new Error("invalid MAC");const h=chacha20(o,a,r);return unpad(h)}var v2={utils:{getConversationKey,calcPaddedLen},encrypt:encrypt2,decrypt:decrypt2},nip47_exports={};__export(nip47_exports,{makeNwcRequestEvent:()=>makeNwcRequestEvent,parseConnectionString:()=>parseConnectionString});function parseConnectionString(t){const{pathname:e,searchParams:n}=new URL(t),r=e,s=n.get("relay"),o=n.get("secret");if(!r||!s||!o)throw new Error("invalid connection string");return{pubkey:r,relay:s,secret:o}}async function makeNwcRequestEvent(t,e,n){const s=await encrypt$1(e,t,JSON.stringify({method:"pay_invoice",params:{invoice:n}})),o={kind:NWCWalletRequest,created_at:Math.round(Date.now()/1e3),content:s,tags:[["p",t]]};return finalizeEvent(o,e)}var nip57_exports={};__export(nip57_exports,{getZapEndpoint:()=>getZapEndpoint,makeZapReceipt:()=>makeZapReceipt,makeZapRequest:()=>makeZapRequest,useFetchImplementation:()=>useFetchImplementation4,validateZapRequest:()=>validateZapRequest});var _fetch4;try{_fetch4=fetch}catch{}function useFetchImplementation4(t){_fetch4=t}async function getZapEndpoint(t){try{let e="",{lud06:n,lud16:r}=JSON.parse(t.content);if(n){let{words:a}=bech32$1.decode(n,1e3),c=bech32$1.fromWords(a);e=utf8Decoder.decode(c)}else if(r){let[a,c]=r.split("@");e=new URL(`/.well-known/lnurlp/${a}`,`https://${c}`).toString()}else return null;let o=await(await _fetch4(e)).json();if(o.allowsNostr&&o.nostrPubkey)return o.callback}catch{}return null}function makeZapRequest({profile:t,event:e,amount:n,relays:r,comment:s=""}){if(!n)throw new Error("amount not given");if(!t)throw new Error("profile not given");let o={kind:9734,created_at:Math.round(Date.now()/1e3),content:s,tags:[["p",t],["amount",n.toString()],["relays",...r]]};return e&&o.tags.push(["e",e]),o}function validateZapRequest(t){let e;try{e=JSON.parse(t)}catch{return"Invalid zap request JSON."}if(!validateEvent(e))return"Zap request is not a valid Nostr event.";if(!verifyEvent(e))return"Invalid signature on zap request.";let n=e.tags.find(([o,a])=>o==="p"&&a);if(!n)return"Zap request doesn't have a 'p' tag.";if(!n[1].match(/^[a-f0-9]{64}$/))return"Zap request 'p' tag is not valid hex.";let r=e.tags.find(([o,a])=>o==="e"&&a);return r&&!r[1].match(/^[a-f0-9]{64}$/)?"Zap request 'e' tag is not valid hex.":e.tags.find(([o,a])=>o==="relays"&&a)?null:"Zap request doesn't have a 'relays' tag."}function makeZapReceipt({zapRequest:t,preimage:e,bolt11:n,paidAt:r}){let s=JSON.parse(t),o=s.tags.filter(([c])=>c==="e"||c==="p"||c==="a"),a={kind:9735,created_at:Math.round(r.getTime()/1e3),content:"",tags:[...o,["P",s.pubkey],["bolt11",n],["description",t]]};return e&&a.tags.push(["preimage",e]),a}var nip59_exports={};__export(nip59_exports,{createRumor:()=>createRumor,createSeal:()=>createSeal,createWrap:()=>createWrap,unwrapEvent:()=>unwrapEvent,unwrapManyEvents:()=>unwrapManyEvents,wrapEvent:()=>wrapEvent,wrapManyEvents:()=>wrapManyEvents});var TWO_DAYS=2*24*60*60,now=()=>Math.round(Date.now()/1e3),randomNow=()=>Math.round(now()-Math.random()*TWO_DAYS),nip44ConversationKey=(t,e)=>getConversationKey(t,e),nip44Encrypt=(t,e,n)=>encrypt2(JSON.stringify(t),nip44ConversationKey(e,n)),nip44Decrypt=(t,e)=>JSON.parse(decrypt2(t.content,nip44ConversationKey(e,t.pubkey)));function createRumor(t,e){const n={created_at:now(),content:"",tags:[],...t,pubkey:getPublicKey(e)};return n.id=getEventHash$1(n),n}function createSeal(t,e,n){return finalizeEvent({kind:Seal,content:nip44Encrypt(t,e,n),created_at:randomNow(),tags:[]},e)}function createWrap(t,e){const n=generateSecretKey();return finalizeEvent({kind:GiftWrap,content:nip44Encrypt(t,n,e),created_at:randomNow(),tags:[["p",e]]},n)}function wrapEvent(t,e,n){const r=createRumor(t,e),s=createSeal(r,e,n);return createWrap(s,n)}function wrapManyEvents(t,e,n){if(!n||n.length===0)throw new Error("At least one recipient is required.");const r=getPublicKey(e),s=[wrapEvent(t,e,r)];return n.forEach(o=>{s.push(wrapEvent(t,e,o))}),s}function unwrapEvent(t,e){const n=nip44Decrypt(t,e);return nip44Decrypt(n,e)}function unwrapManyEvents(t,e){let n=[];return t.forEach(r=>{n.push(unwrapEvent(r,e))}),n.sort((r,s)=>r.created_at-s.created_at),n}var nip98_exports={};__export(nip98_exports,{getToken:()=>getToken,hashPayload:()=>hashPayload,unpackEventFromToken:()=>unpackEventFromToken,validateEvent:()=>validateEvent2,validateEventKind:()=>validateEventKind,validateEventMethodTag:()=>validateEventMethodTag,validateEventPayloadTag:()=>validateEventPayloadTag,validateEventTimestamp:()=>validateEventTimestamp,validateEventUrlTag:()=>validateEventUrlTag,validateToken:()=>validateToken});var _authorizationScheme="Nostr ";async function getToken(t,e,n,r=!1,s){const o={kind:HTTPAuth,tags:[["u",t],["method",e]],created_at:Math.round(new Date().getTime()/1e3),content:""};s&&o.tags.push(["payload",hashPayload(s)]);const a=await n(o);return(r?_authorizationScheme:"")+base64.encode(utf8Encoder.encode(JSON.stringify(a)))}async function validateToken(t,e,n){const r=await unpackEventFromToken(t).catch(o=>{throw o});return await validateEvent2(r,e,n).catch(o=>{throw o})}async function unpackEventFromToken(t){if(!t)throw new Error("Missing token");t=t.replace(_authorizationScheme,"");const e=utf8Decoder.decode(base64.decode(t));if(!e||e.length===0||!e.startsWith("{"))throw new Error("Invalid token");return JSON.parse(e)}function validateEventTimestamp(t){return t.created_at?Math.round(new Date().getTime()/1e3)-t.created_at<60:!1}function validateEventKind(t){return t.kind===HTTPAuth}function validateEventUrlTag(t,e){const n=t.tags.find(r=>r[0]==="u");return n?n.length>0&&n[1]===e:!1}function validateEventMethodTag(t,e){const n=t.tags.find(r=>r[0]==="method");return n?n.length>0&&n[1].toLowerCase()===e.toLowerCase():!1}function hashPayload(t){const e=sha256$2(utf8Encoder.encode(JSON.stringify(t)));return bytesToHex$2(e)}function validateEventPayloadTag(t,e){const n=t.tags.find(s=>s[0]==="payload");if(!n)return!1;const r=hashPayload(e);return n.length>0&&n[1]===r}async function validateEvent2(t,e,n,r){if(!verifyEvent(t))throw new Error("Invalid nostr event, signature invalid");if(!validateEventKind(t))throw new Error("Invalid nostr event, kind invalid");if(!validateEventTimestamp(t))throw new Error("Invalid nostr event, created_at timestamp invalid");if(!validateEventUrlTag(t,e))throw new Error("Invalid nostr event, url tag invalid");if(!validateEventMethodTag(t,n))throw new Error("Invalid nostr event, method tag invalid");if(r&&typeof r=="object"&&Object.keys(r).length>0&&!validateEventPayloadTag(t,r))throw new Error("Invalid nostr event, payload tag does not match request body hash");return!0}function getDefaultExportFromCjs(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}var lib$1={},types={},hasRequiredTypes;function requireTypes(){return hasRequiredTypes||(hasRequiredTypes=1,Object.defineProperty(types,"__esModule",{value:!0})),types}var ee={},taskCollection$1={},taskCollection={},utils$1={},hasRequiredUtils$1;function requireUtils$1(){if(hasRequiredUtils$1)return utils$1;hasRequiredUtils$1=1,Object.defineProperty(utils$1,"__esModule",{value:!0}),utils$1._fast_remove_single=void 0;function t(e,n){n!==-1&&(n===0?e.shift():n===e.length-1?e.length=e.length-1:e.splice(n,1))}return utils$1._fast_remove_single=t,utils$1}var bakeCollection={},hasRequiredBakeCollection;function requireBakeCollection(){return hasRequiredBakeCollection||(hasRequiredBakeCollection=1,function(exports){Object.defineProperty(exports,"__esModule",{value:!0}),exports.bakeCollectionVariadic=exports.bakeCollectionAwait=exports.bakeCollection=exports.BAKED_EMPTY_FUNC=void 0,exports.BAKED_EMPTY_FUNC=function(){};var FORLOOP_FALLBACK=1500;function generateArgsDefCode(t){var e="";if(t===0)return e;for(var n=0;n<t-1;++n)e+="arg"+String(n)+", ";return e+="arg"+String(t-1),e}function generateBodyPartsCode(t,e){for(var n="",r="",s=0;s<e;++s)n+="var f".concat(s," = collection[").concat(s,`];
`),r+="f".concat(s,"(").concat(t,`)
`);return{funcDefCode:n,funcCallCode:r}}function generateBodyPartsVariadicCode(t){for(var e="",n="",r=0;r<t;++r)e+="var f".concat(r," = collection[").concat(r,`];
`),n+="f".concat(r,`.apply(undefined, arguments)
`);return{funcDefCode:e,funcCallCode:n}}function bakeCollection(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                `).concat(funcCallCode,`
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);collection.length%10===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 10) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                        collection[i+4](`).concat(argsDefCode,`);
                        collection[i+5](`).concat(argsDefCode,`);
                        collection[i+6](`).concat(argsDefCode,`);
                        collection[i+7](`).concat(argsDefCode,`);
                        collection[i+8](`).concat(argsDefCode,`);
                        collection[i+9](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%4===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 4) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                        collection[i+3](`).concat(argsDefCode,`);
                    }
                });
            })`):collection.length%3===0?funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; i += 3) {
                        collection[i](`).concat(argsDefCode,`);
                        collection[i+1](`).concat(argsDefCode,`);
                        collection[i+2](`).concat(argsDefCode,`);
                    }
                });
            })`):funcFactoryCode=`(function(collection) {
                return (function(`.concat(argsDefCode,`) {
                    for (var i = 0; i < collection.length; ++i) {
                        collection[i](`).concat(argsDefCode,`);
                    }
                });
            })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollection=bakeCollection;function bakeCollectionAwait(collection,fixedArgsNum){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var argsDefCode=generateArgsDefCode(fixedArgsNum),_a=generateBodyPartsCode(argsDefCode,collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function(`).concat(argsDefCode,`) {
                return Promise.all([ `).concat(funcCallCode,` ]);
            });
        })`)}else{var argsDefCode=generateArgsDefCode(fixedArgsNum);funcFactoryCode=`(function(collection) {
            return (function(`.concat(argsDefCode,`) {
                var promises = Array(collection.length);
                for (var i = 0; i < collection.length; ++i) {
                    promises[i] = collection[i](`).concat(argsDefCode,`);
                }
                return Promise.all(promises);
            });
        })`)}{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionAwait=bakeCollectionAwait;function bakeCollectionVariadic(collection){if(collection.length===0)return exports.BAKED_EMPTY_FUNC;if(collection.length===1)return collection[0];var funcFactoryCode;if(collection.length<FORLOOP_FALLBACK){var _a=generateBodyPartsVariadicCode(collection.length),funcDefCode=_a.funcDefCode,funcCallCode=_a.funcCallCode;funcFactoryCode=`(function(collection) {
            `.concat(funcDefCode,`
            collection = undefined;
            return (function() {
                `).concat(funcCallCode,`
            });
        })`)}else funcFactoryCode=`(function(collection) {
            return (function() {
                for (var i = 0; i < collection.length; ++i) {
                    collection[i].apply(undefined, arguments);
                }
            });
        })`;{var funcFactory=eval(funcFactoryCode);return funcFactory(collection)}}exports.bakeCollectionVariadic=bakeCollectionVariadic}(bakeCollection)),bakeCollection}var hasRequiredTaskCollection$1;function requireTaskCollection$1(){if(hasRequiredTaskCollection$1)return taskCollection;hasRequiredTaskCollection$1=1;var t=taskCollection&&taskCollection.__spreadArray||function(C,U,b){if(b||arguments.length===2)for(var v=0,$=U.length,S;v<$;v++)(S||!(v in U))&&(S||(S=Array.prototype.slice.call(U,0,v)),S[v]=U[v]);return C.concat(S||Array.prototype.slice.call(U))};Object.defineProperty(taskCollection,"__esModule",{value:!0}),taskCollection.TaskCollection=void 0;var e=requireUtils$1(),n=requireBakeCollection();function r(C,U){var b=this.length;if(b>1)if(U){var v;(v=this._tasks).push.apply(v,arguments),this.length+=arguments.length}else this._tasks.push(C),this.length++;else if(U){if(b===1){var $=Array(1+arguments.length);$.push($),$.push.apply($,arguments),this._tasks=$}else{var $=Array(arguments.length);$.push.apply($,arguments),this._tasks=$}this.length+=arguments.length}else b===1?this._tasks=[this._tasks,C]:this._tasks=C,this.length++}function s(C,U){var b=this.length;if(b>1)if(U){var v;(v=this._tasks).push.apply(v,arguments),this.length+=arguments.length}else this._tasks.push(C),this.length++;else if(U){if(b===1){var $=Array(1+arguments.length);$.push($),$.push.apply($,arguments),this._tasks=$}else{var $=Array(arguments.length);$.push.apply($,arguments),this._tasks=$}this.length+=arguments.length}else b===1?this._tasks=[this._tasks,C]:this._tasks=C,this.length++;this.firstEmitBuildStrategy?this.call=u:this.rebuild()}function o(C){this.length!==0&&(this.length===1?this._tasks===C&&(this.length=0):((0,e._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(C)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length))}function a(C){if(this.length!==0){if(this.length===1)if(this._tasks===C&&(this.length=0),this.firstEmitBuildStrategy){this.call=n.BAKED_EMPTY_FUNC;return}else{this.rebuild();return}else(0,e._fast_remove_single)(this._tasks,this._tasks.lastIndexOf(C)),this._tasks.length===1?(this._tasks=this._tasks[0],this.length=1):this.length=this._tasks.length;this.firstEmitBuildStrategy?this.call=u:this.rebuild()}}function c(C){for(var U,b=[],v=1;v<arguments.length;v++)b[v-1]=arguments[v];this.length===0?(this._tasks=b,this.length=1):this.length===1?(b.unshift(this._tasks),this._tasks=b,this.length=this._tasks.length):((U=this._tasks).splice.apply(U,t([C,0],b,!1)),this.length=this._tasks.length)}function l(C){for(var U,b=[],v=1;v<arguments.length;v++)b[v-1]=arguments[v];this.length===0?(this._tasks=b,this.length=1):this.length===1?(b.unshift(this._tasks),this._tasks=b,this.length=this._tasks.length):((U=this._tasks).splice.apply(U,t([C,0],b,!1)),this.length=this._tasks.length),this.firstEmitBuildStrategy?this.call=u:this.rebuild()}function h(){this.length===0?this.call=n.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,n.bakeCollection)(this._tasks,this.argsNum)}function f(){this.length===0?this.call=n.BAKED_EMPTY_FUNC:this.length===1?this.call=this._tasks:this.call=(0,n.bakeCollectionAwait)(this._tasks,this.argsNum)}function u(){this.rebuild(),this.call.apply(void 0,arguments)}var p=function(){function C(U,b,v,$){b===void 0&&(b=!0),v===void 0&&(v=null),$===void 0&&($=!1),this.awaitTasks=$,this.call=n.BAKED_EMPTY_FUNC,this.argsNum=U,this.firstEmitBuildStrategy=!0,$?this.rebuild=f.bind(this):this.rebuild=h.bind(this),this.setAutoRebuild(b),v?typeof v=="function"?(this._tasks=v,this.length=1):(this._tasks=v,this.length=v.length):(this._tasks=null,this.length=0),b&&this.rebuild()}return C}();taskCollection.TaskCollection=p;function g(){this._tasks=null,this.length=0,this.call=n.BAKED_EMPTY_FUNC}function A(){this._tasks=null,this.length=0,this.call=n.BAKED_EMPTY_FUNC}function w(C){this.argsNum<C&&(this.argsNum=C,this.firstEmitBuildStrategy?this.call=u:this.rebuild())}function y(C){C?(this.push=s.bind(this),this.insert=l.bind(this),this.removeLast=a.bind(this)):(this.push=r.bind(this),this.insert=c.bind(this),this.removeLast=o.bind(this))}function _(){return this.length===0?[]:this.length===1?[this._tasks]:this._tasks}function N(C){C.length===0?(this.length=0,this.call=n.BAKED_EMPTY_FUNC):C.length===1?(this.length=1,this.call=C[0],this._tasks=C[0]):(this.length=C.length,this._tasks=C,this.firstEmitBuildStrategy?this.call=u:this.rebuild())}return p.prototype.fastClear=g,p.prototype.clear=A,p.prototype.growArgsNum=w,p.prototype.setAutoRebuild=y,p.prototype.tasksAsArray=_,p.prototype.setTasks=N,taskCollection}var hasRequiredTaskCollection;function requireTaskCollection(){return hasRequiredTaskCollection||(hasRequiredTaskCollection=1,function(t){var e=taskCollection$1&&taskCollection$1.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),n=taskCollection$1&&taskCollection$1.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(t,"__esModule",{value:!0}),n(requireTaskCollection$1(),t)}(taskCollection$1)),taskCollection$1}var utils={},hasRequiredUtils;function requireUtils(){if(hasRequiredUtils)return utils;hasRequiredUtils=1,Object.defineProperty(utils,"__esModule",{value:!0}),utils.nullObj=void 0;function t(){var e={};return e.__proto__=null,e}return utils.nullObj=t,utils}var hasRequiredEe;function requireEe(){if(hasRequiredEe)return ee;hasRequiredEe=1;var t=ee&&ee.__spreadArray||function(b,v,$){if($||arguments.length===2)for(var S=0,I=v.length,P;S<I;S++)(P||!(S in v))&&(P||(P=Array.prototype.slice.call(v,0,S)),P[S]=v[S]);return b.concat(P||Array.prototype.slice.call(v))};Object.defineProperty(ee,"__esModule",{value:!0}),ee.EventEmitter=void 0;var e=requireTaskCollection(),n=requireUtils$1(),r=requireUtils();function s(b,v,$,S,I,P){var E=this.events[b];if(E){if(E.length===0)return!1;if(E.argsNum<6)E.call(v,$,S,I,P);else{for(var R=new Array(E.argsNum),T=0,B=R.length;T<B;++T)R[T]=arguments[T+1];E.call.apply(void 0,R)}return!0}return!1}function o(b,v,$,S,I,P){var E=this.events[b],R;if(E!==void 0){if(E.length===0)return!1;if(E.argsNum<6)E.call(v,$,S,I,P);else{R=new Array(E.argsNum);for(var T=0,B=R.length;T<B;++T)R[T]=arguments[T+1];E.call.apply(void 0,R)}}var m=this.onceEvents[b];if(m){if(typeof m=="function")if(this.onceEvents[b]=void 0,arguments.length<6)m(v,$,S,I,P);else{if(R===void 0){R=new Array(arguments.length-1);for(var T=0,B=R.length;T<B;++T)R[T]=arguments[T+1]}m.apply(void 0,R)}else{var k=m;if(this.onceEvents[b]=void 0,arguments.length<6)for(var T=0;T<k.length;++T)k[T](v,$,S,I,P);else{if(R===void 0){R=new Array(arguments.length-1);for(var T=0,B=R.length;T<B;++T)R[T]=arguments[T+1]}for(var T=0;T<k.length;++T)k[T].apply(void 0,R)}}return!0}return E!==void 0}var a=function(){function b(){this.events=(0,r.nullObj)(),this.onceEvents=(0,r.nullObj)(),this._symbolKeys=new Set,this.maxListeners=1/0}return Object.defineProperty(b.prototype,"_eventsCount",{get:function(){return this.eventNames().length},enumerable:!1,configurable:!0}),b}();ee.EventEmitter=a;function c(b,v){switch(this.emit===s&&(this.emit=o),typeof this.onceEvents[b]){case"undefined":this.onceEvents[b]=v,typeof b=="symbol"&&this._symbolKeys.add(b);break;case"function":this.onceEvents[b]=[this.onceEvents[b],v];break;case"object":this.onceEvents[b].push(v)}return this}function l(b,v,$){if($===void 0&&($=v.length),typeof v!="function")throw new TypeError("The listener must be a function");var S=this.events[b];return S?(S.push(v),S.growArgsNum($),this.maxListeners!==1/0&&this.maxListeners<=S.length&&console.warn('Maximum event listeners for "'.concat(String(b),'" event!'))):(this.events[b]=new e.TaskCollection($,!0,v,!1),typeof b=="symbol"&&this._symbolKeys.add(b)),this}function h(b,v){var $=this.events[b];$&&$.removeLast(v);var S=this.onceEvents[b];return S&&(typeof S=="function"?this.onceEvents[b]=void 0:typeof S=="object"&&(S.length===1&&S[0]===v?this.onceEvents[b]=void 0:(0,n._fast_remove_single)(S,S.lastIndexOf(v)))),this}function f(b,v,$,S){$===void 0&&($=this),S===void 0&&(S=v.length),this.boundFuncs||(this.boundFuncs=new Map);var I=v.bind($);return this.boundFuncs.set(v,I),this.addListener(b,I,S)}function u(b,v){var $,S,I=($=this.boundFuncs)===null||$===void 0?void 0:$.get(v);return(S=this.boundFuncs)===null||S===void 0||S.delete(v),this.removeListener(b,I)}function p(b){return this.events[b]&&!!this.events[b].length}function g(b,v,$){if($===void 0&&($=v.length),typeof v!="function")throw new TypeError("The listener must be a function");var S=this.events[b];return!S||!(S instanceof e.TaskCollection)?(S=this.events[b]=new e.TaskCollection($,!0,v,!1),typeof b=="symbol"&&this._symbolKeys.add(b)):(S.insert(0,v),S.growArgsNum($),this.maxListeners!==1/0&&this.maxListeners<=S.length&&console.warn('Maximum event listeners for "'.concat(String(b),'" event!'))),this}function A(b,v){this.emit===s&&(this.emit=o);var $=this.onceEvents[b];return $?typeof $!="object"?(this.onceEvents[b]=[v,$],typeof b=="symbol"&&this._symbolKeys.add(b)):($.unshift(v),this.maxListeners!==1/0&&this.maxListeners<=$.length&&console.warn('Maximum event listeners for "'.concat(String(b),'" once event!'))):(this.onceEvents[b]=[v],typeof b=="symbol"&&this._symbolKeys.add(b)),this}function w(b){return b===void 0?(this.events=(0,r.nullObj)(),this.onceEvents=(0,r.nullObj)(),this._symbolKeys=new Set):(this.events[b]=void 0,this.onceEvents[b]=void 0,typeof b=="symbol"&&this._symbolKeys.delete(b)),this}function y(b){return this.maxListeners=b,this}function _(){return this.maxListeners}function N(b){return this.emit===s?this.events[b]?this.events[b].tasksAsArray().slice():[]:this.events[b]&&this.onceEvents[b]?t(t([],this.events[b].tasksAsArray(),!0),typeof this.onceEvents[b]=="function"?[this.onceEvents[b]]:this.onceEvents[b],!0):this.events[b]?this.events[b].tasksAsArray():this.onceEvents[b]?typeof this.onceEvents[b]=="function"?[this.onceEvents[b]]:this.onceEvents[b]:[]}function C(){var b=this;if(this.emit===s){var v=Object.keys(this.events);return t(t([],v,!0),Array.from(this._symbolKeys),!0).filter(function(S){return S in b.events&&b.events[S]&&b.events[S].length})}else{var v=Object.keys(this.events).filter(function(I){return b.events[I]&&b.events[I].length}),$=Object.keys(this.onceEvents).filter(function(I){return b.onceEvents[I]&&b.onceEvents[I].length});return t(t(t([],v,!0),$,!0),Array.from(this._symbolKeys).filter(function(I){return I in b.events&&b.events[I]&&b.events[I].length||I in b.onceEvents&&b.onceEvents[I]&&b.onceEvents[I].length}),!0)}}function U(b){return this.emit===s?this.events[b]&&this.events[b].length||0:(this.events[b]&&this.events[b].length||0)+(this.onceEvents[b]&&this.onceEvents[b].length||0)}return a.prototype.emit=s,a.prototype.on=l,a.prototype.once=c,a.prototype.addListener=l,a.prototype.removeListener=h,a.prototype.addListenerBound=f,a.prototype.removeListenerBound=u,a.prototype.hasListeners=p,a.prototype.prependListener=g,a.prototype.prependOnceListener=A,a.prototype.off=h,a.prototype.removeAllListeners=w,a.prototype.setMaxListeners=y,a.prototype.getMaxListeners=_,a.prototype.listeners=N,a.prototype.eventNames=C,a.prototype.listenerCount=U,ee}var hasRequiredLib$1;function requireLib$1(){return hasRequiredLib$1||(hasRequiredLib$1=1,function(t){var e=lib$1&&lib$1.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),n=lib$1&&lib$1.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(t,"__esModule",{value:!0}),n(requireTypes(),t),n(requireEe(),t)}(lib$1)),lib$1}var libExports=requireLib$1(),browser={exports:{}},ms,hasRequiredMs;function requireMs(){if(hasRequiredMs)return ms;hasRequiredMs=1;var t=1e3,e=t*60,n=e*60,r=n*24,s=r*7,o=r*365.25;ms=function(f,u){u=u||{};var p=typeof f;if(p==="string"&&f.length>0)return a(f);if(p==="number"&&isFinite(f))return u.long?l(f):c(f);throw new Error("val is not a non-empty string or a valid number. val="+JSON.stringify(f))};function a(f){if(f=String(f),!(f.length>100)){var u=/^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(f);if(u){var p=parseFloat(u[1]),g=(u[2]||"ms").toLowerCase();switch(g){case"years":case"year":case"yrs":case"yr":case"y":return p*o;case"weeks":case"week":case"w":return p*s;case"days":case"day":case"d":return p*r;case"hours":case"hour":case"hrs":case"hr":case"h":return p*n;case"minutes":case"minute":case"mins":case"min":case"m":return p*e;case"seconds":case"second":case"secs":case"sec":case"s":return p*t;case"milliseconds":case"millisecond":case"msecs":case"msec":case"ms":return p;default:return}}}}function c(f){var u=Math.abs(f);return u>=r?Math.round(f/r)+"d":u>=n?Math.round(f/n)+"h":u>=e?Math.round(f/e)+"m":u>=t?Math.round(f/t)+"s":f+"ms"}function l(f){var u=Math.abs(f);return u>=r?h(f,u,r,"day"):u>=n?h(f,u,n,"hour"):u>=e?h(f,u,e,"minute"):u>=t?h(f,u,t,"second"):f+" ms"}function h(f,u,p,g){var A=u>=p*1.5;return Math.round(f/p)+" "+g+(A?"s":"")}return ms}var common,hasRequiredCommon;function requireCommon(){if(hasRequiredCommon)return common;hasRequiredCommon=1;function t(e){r.debug=r,r.default=r,r.coerce=h,r.disable=c,r.enable=o,r.enabled=l,r.humanize=requireMs(),r.destroy=f,Object.keys(e).forEach(u=>{r[u]=e[u]}),r.names=[],r.skips=[],r.formatters={};function n(u){let p=0;for(let g=0;g<u.length;g++)p=(p<<5)-p+u.charCodeAt(g),p|=0;return r.colors[Math.abs(p)%r.colors.length]}r.selectColor=n;function r(u){let p,g=null,A,w;function y(..._){if(!y.enabled)return;const N=y,C=Number(new Date),U=C-(p||C);N.diff=U,N.prev=p,N.curr=C,p=C,_[0]=r.coerce(_[0]),typeof _[0]!="string"&&_.unshift("%O");let b=0;_[0]=_[0].replace(/%([a-zA-Z%])/g,($,S)=>{if($==="%%")return"%";b++;const I=r.formatters[S];if(typeof I=="function"){const P=_[b];$=I.call(N,P),_.splice(b,1),b--}return $}),r.formatArgs.call(N,_),(N.log||r.log).apply(N,_)}return y.namespace=u,y.useColors=r.useColors(),y.color=r.selectColor(u),y.extend=s,y.destroy=r.destroy,Object.defineProperty(y,"enabled",{enumerable:!0,configurable:!1,get:()=>g!==null?g:(A!==r.namespaces&&(A=r.namespaces,w=r.enabled(u)),w),set:_=>{g=_}}),typeof r.init=="function"&&r.init(y),y}function s(u,p){const g=r(this.namespace+(typeof p>"u"?":":p)+u);return g.log=this.log,g}function o(u){r.save(u),r.namespaces=u,r.names=[],r.skips=[];const p=(typeof u=="string"?u:"").trim().replace(" ",",").split(",").filter(Boolean);for(const g of p)g[0]==="-"?r.skips.push(g.slice(1)):r.names.push(g)}function a(u,p){let g=0,A=0,w=-1,y=0;for(;g<u.length;)if(A<p.length&&(p[A]===u[g]||p[A]==="*"))p[A]==="*"?(w=A,y=g,A++):(g++,A++);else if(w!==-1)A=w+1,y++,g=y;else return!1;for(;A<p.length&&p[A]==="*";)A++;return A===p.length}function c(){const u=[...r.names,...r.skips.map(p=>"-"+p)].join(",");return r.enable(""),u}function l(u){for(const p of r.skips)if(a(u,p))return!1;for(const p of r.names)if(a(u,p))return!0;return!1}function h(u){return u instanceof Error?u.stack||u.message:u}function f(){console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.")}return r.enable(r.load()),r}return common=t,common}var hasRequiredBrowser;function requireBrowser(){return hasRequiredBrowser||(hasRequiredBrowser=1,function(t,e){var n={};e.formatArgs=s,e.save=o,e.load=a,e.useColors=r,e.storage=c(),e.destroy=(()=>{let h=!1;return()=>{h||(h=!0,console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`."))}})(),e.colors=["#0000CC","#0000FF","#0033CC","#0033FF","#0066CC","#0066FF","#0099CC","#0099FF","#00CC00","#00CC33","#00CC66","#00CC99","#00CCCC","#00CCFF","#3300CC","#3300FF","#3333CC","#3333FF","#3366CC","#3366FF","#3399CC","#3399FF","#33CC00","#33CC33","#33CC66","#33CC99","#33CCCC","#33CCFF","#6600CC","#6600FF","#6633CC","#6633FF","#66CC00","#66CC33","#9900CC","#9900FF","#9933CC","#9933FF","#99CC00","#99CC33","#CC0000","#CC0033","#CC0066","#CC0099","#CC00CC","#CC00FF","#CC3300","#CC3333","#CC3366","#CC3399","#CC33CC","#CC33FF","#CC6600","#CC6633","#CC9900","#CC9933","#CCCC00","#CCCC33","#FF0000","#FF0033","#FF0066","#FF0099","#FF00CC","#FF00FF","#FF3300","#FF3333","#FF3366","#FF3399","#FF33CC","#FF33FF","#FF6600","#FF6633","#FF9900","#FF9933","#FFCC00","#FFCC33"];function r(){if(typeof window<"u"&&window.process&&(window.process.type==="renderer"||window.process.__nwjs))return!0;if(typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/))return!1;let h;return typeof document<"u"&&document.documentElement&&document.documentElement.style&&document.documentElement.style.WebkitAppearance||typeof window<"u"&&window.console&&(window.console.firebug||window.console.exception&&window.console.table)||typeof navigator<"u"&&navigator.userAgent&&(h=navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/))&&parseInt(h[1],10)>=31||typeof navigator<"u"&&navigator.userAgent&&navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/)}function s(h){if(h[0]=(this.useColors?"%c":"")+this.namespace+(this.useColors?" %c":" ")+h[0]+(this.useColors?"%c ":" ")+"+"+t.exports.humanize(this.diff),!this.useColors)return;const f="color: "+this.color;h.splice(1,0,f,"color: inherit");let u=0,p=0;h[0].replace(/%[a-zA-Z%]/g,g=>{g!=="%%"&&(u++,g==="%c"&&(p=u))}),h.splice(p,0,f)}e.log=console.debug||console.log||(()=>{});function o(h){try{h?e.storage.setItem("debug",h):e.storage.removeItem("debug")}catch{}}function a(){let h;try{h=e.storage.getItem("debug")}catch{}return!h&&typeof process<"u"&&"env"in process&&(h=n.DEBUG),h}function c(){try{return localStorage}catch{}}t.exports=requireCommon()(e);const{formatters:l}=t.exports;l.j=function(h){try{return JSON.stringify(h)}catch(f){return"[UnexpectedJSONParseError]: "+f.message}}}(browser,browser.exports)),browser.exports}var browserExports=requireBrowser();const debug7=getDefaultExportFromCjs(browserExports);function isBytes$3(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function abytes$2(t,...e){if(!isBytes$3(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function aexists$1(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function aoutput$1(t,e){abytes$2(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const createView$1=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),rotr$1=(t,e)=>t<<32-e|t>>>e,hexes$1=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex$1(t){abytes$2(t);let e="";for(let n=0;n<t.length;n++)e+=hexes$1[t[n]];return e}const asciis$1={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16$1(t){if(t>=asciis$1._0&&t<=asciis$1._9)return t-asciis$1._0;if(t>=asciis$1.A&&t<=asciis$1.F)return t-(asciis$1.A-10);if(t>=asciis$1.a&&t<=asciis$1.f)return t-(asciis$1.a-10)}function hexToBytes$1(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let s=0,o=0;s<n;s++,o+=2){const a=asciiToBase16$1(t.charCodeAt(o)),c=asciiToBase16$1(t.charCodeAt(o+1));if(a===void 0||c===void 0){const l=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+l+'" at index '+o)}r[s]=a*16+c}return r}function utf8ToBytes$2(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function toBytes$1(t){return typeof t=="string"&&(t=utf8ToBytes$2(t)),abytes$2(t),t}let Hash$1=class{clone(){return this._cloneInto()}};function wrapConstructor$1(t){const e=r=>t().update(toBytes$1(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function setBigUint64$1(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(n>>s&o),c=Number(n&o),l=r?4:0,h=r?0:4;t.setUint32(e+l,a,r),t.setUint32(e+h,c,r)}const Chi$1=(t,e,n)=>t&e^~t&n,Maj$1=(t,e,n)=>t&e^t&n^e&n;let HashMD$1=class extends Hash$1{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView$1(this.buffer)}update(e){aexists$1(this);const{view:n,buffer:r,blockLen:s}=this;e=toBytes$1(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView$1(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists$1(this),aoutput$1(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let u=a;u<s;u++)n[u]=0;setBigUint64$1(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView$1(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=l/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<h;u++)c.setUint32(4*u,f[u],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%n&&e.buffer.set(r),e}};const SHA256_K$1=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV$1=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W$1=new Uint32Array(64);let SHA256$1=class extends HashMD$1{constructor(){super(64,32,8,!1),this.A=SHA256_IV$1[0]|0,this.B=SHA256_IV$1[1]|0,this.C=SHA256_IV$1[2]|0,this.D=SHA256_IV$1[3]|0,this.E=SHA256_IV$1[4]|0,this.F=SHA256_IV$1[5]|0,this.G=SHA256_IV$1[6]|0,this.H=SHA256_IV$1[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,n,r,s,o,a,c,l]}set(e,n,r,s,o,a,c,l){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,n){for(let u=0;u<16;u++,n+=4)SHA256_W$1[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const p=SHA256_W$1[u-15],g=SHA256_W$1[u-2],A=rotr$1(p,7)^rotr$1(p,18)^p>>>3,w=rotr$1(g,17)^rotr$1(g,19)^g>>>10;SHA256_W$1[u]=w+SHA256_W$1[u-7]+A+SHA256_W$1[u-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:h,H:f}=this;for(let u=0;u<64;u++){const p=rotr$1(c,6)^rotr$1(c,11)^rotr$1(c,25),g=f+p+Chi$1(c,l,h)+SHA256_K$1[u]+SHA256_W$1[u]|0,w=(rotr$1(r,2)^rotr$1(r,13)^rotr$1(r,22))+Maj$1(r,s,o)|0;f=h,h=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+w|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,h=h+this.G|0,f=f+this.H|0,this.set(r,s,o,a,c,l,h,f)}roundClean(){SHA256_W$1.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}};const sha256$1=wrapConstructor$1(()=>new SHA256$1);function anumber$1(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function isBytes$2(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function abytes$1(t,...e){if(!isBytes$2(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function ahash(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.wrapConstructor");anumber$1(t.outputLen),anumber$1(t.blockLen)}function aexists(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function aoutput(t,e){abytes$1(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}const crypto$1=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */const createView=t=>new DataView(t.buffer,t.byteOffset,t.byteLength),rotr=(t,e)=>t<<32-e|t>>>e;function utf8ToBytes$1(t){if(typeof t!="string")throw new Error("utf8ToBytes expected string, got "+typeof t);return new Uint8Array(new TextEncoder().encode(t))}function toBytes(t){return typeof t=="string"&&(t=utf8ToBytes$1(t)),abytes$1(t),t}function concatBytes$1(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];abytes$1(s),e+=s.length}const n=new Uint8Array(e);for(let r=0,s=0;r<t.length;r++){const o=t[r];n.set(o,s),s+=o.length}return n}class Hash{clone(){return this._cloneInto()}}function wrapConstructor(t){const e=r=>t().update(toBytes(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function randomBytes(t=32){if(crypto$1&&typeof crypto$1.getRandomValues=="function")return crypto$1.getRandomValues(new Uint8Array(t));if(crypto$1&&typeof crypto$1.randomBytes=="function")return crypto$1.randomBytes(t);throw new Error("crypto.getRandomValues must be defined")}function setBigUint64(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),o=BigInt(4294967295),a=Number(n>>s&o),c=Number(n&o),l=r?4:0,h=r?0:4;t.setUint32(e+l,a,r),t.setUint32(e+h,c,r)}const Chi=(t,e,n)=>t&e^~t&n,Maj=(t,e,n)=>t&e^t&n^e&n;class HashMD extends Hash{constructor(e,n,r,s){super(),this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.buffer=new Uint8Array(e),this.view=createView(this.buffer)}update(e){aexists(this);const{view:n,buffer:r,blockLen:s}=this;e=toBytes(e);const o=e.length;for(let a=0;a<o;){const c=Math.min(s-this.pos,o-a);if(c===s){const l=createView(e);for(;s<=o-a;a+=s)this.process(l,a);continue}r.set(e.subarray(a,a+c),this.pos),this.pos+=c,a+=c,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){aexists(this),aoutput(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:o}=this;let{pos:a}=this;n[a++]=128,this.buffer.subarray(a).fill(0),this.padOffset>s-a&&(this.process(r,0),a=0);for(let u=a;u<s;u++)n[u]=0;setBigUint64(r,s-8,BigInt(this.length*8),o),this.process(r,0);const c=createView(e),l=this.outputLen;if(l%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const h=l/4,f=this.get();if(h>f.length)throw new Error("_sha2: outputLen bigger than state");for(let u=0;u<h;u++)c.setUint32(4*u,f[u],o)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:o,destroyed:a,pos:c}=this;return e.length=s,e.pos=c,e.finished=o,e.destroyed=a,s%n&&e.buffer.set(r),e}}const SHA256_K=new Uint32Array([1116352408,1899447441,3049323471,3921009573,961987163,1508970993,2453635748,2870763221,3624381080,310598401,607225278,1426881987,1925078388,2162078206,2614888103,3248222580,3835390401,4022224774,264347078,604807628,770255983,1249150122,1555081692,1996064986,2554220882,2821834349,2952996808,3210313671,3336571891,3584528711,113926993,338241895,666307205,773529912,1294757372,1396182291,1695183700,1986661051,2177026350,2456956037,2730485921,2820302411,3259730800,3345764771,3516065817,3600352804,4094571909,275423344,430227734,506948616,659060556,883997877,958139571,1322822218,1537002063,1747873779,1955562222,2024104815,2227730452,2361852424,2428436474,2756734187,3204031479,3329325298]),SHA256_IV=new Uint32Array([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),SHA256_W=new Uint32Array(64);class SHA256 extends HashMD{constructor(){super(64,32,8,!1),this.A=SHA256_IV[0]|0,this.B=SHA256_IV[1]|0,this.C=SHA256_IV[2]|0,this.D=SHA256_IV[3]|0,this.E=SHA256_IV[4]|0,this.F=SHA256_IV[5]|0,this.G=SHA256_IV[6]|0,this.H=SHA256_IV[7]|0}get(){const{A:e,B:n,C:r,D:s,E:o,F:a,G:c,H:l}=this;return[e,n,r,s,o,a,c,l]}set(e,n,r,s,o,a,c,l){this.A=e|0,this.B=n|0,this.C=r|0,this.D=s|0,this.E=o|0,this.F=a|0,this.G=c|0,this.H=l|0}process(e,n){for(let u=0;u<16;u++,n+=4)SHA256_W[u]=e.getUint32(n,!1);for(let u=16;u<64;u++){const p=SHA256_W[u-15],g=SHA256_W[u-2],A=rotr(p,7)^rotr(p,18)^p>>>3,w=rotr(g,17)^rotr(g,19)^g>>>10;SHA256_W[u]=w+SHA256_W[u-7]+A+SHA256_W[u-16]|0}let{A:r,B:s,C:o,D:a,E:c,F:l,G:h,H:f}=this;for(let u=0;u<64;u++){const p=rotr(c,6)^rotr(c,11)^rotr(c,25),g=f+p+Chi(c,l,h)+SHA256_K[u]+SHA256_W[u]|0,w=(rotr(r,2)^rotr(r,13)^rotr(r,22))+Maj(r,s,o)|0;f=h,h=l,l=c,c=a+g|0,a=o,o=s,s=r,r=g+w|0}r=r+this.A|0,s=s+this.B|0,o=o+this.C|0,a=a+this.D|0,c=c+this.E|0,l=l+this.F|0,h=h+this.G|0,f=f+this.H|0,this.set(r,s,o,a,c,l,h,f)}roundClean(){SHA256_W.fill(0)}destroy(){this.set(0,0,0,0,0,0,0,0),this.buffer.fill(0)}}const sha256=wrapConstructor(()=>new SHA256);class HMAC extends Hash{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,ahash(e);const r=toBytes(n);if(this.iHash=e.create(),typeof this.iHash.update!="function")throw new Error("Expected instance of class which extends utils.Hash");this.blockLen=this.iHash.blockLen,this.outputLen=this.iHash.outputLen;const s=this.blockLen,o=new Uint8Array(s);o.set(r.length>s?e.create().update(r).digest():r);for(let a=0;a<o.length;a++)o[a]^=54;this.iHash.update(o),this.oHash=e.create();for(let a=0;a<o.length;a++)o[a]^=106;this.oHash.update(o),o.fill(0)}update(e){return aexists(this),this.iHash.update(e),this}digestInto(e){aexists(this),abytes$1(e,this.outputLen),this.finished=!0,this.iHash.digestInto(e),this.oHash.update(e),this.oHash.digestInto(e),this.destroy()}digest(){const e=new Uint8Array(this.oHash.outputLen);return this.digestInto(e),e}_cloneInto(e){e||(e=Object.create(Object.getPrototypeOf(this),{}));const{oHash:n,iHash:r,finished:s,destroyed:o,blockLen:a,outputLen:c}=this;return e=e,e.finished=s,e.destroyed=o,e.blockLen=a,e.outputLen=c,e.oHash=n._cloneInto(e.oHash),e.iHash=r._cloneInto(e.iHash),e}destroy(){this.destroyed=!0,this.oHash.destroy(),this.iHash.destroy()}}const hmac=(t,e,n)=>new HMAC(t,e).update(n).digest();hmac.create=(t,e)=>new HMAC(t,e);/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$4=BigInt(0),_1n$4=BigInt(1),_2n$2=BigInt(2);function isBytes$1(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function abytes(t){if(!isBytes$1(t))throw new Error("Uint8Array expected")}function abool(t,e){if(typeof e!="boolean")throw new Error(t+" boolean expected, got "+e)}const hexes=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function bytesToHex(t){abytes(t);let e="";for(let n=0;n<t.length;n++)e+=hexes[t[n]];return e}function numberToHexUnpadded(t){const e=t.toString(16);return e.length&1?"0"+e:e}function hexToNumber(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);return t===""?_0n$4:BigInt("0x"+t)}const asciis={_0:48,_9:57,A:65,F:70,a:97,f:102};function asciiToBase16(t){if(t>=asciis._0&&t<=asciis._9)return t-asciis._0;if(t>=asciis.A&&t<=asciis.F)return t-(asciis.A-10);if(t>=asciis.a&&t<=asciis.f)return t-(asciis.a-10)}function hexToBytes(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let s=0,o=0;s<n;s++,o+=2){const a=asciiToBase16(t.charCodeAt(o)),c=asciiToBase16(t.charCodeAt(o+1));if(a===void 0||c===void 0){const l=t[o]+t[o+1];throw new Error('hex string expected, got non-hex character "'+l+'" at index '+o)}r[s]=a*16+c}return r}function bytesToNumberBE(t){return hexToNumber(bytesToHex(t))}function bytesToNumberLE(t){return abytes(t),hexToNumber(bytesToHex(Uint8Array.from(t).reverse()))}function numberToBytesBE(t,e){return hexToBytes(t.toString(16).padStart(e*2,"0"))}function numberToBytesLE(t,e){return numberToBytesBE(t,e).reverse()}function numberToVarBytesBE(t){return hexToBytes(numberToHexUnpadded(t))}function ensureBytes(t,e,n){let r;if(typeof e=="string")try{r=hexToBytes(e)}catch(o){throw new Error(t+" must be hex string or Uint8Array, cause: "+o)}else if(isBytes$1(e))r=Uint8Array.from(e);else throw new Error(t+" must be hex string or Uint8Array");const s=r.length;if(typeof n=="number"&&s!==n)throw new Error(t+" of length "+n+" expected, got "+s);return r}function concatBytes(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];abytes(s),e+=s.length}const n=new Uint8Array(e);for(let r=0,s=0;r<t.length;r++){const o=t[r];n.set(o,s),s+=o.length}return n}function equalBytes(t,e){if(t.length!==e.length)return!1;let n=0;for(let r=0;r<t.length;r++)n|=t[r]^e[r];return n===0}function utf8ToBytes(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}const isPosBig=t=>typeof t=="bigint"&&_0n$4<=t;function inRange(t,e,n){return isPosBig(t)&&isPosBig(e)&&isPosBig(n)&&e<=t&&t<n}function aInRange(t,e,n,r){if(!inRange(e,n,r))throw new Error("expected valid "+t+": "+n+" <= n < "+r+", got "+e)}function bitLen(t){let e;for(e=0;t>_0n$4;t>>=_1n$4,e+=1);return e}function bitGet(t,e){return t>>BigInt(e)&_1n$4}function bitSet(t,e,n){return t|(n?_1n$4:_0n$4)<<BigInt(e)}const bitMask=t=>(_2n$2<<BigInt(t-1))-_1n$4,u8n=t=>new Uint8Array(t),u8fr=t=>Uint8Array.from(t);function createHmacDrbg(t,e,n){if(typeof t!="number"||t<2)throw new Error("hashLen must be a number");if(typeof e!="number"||e<2)throw new Error("qByteLen must be a number");if(typeof n!="function")throw new Error("hmacFn must be a function");let r=u8n(t),s=u8n(t),o=0;const a=()=>{r.fill(1),s.fill(0),o=0},c=(...u)=>n(s,r,...u),l=(u=u8n())=>{s=c(u8fr([0]),u),r=c(),u.length!==0&&(s=c(u8fr([1]),u),r=c())},h=()=>{if(o++>=1e3)throw new Error("drbg: tried 1000 values");let u=0;const p=[];for(;u<e;){r=c();const g=r.slice();p.push(g),u+=r.length}return concatBytes(...p)};return(u,p)=>{a(),l(u);let g;for(;!(g=p(h()));)l();return a(),g}}const validatorFns={bigint:t=>typeof t=="bigint",function:t=>typeof t=="function",boolean:t=>typeof t=="boolean",string:t=>typeof t=="string",stringOrUint8Array:t=>typeof t=="string"||isBytes$1(t),isSafeInteger:t=>Number.isSafeInteger(t),array:t=>Array.isArray(t),field:(t,e)=>e.Fp.isValid(t),hash:t=>typeof t=="function"&&Number.isSafeInteger(t.outputLen)};function validateObject(t,e,n={}){const r=(s,o,a)=>{const c=validatorFns[o];if(typeof c!="function")throw new Error("invalid validator function");const l=t[s];if(!(a&&l===void 0)&&!c(l,t))throw new Error("param "+String(s)+" is invalid. Expected "+o+", got "+l)};for(const[s,o]of Object.entries(e))r(s,o,!1);for(const[s,o]of Object.entries(n))r(s,o,!0);return t}const notImplemented=()=>{throw new Error("not implemented")};function memoized(t){const e=new WeakMap;return(n,...r)=>{const s=e.get(n);if(s!==void 0)return s;const o=t(n,...r);return e.set(n,o),o}}const ut=Object.freeze(Object.defineProperty({__proto__:null,aInRange,abool,abytes,bitGet,bitLen,bitMask,bitSet,bytesToHex,bytesToNumberBE,bytesToNumberLE,concatBytes,createHmacDrbg,ensureBytes,equalBytes,hexToBytes,hexToNumber,inRange,isBytes:isBytes$1,memoized,notImplemented,numberToBytesBE,numberToBytesLE,numberToHexUnpadded,numberToVarBytesBE,utf8ToBytes,validateObject},Symbol.toStringTag,{value:"Module"}));/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$3=BigInt(0),_1n$3=BigInt(1),_2n$1=BigInt(2),_3n$1=BigInt(3),_4n=BigInt(4),_5n=BigInt(5),_8n=BigInt(8);function mod(t,e){const n=t%e;return n>=_0n$3?n:e+n}function pow(t,e,n){if(e<_0n$3)throw new Error("invalid exponent, negatives unsupported");if(n<=_0n$3)throw new Error("invalid modulus");if(n===_1n$3)return _0n$3;let r=_1n$3;for(;e>_0n$3;)e&_1n$3&&(r=r*t%n),t=t*t%n,e>>=_1n$3;return r}function pow2(t,e,n){let r=t;for(;e-- >_0n$3;)r*=r,r%=n;return r}function invert(t,e){if(t===_0n$3)throw new Error("invert: expected non-zero number");if(e<=_0n$3)throw new Error("invert: expected positive modulus, got "+e);let n=mod(t,e),r=e,s=_0n$3,o=_1n$3;for(;n!==_0n$3;){const c=r/n,l=r%n,h=s-o*c;r=n,n=l,s=o,o=h}if(r!==_1n$3)throw new Error("invert: does not exist");return mod(s,e)}function tonelliShanks(t){const e=(t-_1n$3)/_2n$1;let n,r,s;for(n=t-_1n$3,r=0;n%_2n$1===_0n$3;n/=_2n$1,r++);for(s=_2n$1;s<t&&pow(s,e,t)!==t-_1n$3;s++)if(s>1e3)throw new Error("Cannot find square root: likely non-prime P");if(r===1){const a=(t+_1n$3)/_4n;return function(l,h){const f=l.pow(h,a);if(!l.eql(l.sqr(f),h))throw new Error("Cannot find square root");return f}}const o=(n+_1n$3)/_2n$1;return function(c,l){if(c.pow(l,e)===c.neg(c.ONE))throw new Error("Cannot find square root");let h=r,f=c.pow(c.mul(c.ONE,s),n),u=c.pow(l,o),p=c.pow(l,n);for(;!c.eql(p,c.ONE);){if(c.eql(p,c.ZERO))return c.ZERO;let g=1;for(let w=c.sqr(p);g<h&&!c.eql(w,c.ONE);g++)w=c.sqr(w);const A=c.pow(f,_1n$3<<BigInt(h-g-1));f=c.sqr(A),u=c.mul(u,A),p=c.mul(p,f),h=g}return u}}function FpSqrt(t){if(t%_4n===_3n$1){const e=(t+_1n$3)/_4n;return function(r,s){const o=r.pow(s,e);if(!r.eql(r.sqr(o),s))throw new Error("Cannot find square root");return o}}if(t%_8n===_5n){const e=(t-_5n)/_8n;return function(r,s){const o=r.mul(s,_2n$1),a=r.pow(o,e),c=r.mul(s,a),l=r.mul(r.mul(c,_2n$1),a),h=r.mul(c,r.sub(l,r.ONE));if(!r.eql(r.sqr(h),s))throw new Error("Cannot find square root");return h}}return tonelliShanks(t)}const FIELD_FIELDS=["create","isValid","is0","neg","inv","sqrt","sqr","eql","add","sub","mul","pow","div","addN","subN","mulN","sqrN"];function validateField(t){const e={ORDER:"bigint",MASK:"bigint",BYTES:"isSafeInteger",BITS:"isSafeInteger"},n=FIELD_FIELDS.reduce((r,s)=>(r[s]="function",r),e);return validateObject(t,n)}function FpPow(t,e,n){if(n<_0n$3)throw new Error("invalid exponent, negatives unsupported");if(n===_0n$3)return t.ONE;if(n===_1n$3)return e;let r=t.ONE,s=e;for(;n>_0n$3;)n&_1n$3&&(r=t.mul(r,s)),s=t.sqr(s),n>>=_1n$3;return r}function FpInvertBatch(t,e){const n=new Array(e.length),r=e.reduce((o,a,c)=>t.is0(a)?o:(n[c]=o,t.mul(o,a)),t.ONE),s=t.inv(r);return e.reduceRight((o,a,c)=>t.is0(a)?o:(n[c]=t.mul(o,n[c]),t.mul(o,a)),s),n}function nLength(t,e){const n=e!==void 0?e:t.toString(2).length,r=Math.ceil(n/8);return{nBitLength:n,nByteLength:r}}function Field(t,e,n=!1,r={}){if(t<=_0n$3)throw new Error("invalid field: expected ORDER > 0, got "+t);const{nBitLength:s,nByteLength:o}=nLength(t,e);if(o>2048)throw new Error("invalid field: expected ORDER of <= 2048 bytes");let a;const c=Object.freeze({ORDER:t,BITS:s,BYTES:o,MASK:bitMask(s),ZERO:_0n$3,ONE:_1n$3,create:l=>mod(l,t),isValid:l=>{if(typeof l!="bigint")throw new Error("invalid field element: expected bigint, got "+typeof l);return _0n$3<=l&&l<t},is0:l=>l===_0n$3,isOdd:l=>(l&_1n$3)===_1n$3,neg:l=>mod(-l,t),eql:(l,h)=>l===h,sqr:l=>mod(l*l,t),add:(l,h)=>mod(l+h,t),sub:(l,h)=>mod(l-h,t),mul:(l,h)=>mod(l*h,t),pow:(l,h)=>FpPow(c,l,h),div:(l,h)=>mod(l*invert(h,t),t),sqrN:l=>l*l,addN:(l,h)=>l+h,subN:(l,h)=>l-h,mulN:(l,h)=>l*h,inv:l=>invert(l,t),sqrt:r.sqrt||(l=>(a||(a=FpSqrt(t)),a(c,l))),invertBatch:l=>FpInvertBatch(c,l),cmov:(l,h,f)=>f?h:l,toBytes:l=>n?numberToBytesLE(l,o):numberToBytesBE(l,o),fromBytes:l=>{if(l.length!==o)throw new Error("Field.fromBytes: expected "+o+" bytes, got "+l.length);return n?bytesToNumberLE(l):bytesToNumberBE(l)}});return Object.freeze(c)}function getFieldBytesLength(t){if(typeof t!="bigint")throw new Error("field order must be bigint");const e=t.toString(2).length;return Math.ceil(e/8)}function getMinHashLength(t){const e=getFieldBytesLength(t);return e+Math.ceil(e/2)}function mapHashToField(t,e,n=!1){const r=t.length,s=getFieldBytesLength(e),o=getMinHashLength(e);if(r<16||r<o||r>1024)throw new Error("expected "+o+"-1024 bytes of input, got "+r);const a=n?bytesToNumberBE(t):bytesToNumberLE(t),c=mod(a,e-_1n$3)+_1n$3;return n?numberToBytesLE(c,s):numberToBytesBE(c,s)}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const _0n$2=BigInt(0),_1n$2=BigInt(1);function constTimeNegate(t,e){const n=e.negate();return t?n:e}function validateW(t,e){if(!Number.isSafeInteger(t)||t<=0||t>e)throw new Error("invalid window size, expected [1.."+e+"], got W="+t)}function calcWOpts(t,e){validateW(t,e);const n=Math.ceil(e/t)+1,r=2**(t-1);return{windows:n,windowSize:r}}function validateMSMPoints(t,e){if(!Array.isArray(t))throw new Error("array expected");t.forEach((n,r)=>{if(!(n instanceof e))throw new Error("invalid point at index "+r)})}function validateMSMScalars(t,e){if(!Array.isArray(t))throw new Error("array of scalars expected");t.forEach((n,r)=>{if(!e.isValid(n))throw new Error("invalid scalar at index "+r)})}const pointPrecomputes=new WeakMap,pointWindowSizes=new WeakMap;function getW(t){return pointWindowSizes.get(t)||1}function wNAF(t,e){return{constTimeNegate,hasPrecomputes(n){return getW(n)!==1},unsafeLadder(n,r,s=t.ZERO){let o=n;for(;r>_0n$2;)r&_1n$2&&(s=s.add(o)),o=o.double(),r>>=_1n$2;return s},precomputeWindow(n,r){const{windows:s,windowSize:o}=calcWOpts(r,e),a=[];let c=n,l=c;for(let h=0;h<s;h++){l=c,a.push(l);for(let f=1;f<o;f++)l=l.add(c),a.push(l);c=l.double()}return a},wNAF(n,r,s){const{windows:o,windowSize:a}=calcWOpts(n,e);let c=t.ZERO,l=t.BASE;const h=BigInt(2**n-1),f=2**n,u=BigInt(n);for(let p=0;p<o;p++){const g=p*a;let A=Number(s&h);s>>=u,A>a&&(A-=f,s+=_1n$2);const w=g,y=g+Math.abs(A)-1,_=p%2!==0,N=A<0;A===0?l=l.add(constTimeNegate(_,r[w])):c=c.add(constTimeNegate(N,r[y]))}return{p:c,f:l}},wNAFUnsafe(n,r,s,o=t.ZERO){const{windows:a,windowSize:c}=calcWOpts(n,e),l=BigInt(2**n-1),h=2**n,f=BigInt(n);for(let u=0;u<a;u++){const p=u*c;if(s===_0n$2)break;let g=Number(s&l);if(s>>=f,g>c&&(g-=h,s+=_1n$2),g===0)continue;let A=r[p+Math.abs(g)-1];g<0&&(A=A.negate()),o=o.add(A)}return o},getPrecomputes(n,r,s){let o=pointPrecomputes.get(r);return o||(o=this.precomputeWindow(r,n),n!==1&&pointPrecomputes.set(r,s(o))),o},wNAFCached(n,r,s){const o=getW(n);return this.wNAF(o,this.getPrecomputes(o,n,s),r)},wNAFCachedUnsafe(n,r,s,o){const a=getW(n);return a===1?this.unsafeLadder(n,r,o):this.wNAFUnsafe(a,this.getPrecomputes(a,n,s),r,o)},setWindowSize(n,r){validateW(r,e),pointWindowSizes.set(n,r),pointPrecomputes.delete(n)}}}function pippenger(t,e,n,r){if(validateMSMPoints(n,t),validateMSMScalars(r,e),n.length!==r.length)throw new Error("arrays of points and scalars must have equal length");const s=t.ZERO,o=bitLen(BigInt(n.length)),a=o>12?o-3:o>4?o-2:o?2:1,c=(1<<a)-1,l=new Array(c+1).fill(s),h=Math.floor((e.BITS-1)/a)*a;let f=s;for(let u=h;u>=0;u-=a){l.fill(s);for(let g=0;g<r.length;g++){const A=r[g],w=Number(A>>BigInt(u)&BigInt(c));l[w]=l[w].add(n[g])}let p=s;for(let g=l.length-1,A=s;g>0;g--)A=A.add(l[g]),p=p.add(A);if(f=f.add(p),u!==0)for(let g=0;g<a;g++)f=f.double()}return f}function validateBasic(t){return validateField(t.Fp),validateObject(t,{n:"bigint",h:"bigint",Gx:"field",Gy:"field"},{nBitLength:"isSafeInteger",nByteLength:"isSafeInteger"}),Object.freeze({...nLength(t.n,t.nBitLength),...t,p:t.Fp.ORDER})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function validateSigVerOpts(t){t.lowS!==void 0&&abool("lowS",t.lowS),t.prehash!==void 0&&abool("prehash",t.prehash)}function validatePointOpts(t){const e=validateBasic(t);validateObject(e,{a:"field",b:"field"},{allowedPrivateKeyLengths:"array",wrapPrivateKey:"boolean",isTorsionFree:"function",clearCofactor:"function",allowInfinityPoint:"boolean",fromBytes:"function",toBytes:"function"});const{endo:n,Fp:r,a:s}=e;if(n){if(!r.eql(s,r.ZERO))throw new Error("invalid endomorphism, can only be defined for Koblitz curves that have a=0");if(typeof n!="object"||typeof n.beta!="bigint"||typeof n.splitScalar!="function")throw new Error("invalid endomorphism, expected beta: bigint and splitScalar: function")}return Object.freeze({...e})}const{bytesToNumberBE:b2n,hexToBytes:h2b}=ut,DER={Err:class extends Error{constructor(e=""){super(e)}},_tlv:{encode:(t,e)=>{const{Err:n}=DER;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length&1)throw new n("tlv.encode: unpadded data");const r=e.length/2,s=numberToHexUnpadded(r);if(s.length/2&128)throw new n("tlv.encode: long form length too big");const o=r>127?numberToHexUnpadded(s.length/2|128):"";return numberToHexUnpadded(t)+o+s+e},decode(t,e){const{Err:n}=DER;let r=0;if(t<0||t>256)throw new n("tlv.encode: wrong tag");if(e.length<2||e[r++]!==t)throw new n("tlv.decode: wrong tlv");const s=e[r++],o=!!(s&128);let a=0;if(!o)a=s;else{const l=s&127;if(!l)throw new n("tlv.decode(long): indefinite length not supported");if(l>4)throw new n("tlv.decode(long): byte length is too big");const h=e.subarray(r,r+l);if(h.length!==l)throw new n("tlv.decode: length bytes not complete");if(h[0]===0)throw new n("tlv.decode(long): zero leftmost byte");for(const f of h)a=a<<8|f;if(r+=l,a<128)throw new n("tlv.decode(long): not minimal encoding")}const c=e.subarray(r,r+a);if(c.length!==a)throw new n("tlv.decode: wrong value length");return{v:c,l:e.subarray(r+a)}}},_int:{encode(t){const{Err:e}=DER;if(t<_0n$1)throw new e("integer: negative integers are not allowed");let n=numberToHexUnpadded(t);if(Number.parseInt(n[0],16)&8&&(n="00"+n),n.length&1)throw new e("unexpected DER parsing assertion: unpadded hex");return n},decode(t){const{Err:e}=DER;if(t[0]&128)throw new e("invalid signature integer: negative");if(t[0]===0&&!(t[1]&128))throw new e("invalid signature integer: unnecessary leading zero");return b2n(t)}},toSig(t){const{Err:e,_int:n,_tlv:r}=DER,s=typeof t=="string"?h2b(t):t;abytes(s);const{v:o,l:a}=r.decode(48,s);if(a.length)throw new e("invalid signature: left bytes after parsing");const{v:c,l}=r.decode(2,o),{v:h,l:f}=r.decode(2,l);if(f.length)throw new e("invalid signature: left bytes after parsing");return{r:n.decode(c),s:n.decode(h)}},hexFromSig(t){const{_tlv:e,_int:n}=DER,r=e.encode(2,n.encode(t.r)),s=e.encode(2,n.encode(t.s)),o=r+s;return e.encode(48,o)}},_0n$1=BigInt(0),_1n$1=BigInt(1);BigInt(2);const _3n=BigInt(3);BigInt(4);function weierstrassPoints(t){const e=validatePointOpts(t),{Fp:n}=e,r=Field(e.n,e.nBitLength),s=e.toBytes||((w,y,_)=>{const N=y.toAffine();return concatBytes(Uint8Array.from([4]),n.toBytes(N.x),n.toBytes(N.y))}),o=e.fromBytes||(w=>{const y=w.subarray(1),_=n.fromBytes(y.subarray(0,n.BYTES)),N=n.fromBytes(y.subarray(n.BYTES,2*n.BYTES));return{x:_,y:N}});function a(w){const{a:y,b:_}=e,N=n.sqr(w),C=n.mul(N,w);return n.add(n.add(C,n.mul(w,y)),_)}if(!n.eql(n.sqr(e.Gy),a(e.Gx)))throw new Error("bad generator point: equation left != right");function c(w){return inRange(w,_1n$1,e.n)}function l(w){const{allowedPrivateKeyLengths:y,nByteLength:_,wrapPrivateKey:N,n:C}=e;if(y&&typeof w!="bigint"){if(isBytes$1(w)&&(w=bytesToHex(w)),typeof w!="string"||!y.includes(w.length))throw new Error("invalid private key");w=w.padStart(_*2,"0")}let U;try{U=typeof w=="bigint"?w:bytesToNumberBE(ensureBytes("private key",w,_))}catch{throw new Error("invalid private key, expected hex or "+_+" bytes, got "+typeof w)}return N&&(U=mod(U,C)),aInRange("private key",U,_1n$1,C),U}function h(w){if(!(w instanceof p))throw new Error("ProjectivePoint expected")}const f=memoized((w,y)=>{const{px:_,py:N,pz:C}=w;if(n.eql(C,n.ONE))return{x:_,y:N};const U=w.is0();y==null&&(y=U?n.ONE:n.inv(C));const b=n.mul(_,y),v=n.mul(N,y),$=n.mul(C,y);if(U)return{x:n.ZERO,y:n.ZERO};if(!n.eql($,n.ONE))throw new Error("invZ was invalid");return{x:b,y:v}}),u=memoized(w=>{if(w.is0()){if(e.allowInfinityPoint&&!n.is0(w.py))return;throw new Error("bad point: ZERO")}const{x:y,y:_}=w.toAffine();if(!n.isValid(y)||!n.isValid(_))throw new Error("bad point: x or y not FE");const N=n.sqr(_),C=a(y);if(!n.eql(N,C))throw new Error("bad point: equation left != right");if(!w.isTorsionFree())throw new Error("bad point: not in prime-order subgroup");return!0});class p{constructor(y,_,N){if(this.px=y,this.py=_,this.pz=N,y==null||!n.isValid(y))throw new Error("x required");if(_==null||!n.isValid(_))throw new Error("y required");if(N==null||!n.isValid(N))throw new Error("z required");Object.freeze(this)}static fromAffine(y){const{x:_,y:N}=y||{};if(!y||!n.isValid(_)||!n.isValid(N))throw new Error("invalid affine point");if(y instanceof p)throw new Error("projective point not allowed");const C=U=>n.eql(U,n.ZERO);return C(_)&&C(N)?p.ZERO:new p(_,N,n.ONE)}get x(){return this.toAffine().x}get y(){return this.toAffine().y}static normalizeZ(y){const _=n.invertBatch(y.map(N=>N.pz));return y.map((N,C)=>N.toAffine(_[C])).map(p.fromAffine)}static fromHex(y){const _=p.fromAffine(o(ensureBytes("pointHex",y)));return _.assertValidity(),_}static fromPrivateKey(y){return p.BASE.multiply(l(y))}static msm(y,_){return pippenger(p,r,y,_)}_setWindowSize(y){A.setWindowSize(this,y)}assertValidity(){u(this)}hasEvenY(){const{y}=this.toAffine();if(n.isOdd)return!n.isOdd(y);throw new Error("Field doesn't support isOdd")}equals(y){h(y);const{px:_,py:N,pz:C}=this,{px:U,py:b,pz:v}=y,$=n.eql(n.mul(_,v),n.mul(U,C)),S=n.eql(n.mul(N,v),n.mul(b,C));return $&&S}negate(){return new p(this.px,n.neg(this.py),this.pz)}double(){const{a:y,b:_}=e,N=n.mul(_,_3n),{px:C,py:U,pz:b}=this;let v=n.ZERO,$=n.ZERO,S=n.ZERO,I=n.mul(C,C),P=n.mul(U,U),E=n.mul(b,b),R=n.mul(C,U);return R=n.add(R,R),S=n.mul(C,b),S=n.add(S,S),v=n.mul(y,S),$=n.mul(N,E),$=n.add(v,$),v=n.sub(P,$),$=n.add(P,$),$=n.mul(v,$),v=n.mul(R,v),S=n.mul(N,S),E=n.mul(y,E),R=n.sub(I,E),R=n.mul(y,R),R=n.add(R,S),S=n.add(I,I),I=n.add(S,I),I=n.add(I,E),I=n.mul(I,R),$=n.add($,I),E=n.mul(U,b),E=n.add(E,E),I=n.mul(E,R),v=n.sub(v,I),S=n.mul(E,P),S=n.add(S,S),S=n.add(S,S),new p(v,$,S)}add(y){h(y);const{px:_,py:N,pz:C}=this,{px:U,py:b,pz:v}=y;let $=n.ZERO,S=n.ZERO,I=n.ZERO;const P=e.a,E=n.mul(e.b,_3n);let R=n.mul(_,U),T=n.mul(N,b),B=n.mul(C,v),m=n.add(_,N),k=n.add(U,b);m=n.mul(m,k),k=n.add(R,T),m=n.sub(m,k),k=n.add(_,C);let L=n.add(U,v);return k=n.mul(k,L),L=n.add(R,B),k=n.sub(k,L),L=n.add(N,C),$=n.add(b,v),L=n.mul(L,$),$=n.add(T,B),L=n.sub(L,$),I=n.mul(P,k),$=n.mul(E,B),I=n.add($,I),$=n.sub(T,I),I=n.add(T,I),S=n.mul($,I),T=n.add(R,R),T=n.add(T,R),B=n.mul(P,B),k=n.mul(E,k),T=n.add(T,B),B=n.sub(R,B),B=n.mul(P,B),k=n.add(k,B),R=n.mul(T,k),S=n.add(S,R),R=n.mul(L,k),$=n.mul(m,$),$=n.sub($,R),R=n.mul(m,T),I=n.mul(L,I),I=n.add(I,R),new p($,S,I)}subtract(y){return this.add(y.negate())}is0(){return this.equals(p.ZERO)}wNAF(y){return A.wNAFCached(this,y,p.normalizeZ)}multiplyUnsafe(y){const{endo:_,n:N}=e;aInRange("scalar",y,_0n$1,N);const C=p.ZERO;if(y===_0n$1)return C;if(this.is0()||y===_1n$1)return this;if(!_||A.hasPrecomputes(this))return A.wNAFCachedUnsafe(this,y,p.normalizeZ);let{k1neg:U,k1:b,k2neg:v,k2:$}=_.splitScalar(y),S=C,I=C,P=this;for(;b>_0n$1||$>_0n$1;)b&_1n$1&&(S=S.add(P)),$&_1n$1&&(I=I.add(P)),P=P.double(),b>>=_1n$1,$>>=_1n$1;return U&&(S=S.negate()),v&&(I=I.negate()),I=new p(n.mul(I.px,_.beta),I.py,I.pz),S.add(I)}multiply(y){const{endo:_,n:N}=e;aInRange("scalar",y,_1n$1,N);let C,U;if(_){const{k1neg:b,k1:v,k2neg:$,k2:S}=_.splitScalar(y);let{p:I,f:P}=this.wNAF(v),{p:E,f:R}=this.wNAF(S);I=A.constTimeNegate(b,I),E=A.constTimeNegate($,E),E=new p(n.mul(E.px,_.beta),E.py,E.pz),C=I.add(E),U=P.add(R)}else{const{p:b,f:v}=this.wNAF(y);C=b,U=v}return p.normalizeZ([C,U])[0]}multiplyAndAddUnsafe(y,_,N){const C=p.BASE,U=(v,$)=>$===_0n$1||$===_1n$1||!v.equals(C)?v.multiplyUnsafe($):v.multiply($),b=U(this,_).add(U(y,N));return b.is0()?void 0:b}toAffine(y){return f(this,y)}isTorsionFree(){const{h:y,isTorsionFree:_}=e;if(y===_1n$1)return!0;if(_)return _(p,this);throw new Error("isTorsionFree() has not been declared for the elliptic curve")}clearCofactor(){const{h:y,clearCofactor:_}=e;return y===_1n$1?this:_?_(p,this):this.multiplyUnsafe(e.h)}toRawBytes(y=!0){return abool("isCompressed",y),this.assertValidity(),s(p,this,y)}toHex(y=!0){return abool("isCompressed",y),bytesToHex(this.toRawBytes(y))}}p.BASE=new p(e.Gx,e.Gy,n.ONE),p.ZERO=new p(n.ZERO,n.ONE,n.ZERO);const g=e.nBitLength,A=wNAF(p,e.endo?Math.ceil(g/2):g);return{CURVE:e,ProjectivePoint:p,normPrivateKeyToScalar:l,weierstrassEquation:a,isWithinCurveOrder:c}}function validateOpts(t){const e=validateBasic(t);return validateObject(e,{hash:"hash",hmac:"function",randomBytes:"function"},{bits2int:"function",bits2int_modN:"function",lowS:"boolean"}),Object.freeze({lowS:!0,...e})}function weierstrass(t){const e=validateOpts(t),{Fp:n,n:r}=e,s=n.BYTES+1,o=2*n.BYTES+1;function a(B){return mod(B,r)}function c(B){return invert(B,r)}const{ProjectivePoint:l,normPrivateKeyToScalar:h,weierstrassEquation:f,isWithinCurveOrder:u}=weierstrassPoints({...e,toBytes(B,m,k){const L=m.toAffine(),H=n.toBytes(L.x),D=concatBytes;return abool("isCompressed",k),k?D(Uint8Array.from([m.hasEvenY()?2:3]),H):D(Uint8Array.from([4]),H,n.toBytes(L.y))},fromBytes(B){const m=B.length,k=B[0],L=B.subarray(1);if(m===s&&(k===2||k===3)){const H=bytesToNumberBE(L);if(!inRange(H,_1n$1,n.ORDER))throw new Error("Point is not on curve");const D=f(H);let M;try{M=n.sqrt(D)}catch(K){const z=K instanceof Error?": "+K.message:"";throw new Error("Point is not on curve"+z)}const O=(M&_1n$1)===_1n$1;return(k&1)===1!==O&&(M=n.neg(M)),{x:H,y:M}}else if(m===o&&k===4){const H=n.fromBytes(L.subarray(0,n.BYTES)),D=n.fromBytes(L.subarray(n.BYTES,2*n.BYTES));return{x:H,y:D}}else{const H=s,D=o;throw new Error("invalid Point, expected length of "+H+", or uncompressed "+D+", got "+m)}}}),p=B=>bytesToHex(numberToBytesBE(B,e.nByteLength));function g(B){const m=r>>_1n$1;return B>m}function A(B){return g(B)?a(-B):B}const w=(B,m,k)=>bytesToNumberBE(B.slice(m,k));class y{constructor(m,k,L){this.r=m,this.s=k,this.recovery=L,this.assertValidity()}static fromCompact(m){const k=e.nByteLength;return m=ensureBytes("compactSignature",m,k*2),new y(w(m,0,k),w(m,k,2*k))}static fromDER(m){const{r:k,s:L}=DER.toSig(ensureBytes("DER",m));return new y(k,L)}assertValidity(){aInRange("r",this.r,_1n$1,r),aInRange("s",this.s,_1n$1,r)}addRecoveryBit(m){return new y(this.r,this.s,m)}recoverPublicKey(m){const{r:k,s:L,recovery:H}=this,D=v(ensureBytes("msgHash",m));if(H==null||![0,1,2,3].includes(H))throw new Error("recovery id invalid");const M=H===2||H===3?k+e.n:k;if(M>=n.ORDER)throw new Error("recovery id 2 or 3 invalid");const O=H&1?"03":"02",F=l.fromHex(O+p(M)),K=c(M),z=a(-D*K),q=a(L*K),V=l.BASE.multiplyAndAddUnsafe(F,z,q);if(!V)throw new Error("point at infinify");return V.assertValidity(),V}hasHighS(){return g(this.s)}normalizeS(){return this.hasHighS()?new y(this.r,a(-this.s),this.recovery):this}toDERRawBytes(){return hexToBytes(this.toDERHex())}toDERHex(){return DER.hexFromSig({r:this.r,s:this.s})}toCompactRawBytes(){return hexToBytes(this.toCompactHex())}toCompactHex(){return p(this.r)+p(this.s)}}const _={isValidPrivateKey(B){try{return h(B),!0}catch{return!1}},normPrivateKeyToScalar:h,randomPrivateKey:()=>{const B=getMinHashLength(e.n);return mapHashToField(e.randomBytes(B),e.n)},precompute(B=8,m=l.BASE){return m._setWindowSize(B),m.multiply(BigInt(3)),m}};function N(B,m=!0){return l.fromPrivateKey(B).toRawBytes(m)}function C(B){const m=isBytes$1(B),k=typeof B=="string",L=(m||k)&&B.length;return m?L===s||L===o:k?L===2*s||L===2*o:B instanceof l}function U(B,m,k=!0){if(C(B))throw new Error("first arg must be private key");if(!C(m))throw new Error("second arg must be public key");return l.fromHex(m).multiply(h(B)).toRawBytes(k)}const b=e.bits2int||function(B){if(B.length>8192)throw new Error("input is too large");const m=bytesToNumberBE(B),k=B.length*8-e.nBitLength;return k>0?m>>BigInt(k):m},v=e.bits2int_modN||function(B){return a(b(B))},$=bitMask(e.nBitLength);function S(B){return aInRange("num < 2^"+e.nBitLength,B,_0n$1,$),numberToBytesBE(B,e.nByteLength)}function I(B,m,k=P){if(["recovered","canonical"].some(G=>G in k))throw new Error("sign() legacy options not supported");const{hash:L,randomBytes:H}=e;let{lowS:D,prehash:M,extraEntropy:O}=k;D==null&&(D=!0),B=ensureBytes("msgHash",B),validateSigVerOpts(k),M&&(B=ensureBytes("prehashed msgHash",L(B)));const F=v(B),K=h(m),z=[S(K),S(F)];if(O!=null&&O!==!1){const G=O===!0?H(n.BYTES):O;z.push(ensureBytes("extraEntropy",G))}const q=concatBytes(...z),V=F;function j(G){const Z=b(G);if(!u(Z))return;const X=c(Z),te=l.BASE.multiply(Z).toAffine(),Y=a(te.x);if(Y===_0n$1)return;const W=a(X*a(V+Y*K));if(W===_0n$1)return;let J=(te.x===Y?0:2)|Number(te.y&_1n$1),Q=W;return D&&g(W)&&(Q=A(W),J^=1),new y(Y,Q,J)}return{seed:q,k2sig:j}}const P={lowS:e.lowS,prehash:!1},E={lowS:e.lowS,prehash:!1};function R(B,m,k=P){const{seed:L,k2sig:H}=I(B,m,k),D=e;return createHmacDrbg(D.hash.outputLen,D.nByteLength,D.hmac)(L,H)}l.BASE._setWindowSize(8);function T(B,m,k,L=E){var J;const H=B;m=ensureBytes("msgHash",m),k=ensureBytes("publicKey",k);const{lowS:D,prehash:M,format:O}=L;if(validateSigVerOpts(L),"strict"in L)throw new Error("options.strict was renamed to lowS");if(O!==void 0&&O!=="compact"&&O!=="der")throw new Error("format must be compact or der");const F=typeof H=="string"||isBytes$1(H),K=!F&&!O&&typeof H=="object"&&H!==null&&typeof H.r=="bigint"&&typeof H.s=="bigint";if(!F&&!K)throw new Error("invalid signature, expected Uint8Array, hex string or Signature instance");let z,q;try{if(K&&(z=new y(H.r,H.s)),F){try{O!=="compact"&&(z=y.fromDER(H))}catch(Q){if(!(Q instanceof DER.Err))throw Q}!z&&O!=="der"&&(z=y.fromCompact(H))}q=l.fromHex(k)}catch{return!1}if(!z||D&&z.hasHighS())return!1;M&&(m=e.hash(m));const{r:V,s:j}=z,G=v(m),Z=c(j),X=a(G*Z),te=a(V*Z),Y=(J=l.BASE.multiplyAndAddUnsafe(q,X,te))==null?void 0:J.toAffine();return Y?a(Y.x)===V:!1}return{CURVE:e,getPublicKey:N,getSharedSecret:U,sign:R,verify:T,ProjectivePoint:l,Signature:y,utils:_}}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */function getHash(t){return{hash:t,hmac:(e,...n)=>hmac(t,e,concatBytes$1(...n)),randomBytes}}function createCurve(t,e){const n=r=>weierstrass({...t,...getHash(r)});return Object.freeze({...n(e),create:n})}/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */const secp256k1P=BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),secp256k1N=BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),_1n=BigInt(1),_2n=BigInt(2),divNearest=(t,e)=>(t+e/_2n)/e;function sqrtMod(t){const e=secp256k1P,n=BigInt(3),r=BigInt(6),s=BigInt(11),o=BigInt(22),a=BigInt(23),c=BigInt(44),l=BigInt(88),h=t*t*t%e,f=h*h*t%e,u=pow2(f,n,e)*f%e,p=pow2(u,n,e)*f%e,g=pow2(p,_2n,e)*h%e,A=pow2(g,s,e)*g%e,w=pow2(A,o,e)*A%e,y=pow2(w,c,e)*w%e,_=pow2(y,l,e)*y%e,N=pow2(_,c,e)*w%e,C=pow2(N,n,e)*f%e,U=pow2(C,a,e)*A%e,b=pow2(U,r,e)*h%e,v=pow2(b,_2n,e);if(!Fpk1.eql(Fpk1.sqr(v),t))throw new Error("Cannot find square root");return v}const Fpk1=Field(secp256k1P,void 0,void 0,{sqrt:sqrtMod}),secp256k1=createCurve({a:BigInt(0),b:BigInt(7),Fp:Fpk1,n:secp256k1N,Gx:BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),Gy:BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),h:BigInt(1),lowS:!0,endo:{beta:BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),splitScalar:t=>{const e=secp256k1N,n=BigInt("0x3086d221a7d46bcde86c90e49284eb15"),r=-_1n*BigInt("0xe4437ed6010e88286f547fa90abfe4c3"),s=BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8"),o=n,a=BigInt("0x100000000000000000000000000000000"),c=divNearest(o*t,e),l=divNearest(-r*t,e);let h=mod(t-c*n-l*s,e),f=mod(-c*r-l*o,e);const u=h>a,p=f>a;if(u&&(h=e-h),p&&(f=e-f),h>a||f>a)throw new Error("splitScalar: Endomorphism failed, k="+t);return{k1neg:u,k1:h,k2neg:p,k2:f}}}},sha256),_0n=BigInt(0),TAGGED_HASH_PREFIXES={};function taggedHash(t,...e){let n=TAGGED_HASH_PREFIXES[t];if(n===void 0){const r=sha256(Uint8Array.from(t,s=>s.charCodeAt(0)));n=concatBytes(r,r),TAGGED_HASH_PREFIXES[t]=n}return sha256(concatBytes(n,...e))}const pointToBytes=t=>t.toRawBytes(!0).slice(1),numTo32b=t=>numberToBytesBE(t,32),modP=t=>mod(t,secp256k1P),modN=t=>mod(t,secp256k1N),Point=secp256k1.ProjectivePoint,GmulAdd=(t,e,n)=>Point.BASE.multiplyAndAddUnsafe(t,e,n);function schnorrGetExtPubKey(t){let e=secp256k1.utils.normPrivateKeyToScalar(t),n=Point.fromPrivateKey(e);return{scalar:n.hasEvenY()?e:modN(-e),bytes:pointToBytes(n)}}function lift_x(t){aInRange("x",t,_1n,secp256k1P);const e=modP(t*t),n=modP(e*t+BigInt(7));let r=sqrtMod(n);r%_2n!==_0n&&(r=modP(-r));const s=new Point(t,r,_1n);return s.assertValidity(),s}const num=bytesToNumberBE;function challenge(...t){return modN(num(taggedHash("BIP0340/challenge",...t)))}function schnorrGetPublicKey(t){return schnorrGetExtPubKey(t).bytes}function schnorrSign(t,e,n=randomBytes(32)){const r=ensureBytes("message",t),{bytes:s,scalar:o}=schnorrGetExtPubKey(e),a=ensureBytes("auxRand",n,32),c=numTo32b(o^num(taggedHash("BIP0340/aux",a))),l=taggedHash("BIP0340/nonce",c,s,r),h=modN(num(l));if(h===_0n)throw new Error("sign failed: k is zero");const{bytes:f,scalar:u}=schnorrGetExtPubKey(h),p=challenge(f,s,r),g=new Uint8Array(64);if(g.set(f,0),g.set(numTo32b(modN(u+p*o)),32),!schnorrVerify(g,r,s))throw new Error("sign: Invalid signature produced");return g}function schnorrVerify(t,e,n){const r=ensureBytes("signature",t,64),s=ensureBytes("message",e),o=ensureBytes("publicKey",n,32);try{const a=lift_x(num(o)),c=num(r.subarray(0,32));if(!inRange(c,_1n,secp256k1P))return!1;const l=num(r.subarray(32,64));if(!inRange(l,_1n,secp256k1N))return!1;const h=challenge(numTo32b(c),pointToBytes(a),s),f=GmulAdd(a,l,modN(-h));return!(!f||!f.hasEvenY()||f.toAffine().x!==c)}catch{return!1}}const schnorr={getPublicKey:schnorrGetPublicKey,sign:schnorrSign,verify:schnorrVerify,utils:{randomPrivateKey:secp256k1.utils.randomPrivateKey,lift_x,pointToBytes,numberToBytesBE,bytesToNumberBE,taggedHash,mod}};var dist={},LRUCache={},LRUCacheNode={},hasRequiredLRUCacheNode;function requireLRUCacheNode(){if(hasRequiredLRUCacheNode)return LRUCacheNode;hasRequiredLRUCacheNode=1,Object.defineProperty(LRUCacheNode,"__esModule",{value:!0}),LRUCacheNode.LRUCacheNode=void 0;let t=class{constructor(n,r,s){const{entryExpirationTimeInMS:o=null,next:a=null,prev:c=null,onEntryEvicted:l,onEntryMarkedAsMostRecentlyUsed:h,clone:f,cloneFn:u}=s??{};if(typeof o=="number"&&(o<=0||Number.isNaN(o)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.clone=f??!1,this.cloneFn=u??this.defaultClone,this.key=n,this.internalValue=this.clone?this.cloneFn(r):r,this.created=Date.now(),this.entryExpirationTimeInMS=o,this.next=a,this.prev=c,this.onEntryEvicted=l,this.onEntryMarkedAsMostRecentlyUsed=h}get value(){return this.clone?this.cloneFn(this.internalValue):this.internalValue}get isExpired(){return typeof this.entryExpirationTimeInMS=="number"&&Date.now()-this.created>this.entryExpirationTimeInMS}invokeOnEvicted(){if(this.onEntryEvicted){const{key:n,value:r,isExpired:s}=this;this.onEntryEvicted({key:n,value:r,isExpired:s})}}invokeOnEntryMarkedAsMostRecentlyUsed(){if(this.onEntryMarkedAsMostRecentlyUsed){const{key:n,value:r}=this;this.onEntryMarkedAsMostRecentlyUsed({key:n,value:r})}}defaultClone(n){return typeof n=="boolean"||typeof n=="string"||typeof n=="number"?n:JSON.parse(JSON.stringify(n))}};return LRUCacheNode.LRUCacheNode=t,LRUCacheNode}var hasRequiredLRUCache;function requireLRUCache(){if(hasRequiredLRUCache)return LRUCache;hasRequiredLRUCache=1,Object.defineProperty(LRUCache,"__esModule",{value:!0}),LRUCache.LRUCache=void 0;const t=requireLRUCacheNode();let e=class{constructor(r){this.lookupTable=new Map,this.head=null,this.tail=null;const{maxSize:s=25,entryExpirationTimeInMS:o=null,onEntryEvicted:a,onEntryMarkedAsMostRecentlyUsed:c,cloneFn:l,clone:h}=r??{};if(Number.isNaN(s)||s<=0)throw new Error("maxSize must be greater than 0.");if(typeof o=="number"&&(o<=0||Number.isNaN(o)))throw new Error("entryExpirationTimeInMS must either be null (no expiry) or greater than 0");this.maxSizeInternal=s,this.entryExpirationTimeInMS=o,this.onEntryEvicted=a,this.onEntryMarkedAsMostRecentlyUsed=c,this.clone=h,this.cloneFn=l}get size(){return this.cleanCache(),this.lookupTable.size}get remainingSize(){return this.maxSizeInternal-this.size}get newest(){return this.head?this.head.isExpired?(this.removeNodeFromListAndLookupTable(this.head),this.newest):this.mapNodeToEntry(this.head):null}get oldest(){return this.tail?this.tail.isExpired?(this.removeNodeFromListAndLookupTable(this.tail),this.oldest):this.mapNodeToEntry(this.tail):null}get maxSize(){return this.maxSizeInternal}set maxSize(r){if(Number.isNaN(r)||r<=0)throw new Error("maxSize must be greater than 0.");this.maxSizeInternal=r,this.enforceSizeLimit()}set(r,s,o){const a=this.lookupTable.get(r);a&&this.removeNodeFromListAndLookupTable(a);const c=new t.LRUCacheNode(r,s,{entryExpirationTimeInMS:this.entryExpirationTimeInMS,onEntryEvicted:this.onEntryEvicted,onEntryMarkedAsMostRecentlyUsed:this.onEntryMarkedAsMostRecentlyUsed,clone:this.clone,cloneFn:this.cloneFn,...o});return this.setNodeAsHead(c),this.lookupTable.set(r,c),this.enforceSizeLimit(),this}get(r){const s=this.lookupTable.get(r);return s?s.isExpired?(this.removeNodeFromListAndLookupTable(s),null):(this.setNodeAsHead(s),s.value):null}peek(r){const s=this.lookupTable.get(r);return s?s.isExpired?(this.removeNodeFromListAndLookupTable(s),null):s.value:null}delete(r){const s=this.lookupTable.get(r);return s?this.removeNodeFromListAndLookupTable(s):!1}has(r){const s=this.lookupTable.get(r);return s?s.isExpired?(this.removeNodeFromListAndLookupTable(s),!1):!0:!1}clear(){this.head=null,this.tail=null,this.lookupTable.clear()}find(r){let s=this.head;for(;s;){if(s.isExpired){const a=s.next;this.removeNodeFromListAndLookupTable(s),s=a;continue}const o=this.mapNodeToEntry(s);if(r(o))return this.setNodeAsHead(s),o;s=s.next}return null}forEach(r){let s=this.head,o=0;for(;s;){if(s.isExpired){const a=s.next;this.removeNodeFromListAndLookupTable(s),s=a;continue}r(s.value,s.key,o),s=s.next,o++}}*values(){let r=this.head;for(;r;){if(r.isExpired){const s=r.next;this.removeNodeFromListAndLookupTable(r),r=s;continue}yield r.value,r=r.next}}*keys(){let r=this.head;for(;r;){if(r.isExpired){const s=r.next;this.removeNodeFromListAndLookupTable(r),r=s;continue}yield r.key,r=r.next}}*entries(){let r=this.head;for(;r;){if(r.isExpired){const s=r.next;this.removeNodeFromListAndLookupTable(r),r=s;continue}yield this.mapNodeToEntry(r),r=r.next}}*[Symbol.iterator](){let r=this.head;for(;r;){if(r.isExpired){const s=r.next;this.removeNodeFromListAndLookupTable(r),r=s;continue}yield this.mapNodeToEntry(r),r=r.next}}enforceSizeLimit(){let r=this.tail;for(;r!==null&&this.size>this.maxSizeInternal;){const s=r.prev;this.removeNodeFromListAndLookupTable(r),r=s}}mapNodeToEntry({key:r,value:s}){return{key:r,value:s}}setNodeAsHead(r){this.removeNodeFromList(r),this.head?(r.next=this.head,this.head.prev=r,this.head=r):(this.head=r,this.tail=r),r.invokeOnEntryMarkedAsMostRecentlyUsed()}removeNodeFromList(r){r.prev!==null&&(r.prev.next=r.next),r.next!==null&&(r.next.prev=r.prev),this.head===r&&(this.head=r.next),this.tail===r&&(this.tail=r.prev),r.next=null,r.prev=null}removeNodeFromListAndLookupTable(r){return r.invokeOnEvicted(),this.removeNodeFromList(r),this.lookupTable.delete(r.key)}cleanCache(){if(!this.entryExpirationTimeInMS)return;const r=[];for(const s of this.lookupTable.values())s.isExpired&&r.push(s);r.forEach(s=>this.removeNodeFromListAndLookupTable(s))}};return LRUCache.LRUCache=e,LRUCache}var hasRequiredDist;function requireDist(){return hasRequiredDist||(hasRequiredDist=1,function(t){var e=dist&&dist.__createBinding||(Object.create?function(r,s,o,a){a===void 0&&(a=o);var c=Object.getOwnPropertyDescriptor(s,o);(!c||("get"in c?!s.__esModule:c.writable||c.configurable))&&(c={enumerable:!0,get:function(){return s[o]}}),Object.defineProperty(r,a,c)}:function(r,s,o,a){a===void 0&&(a=o),r[a]=s[o]}),n=dist&&dist.__exportStar||function(r,s){for(var o in r)o!=="default"&&!Object.prototype.hasOwnProperty.call(s,o)&&e(s,r,o)};Object.defineProperty(t,"__esModule",{value:!0}),n(requireLRUCache(),t)}(dist)),dist}var distExports=requireDist();/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function isBytes(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function isArrayOf(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(n=>typeof n=="string"):e.every(n=>Number.isSafeInteger(n)):!1}function afn(t){if(typeof t!="function")throw new Error("function expected");return!0}function astr(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function anumber(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function aArr(t){if(!Array.isArray(t))throw new Error("array expected")}function astrArr(t,e){if(!isArrayOf(!0,e))throw new Error(`${t}: array of strings expected`)}function anumArr(t,e){if(!isArrayOf(!1,e))throw new Error(`${t}: array of numbers expected`)}function chain(...t){const e=o=>o,n=(o,a)=>c=>o(a(c)),r=t.map(o=>o.encode).reduceRight(n,e),s=t.map(o=>o.decode).reduce(n,e);return{encode:r,decode:s}}function alphabet(t){const e=typeof t=="string"?t.split(""):t,n=e.length;astrArr("alphabet",e);const r=new Map(e.map((s,o)=>[s,o]));return{encode:s=>(aArr(s),s.map(o=>{if(!Number.isSafeInteger(o)||o<0||o>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${o}". Allowed: ${t}`);return e[o]})),decode:s=>(aArr(s),s.map(o=>{astr("alphabet.decode",o);const a=r.get(o);if(a===void 0)throw new Error(`Unknown letter: "${o}". Allowed: ${t}`);return a}))}}function join(t=""){return astr("join",t),{encode:e=>(astrArr("join.decode",e),e.join(t)),decode:e=>(astr("join.decode",e),e.split(t))}}const gcd=(t,e)=>e===0?t:gcd(e,t%e),radix2carry=(t,e)=>t+(e-gcd(t,e)),powers=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function convertRadix2(t,e,n,r){if(aArr(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(radix2carry(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${radix2carry(e,n)}`);let s=0,o=0;const a=powers[e],c=powers[n]-1,l=[];for(const h of t){if(anumber(h),h>=a)throw new Error(`convertRadix2: invalid data word=${h} from=${e}`);if(s=s<<e|h,o+e>32)throw new Error(`convertRadix2: carry overflow pos=${o} from=${e}`);for(o+=e;o>=n;o-=n)l.push((s>>o-n&c)>>>0);const f=powers[o];if(f===void 0)throw new Error("invalid carry");s&=f-1}if(s=s<<n-o&c,!r&&o>=e)throw new Error("Excess padding");if(!r&&s>0)throw new Error(`Non-zero padding: ${s}`);return r&&o>0&&l.push(s>>>0),l}function radix2(t,e=!1){if(anumber(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(radix2carry(8,t)>32||radix2carry(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!isBytes(n))throw new Error("radix2.encode input should be Uint8Array");return convertRadix2(Array.from(n),8,t,!e)},decode:n=>(anumArr("radix2.decode",n),Uint8Array.from(convertRadix2(n,t,8,e)))}}function unsafeWrapper(t){return afn(t),function(...e){try{return t.apply(null,e)}catch{}}}const BECH_ALPHABET=chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),join("")),POLYMOD_GENERATORS=[996825010,642813549,513874426,1027748829,705979059];function bech32Polymod(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<POLYMOD_GENERATORS.length;r++)(e>>r&1)===1&&(n^=POLYMOD_GENERATORS[r]);return n}function bechChecksum(t,e,n=1){const r=t.length;let s=1;for(let o=0;o<r;o++){const a=t.charCodeAt(o);if(a<33||a>126)throw new Error(`Invalid prefix (${t})`);s=bech32Polymod(s)^a>>5}s=bech32Polymod(s);for(let o=0;o<r;o++)s=bech32Polymod(s)^t.charCodeAt(o)&31;for(let o of e)s=bech32Polymod(s)^o;for(let o=0;o<6;o++)s=bech32Polymod(s);return s^=n,BECH_ALPHABET.encode(convertRadix2([s%powers[30]],30,5,!1))}function genBech32(t){const e=t==="bech32"?1:734539939,n=radix2(5),r=n.decode,s=n.encode,o=unsafeWrapper(r);function a(u,p,g=90){astr("bech32.encode prefix",u),isBytes(p)&&(p=Array.from(p)),anumArr("bech32.encode",p);const A=u.length;if(A===0)throw new TypeError(`Invalid prefix length ${A}`);const w=A+7+p.length;if(g!==!1&&w>g)throw new TypeError(`Length ${w} exceeds limit ${g}`);const y=u.toLowerCase(),_=bechChecksum(y,p,e);return`${y}1${BECH_ALPHABET.encode(p)}${_}`}function c(u,p=90){astr("bech32.decode input",u);const g=u.length;if(g<8||p!==!1&&g>p)throw new TypeError(`invalid string length: ${g} (${u}). Expected (8..${p})`);const A=u.toLowerCase();if(u!==A&&u!==u.toUpperCase())throw new Error("String must be lowercase or uppercase");const w=A.lastIndexOf("1");if(w===0||w===-1)throw new Error('Letter "1" must be present between prefix and data only');const y=A.slice(0,w),_=A.slice(w+1);if(_.length<6)throw new Error("Data must be at least 6 characters long");const N=BECH_ALPHABET.decode(_).slice(0,-6),C=bechChecksum(y,N,e);if(!_.endsWith(C))throw new Error(`Invalid checksum in ${u}: expected "${C}"`);return{prefix:y,words:N}}const l=unsafeWrapper(c);function h(u){const{prefix:p,words:g}=c(u,!1);return{prefix:p,words:g,bytes:r(g)}}function f(u,p){return a(u,s(p))}return{encode:a,decode:c,encodeFromBytes:f,decodeToBytes:h,decodeUnsafe:l,fromWords:r,fromWordsUnsafe:o,toWords:s}}const bech32=genBech32("bech32");var lib={},hasRequiredLib;function requireLib(){return hasRequiredLib||(hasRequiredLib=1,function(t){/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */Object.defineProperty(t,"__esModule",{value:!0}),t.bytes=t.stringToBytes=t.str=t.bytesToString=t.hex=t.utf8=t.bech32m=t.bech32=t.base58check=t.base58xmr=t.base58xrp=t.base58flickr=t.base58=t.base64url=t.base64=t.base32crockford=t.base32hex=t.base32=t.base16=t.utils=t.assertNumber=void 0;function e(E){if(!Number.isSafeInteger(E))throw new Error(`Wrong integer: ${E}`)}t.assertNumber=e;function n(...E){const R=(m,k)=>L=>m(k(L)),T=Array.from(E).reverse().reduce((m,k)=>m?R(m,k.encode):k.encode,void 0),B=E.reduce((m,k)=>m?R(m,k.decode):k.decode,void 0);return{encode:T,decode:B}}function r(E){return{encode:R=>{if(!Array.isArray(R)||R.length&&typeof R[0]!="number")throw new Error("alphabet.encode input should be an array of numbers");return R.map(T=>{if(e(T),T<0||T>=E.length)throw new Error(`Digit index outside alphabet: ${T} (alphabet: ${E.length})`);return E[T]})},decode:R=>{if(!Array.isArray(R)||R.length&&typeof R[0]!="string")throw new Error("alphabet.decode input should be array of strings");return R.map(T=>{if(typeof T!="string")throw new Error(`alphabet.decode: not string element=${T}`);const B=E.indexOf(T);if(B===-1)throw new Error(`Unknown letter: "${T}". Allowed: ${E}`);return B})}}}function s(E=""){if(typeof E!="string")throw new Error("join separator should be string");return{encode:R=>{if(!Array.isArray(R)||R.length&&typeof R[0]!="string")throw new Error("join.encode input should be array of strings");for(let T of R)if(typeof T!="string")throw new Error(`join.encode: non-string input=${T}`);return R.join(E)},decode:R=>{if(typeof R!="string")throw new Error("join.decode input should be string");return R.split(E)}}}function o(E,R="="){if(e(E),typeof R!="string")throw new Error("padding chr should be string");return{encode(T){if(!Array.isArray(T)||T.length&&typeof T[0]!="string")throw new Error("padding.encode input should be array of strings");for(let B of T)if(typeof B!="string")throw new Error(`padding.encode: non-string input=${B}`);for(;T.length*E%8;)T.push(R);return T},decode(T){if(!Array.isArray(T)||T.length&&typeof T[0]!="string")throw new Error("padding.encode input should be array of strings");for(let m of T)if(typeof m!="string")throw new Error(`padding.decode: non-string input=${m}`);let B=T.length;if(B*E%8)throw new Error("Invalid padding: string should have whole number of bytes");for(;B>0&&T[B-1]===R;B--)if(!((B-1)*E%8))throw new Error("Invalid padding: string has too much padding");return T.slice(0,B)}}}function a(E){if(typeof E!="function")throw new Error("normalize fn should be function");return{encode:R=>R,decode:R=>E(R)}}function c(E,R,T){if(R<2)throw new Error(`convertRadix: wrong from=${R}, base cannot be less than 2`);if(T<2)throw new Error(`convertRadix: wrong to=${T}, base cannot be less than 2`);if(!Array.isArray(E))throw new Error("convertRadix: data should be array");if(!E.length)return[];let B=0;const m=[],k=Array.from(E);for(k.forEach(L=>{if(e(L),L<0||L>=R)throw new Error(`Wrong integer: ${L}`)});;){let L=0,H=!0;for(let D=B;D<k.length;D++){const M=k[D],O=R*L+M;if(!Number.isSafeInteger(O)||R*L/R!==L||O-M!==R*L)throw new Error("convertRadix: carry overflow");if(L=O%T,k[D]=Math.floor(O/T),!Number.isSafeInteger(k[D])||k[D]*T+L!==O)throw new Error("convertRadix: carry overflow");if(H)k[D]?H=!1:B=D;else continue}if(m.push(L),H)break}for(let L=0;L<E.length-1&&E[L]===0;L++)m.push(0);return m.reverse()}const l=(E,R)=>R?l(R,E%R):E,h=(E,R)=>E+(R-l(E,R));function f(E,R,T,B){if(!Array.isArray(E))throw new Error("convertRadix2: data should be array");if(R<=0||R>32)throw new Error(`convertRadix2: wrong from=${R}`);if(T<=0||T>32)throw new Error(`convertRadix2: wrong to=${T}`);if(h(R,T)>32)throw new Error(`convertRadix2: carry overflow from=${R} to=${T} carryBits=${h(R,T)}`);let m=0,k=0;const L=2**T-1,H=[];for(const D of E){if(e(D),D>=2**R)throw new Error(`convertRadix2: invalid data word=${D} from=${R}`);if(m=m<<R|D,k+R>32)throw new Error(`convertRadix2: carry overflow pos=${k} from=${R}`);for(k+=R;k>=T;k-=T)H.push((m>>k-T&L)>>>0);m&=2**k-1}if(m=m<<T-k&L,!B&&k>=R)throw new Error("Excess padding");if(!B&&m)throw new Error(`Non-zero padding: ${m}`);return B&&k>0&&H.push(m>>>0),H}function u(E){return e(E),{encode:R=>{if(!(R instanceof Uint8Array))throw new Error("radix.encode input should be Uint8Array");return c(Array.from(R),2**8,E)},decode:R=>{if(!Array.isArray(R)||R.length&&typeof R[0]!="number")throw new Error("radix.decode input should be array of strings");return Uint8Array.from(c(R,E,2**8))}}}function p(E,R=!1){if(e(E),E<=0||E>32)throw new Error("radix2: bits should be in (0..32]");if(h(8,E)>32||h(E,8)>32)throw new Error("radix2: carry overflow");return{encode:T=>{if(!(T instanceof Uint8Array))throw new Error("radix2.encode input should be Uint8Array");return f(Array.from(T),8,E,!R)},decode:T=>{if(!Array.isArray(T)||T.length&&typeof T[0]!="number")throw new Error("radix2.decode input should be array of strings");return Uint8Array.from(f(T,E,8,R))}}}function g(E){if(typeof E!="function")throw new Error("unsafeWrapper fn should be function");return function(...R){try{return E.apply(null,R)}catch{}}}function A(E,R){if(e(E),typeof R!="function")throw new Error("checksum fn should be function");return{encode(T){if(!(T instanceof Uint8Array))throw new Error("checksum.encode: input should be Uint8Array");const B=R(T).slice(0,E),m=new Uint8Array(T.length+E);return m.set(T),m.set(B,T.length),m},decode(T){if(!(T instanceof Uint8Array))throw new Error("checksum.decode: input should be Uint8Array");const B=T.slice(0,-E),m=R(B).slice(0,E),k=T.slice(-E);for(let L=0;L<E;L++)if(m[L]!==k[L])throw new Error("Invalid checksum");return B}}}t.utils={alphabet:r,chain:n,checksum:A,radix:u,radix2:p,join:s,padding:o},t.base16=n(p(4),r("0123456789ABCDEF"),s("")),t.base32=n(p(5),r("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"),o(5),s("")),t.base32hex=n(p(5),r("0123456789ABCDEFGHIJKLMNOPQRSTUV"),o(5),s("")),t.base32crockford=n(p(5),r("0123456789ABCDEFGHJKMNPQRSTVWXYZ"),s(""),a(E=>E.toUpperCase().replace(/O/g,"0").replace(/[IL]/g,"1"))),t.base64=n(p(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"),o(6),s("")),t.base64url=n(p(6),r("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"),o(6),s(""));const w=E=>n(u(58),r(E),s(""));t.base58=w("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),t.base58flickr=w("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"),t.base58xrp=w("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");const y=[0,2,3,5,6,7,9,10,11];t.base58xmr={encode(E){let R="";for(let T=0;T<E.length;T+=8){const B=E.subarray(T,T+8);R+=t.base58.encode(B).padStart(y[B.length],"1")}return R},decode(E){let R=[];for(let T=0;T<E.length;T+=11){const B=E.slice(T,T+11),m=y.indexOf(B.length),k=t.base58.decode(B);for(let L=0;L<k.length-m;L++)if(k[L]!==0)throw new Error("base58xmr: wrong padding");R=R.concat(Array.from(k.slice(k.length-m)))}return Uint8Array.from(R)}};const _=E=>n(A(4,R=>E(E(R))),t.base58);t.base58check=_;const N=n(r("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),s("")),C=[996825010,642813549,513874426,1027748829,705979059];function U(E){const R=E>>25;let T=(E&33554431)<<5;for(let B=0;B<C.length;B++)(R>>B&1)===1&&(T^=C[B]);return T}function b(E,R,T=1){const B=E.length;let m=1;for(let k=0;k<B;k++){const L=E.charCodeAt(k);if(L<33||L>126)throw new Error(`Invalid prefix (${E})`);m=U(m)^L>>5}m=U(m);for(let k=0;k<B;k++)m=U(m)^E.charCodeAt(k)&31;for(let k of R)m=U(m)^k;for(let k=0;k<6;k++)m=U(m);return m^=T,N.encode(f([m%2**30],30,5,!1))}function v(E){const R=E==="bech32"?1:734539939,T=p(5),B=T.decode,m=T.encode,k=g(B);function L(O,F,K=90){if(typeof O!="string")throw new Error(`bech32.encode prefix should be string, not ${typeof O}`);if(!Array.isArray(F)||F.length&&typeof F[0]!="number")throw new Error(`bech32.encode words should be array of numbers, not ${typeof F}`);const z=O.length+7+F.length;if(K!==!1&&z>K)throw new TypeError(`Length ${z} exceeds limit ${K}`);return O=O.toLowerCase(),`${O}1${N.encode(F)}${b(O,F,R)}`}function H(O,F=90){if(typeof O!="string")throw new Error(`bech32.decode input should be string, not ${typeof O}`);if(O.length<8||F!==!1&&O.length>F)throw new TypeError(`Wrong string length: ${O.length} (${O}). Expected (8..${F})`);const K=O.toLowerCase();if(O!==K&&O!==O.toUpperCase())throw new Error("String must be lowercase or uppercase");O=K;const z=O.lastIndexOf("1");if(z===0||z===-1)throw new Error('Letter "1" must be present between prefix and data only');const q=O.slice(0,z),V=O.slice(z+1);if(V.length<6)throw new Error("Data must be at least 6 characters long");const j=N.decode(V).slice(0,-6),G=b(q,j,R);if(!V.endsWith(G))throw new Error(`Invalid checksum in ${O}: expected "${G}"`);return{prefix:q,words:j}}const D=g(H);function M(O){const{prefix:F,words:K}=H(O,!1);return{prefix:F,words:K,bytes:B(K)}}return{encode:L,decode:H,decodeToBytes:M,decodeUnsafe:D,fromWords:B,fromWordsUnsafe:k,toWords:m}}t.bech32=v("bech32"),t.bech32m=v("bech32m"),t.utf8={encode:E=>new TextDecoder().decode(E),decode:E=>new TextEncoder().encode(E)},t.hex=n(p(4),r("0123456789abcdef"),s(""),a(E=>{if(typeof E!="string"||E.length%2)throw new TypeError(`hex.decode: expected string, got ${typeof E} with length ${E.length}`);return E.toLowerCase()}));const $={utf8:t.utf8,hex:t.hex,base16:t.base16,base32:t.base32,base64:t.base64,base64url:t.base64url,base58:t.base58,base58xmr:t.base58xmr},S=`Invalid encoding type. Available types: ${Object.keys($).join(", ")}`,I=(E,R)=>{if(typeof E!="string"||!$.hasOwnProperty(E))throw new TypeError(S);if(!(R instanceof Uint8Array))throw new TypeError("bytesToString() expects Uint8Array");return $[E].encode(R)};t.bytesToString=I,t.str=t.bytesToString;const P=(E,R)=>{if(!$.hasOwnProperty(E))throw new TypeError(S);if(typeof R!="string")throw new TypeError("stringToBytes() expects string");return $[E].decode(R)};t.stringToBytes=P,t.bytes=t.stringToBytes}(lib)),lib}var bolt11,hasRequiredBolt11;function requireBolt11(){if(hasRequiredBolt11)return bolt11;hasRequiredBolt11=1;const{bech32:t,hex:e,utf8:n}=requireLib(),r={bech32:"bc",pubKeyHash:0,scriptHash:5,validWitnessVersions:[0]},s={bech32:"tb",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},o={bech32:"tbs",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},a={bech32:"bcrt",pubKeyHash:111,scriptHash:196,validWitnessVersions:[0]},c={bech32:"sb",pubKeyHash:63,scriptHash:123,validWitnessVersions:[0]},l=["option_data_loss_protect","initial_routing_sync","option_upfront_shutdown_script","gossip_queries","var_onion_optin","gossip_queries_ex","option_static_remotekey","payment_secret","basic_mpp","option_support_large_channel"],h={m:BigInt(1e3),u:BigInt(1e6),n:BigInt(1e9),p:BigInt(1e12)},f=BigInt("2100000000000000000"),u=BigInt(1e11),p={payment_hash:1,payment_secret:16,description:13,payee:19,description_hash:23,expiry:6,min_final_cltv_expiry:24,fallback_address:9,route_hint:3,feature_bits:5,metadata:27},g={};for(let b=0,v=Object.keys(p);b<v.length;b++){const $=v[b],S=p[v[b]].toString();g[S]=$}const A={1:b=>e.encode(t.fromWordsUnsafe(b)),16:b=>e.encode(t.fromWordsUnsafe(b)),13:b=>n.encode(t.fromWordsUnsafe(b)),19:b=>e.encode(t.fromWordsUnsafe(b)),23:b=>e.encode(t.fromWordsUnsafe(b)),27:b=>e.encode(t.fromWordsUnsafe(b)),6:y,24:y,3:_,5:N};function w(b){return v=>({tagCode:parseInt(b),words:t.encode("unknown",v,Number.MAX_SAFE_INTEGER)})}function y(b){return b.reverse().reduce((v,$,S)=>v+$*Math.pow(32,S),0)}function _(b){const v=[];let $,S,I,P,E,R=t.fromWordsUnsafe(b);for(;R.length>0;)$=e.encode(R.slice(0,33)),S=e.encode(R.slice(33,41)),I=parseInt(e.encode(R.slice(41,45)),16),P=parseInt(e.encode(R.slice(45,49)),16),E=parseInt(e.encode(R.slice(49,51)),16),R=R.slice(51),v.push({pubkey:$,short_channel_id:S,fee_base_msat:I,fee_proportional_millionths:P,cltv_expiry_delta:E});return v}function N(b){const v=b.slice().reverse().map(I=>[!!(I&1),!!(I&2),!!(I&4),!!(I&8),!!(I&16)]).reduce((I,P)=>I.concat(P),[]);for(;v.length<l.length*2;)v.push(!1);const $={};l.forEach((I,P)=>{let E;v[P*2]?E="required":v[P*2+1]?E="supported":E="unsupported",$[I]=E});const S=v.slice(l.length*2);return $.extra_bits={start_bit:l.length*2,bits:S,has_required:S.reduce((I,P,E)=>E%2!==0?I||!1:I||P,!1)},$}function C(b,v){let $,S;if(b.slice(-1).match(/^[munp]$/))$=b.slice(-1),S=b.slice(0,-1);else{if(b.slice(-1).match(/^[^munp0-9]$/))throw new Error("Not a valid multiplier for the amount");S=b}if(!S.match(/^\d+$/))throw new Error("Not a valid human readable amount");const I=BigInt(S),P=$?I*u/h[$]:I*u;if($==="p"&&I%BigInt(10)!==BigInt(0)||P>f)throw new Error("Amount is outside of valid range");return v?P.toString():P}function U(b,v){if(typeof b!="string")throw new Error("Lightning Payment Request must be string");if(b.slice(0,2).toLowerCase()!=="ln")throw new Error("Not a proper lightning payment request");const $=[],S=t.decode(b,Number.MAX_SAFE_INTEGER);b=b.toLowerCase();const I=S.prefix;let P=S.words,E=b.slice(I.length+1),R=P.slice(-104);P=P.slice(0,-104);let T=I.match(/^ln(\S+?)(\d*)([a-zA-Z]?)$/);if(T&&!T[2]&&(T=I.match(/^ln(\S+)$/)),!T)throw new Error("Not a proper lightning payment request");$.push({name:"lightning_network",letters:"ln"});const B=T[1];let m;if(v){if(v.bech32===void 0||v.pubKeyHash===void 0||v.scriptHash===void 0||!Array.isArray(v.validWitnessVersions))throw new Error("Invalid network");m=v}else switch(B){case r.bech32:m=r;break;case s.bech32:m=s;break;case o.bech32:m=o;break;case a.bech32:m=a;break;case c.bech32:m=c;break}if(!m||m.bech32!==B)throw new Error("Unknown coin bech32 prefix");$.push({name:"coin_network",letters:B,value:m});const k=T[2];let L;if(k){const q=T[3];L=C(k+q,!0),$.push({name:"amount",letters:T[2]+T[3],value:L})}else L=null;$.push({name:"separator",letters:"1"});const H=y(P.slice(0,7));P=P.slice(7),$.push({name:"timestamp",letters:E.slice(0,7),value:H}),E=E.slice(7);let D,M,O,F;for(;P.length>0;){const q=P[0].toString();D=g[q]||"unknown_tag",M=A[q]||w(q),P=P.slice(1),O=y(P.slice(0,2)),P=P.slice(2),F=P.slice(0,O),P=P.slice(O),$.push({name:D,tag:E[0],letters:E.slice(0,3+O),value:M(F)}),E=E.slice(3+O)}$.push({name:"signature",letters:E.slice(0,104),value:e.encode(t.fromWordsUnsafe(R))}),E=E.slice(104),$.push({name:"checksum",letters:E});let K={paymentRequest:b,sections:$,get expiry(){let q=$.find(V=>V.name==="expiry");if(q)return z("timestamp")+q.value},get route_hints(){return $.filter(q=>q.name==="route_hint").map(q=>q.value)}};for(let q in p)q!=="route_hint"&&Object.defineProperty(K,q,{get(){return z(q)}});return K;function z(q){let V=$.find(j=>j.name===q);return V?V.value:void 0}}return bolt11={decode:U,hrpToMillisat:C},bolt11}requireBolt11();function getRelaysForSync(t,e,n="write"){if(!t.outboxTracker)return;const r=t.outboxTracker.data.get(e);if(r)return n==="write"?r.writeRelays:r.readRelays}async function getWriteRelaysFor(t,e,n="write"){if(t.outboxTracker)return t.outboxTracker.data.has(e)||await t.outboxTracker.trackUsers([e]),getRelaysForSync(t,e,n)}function getTopRelaysForAuthors(t,e){const n=new Map;return e.forEach(s=>{const o=getRelaysForSync(t,s);o&&o.forEach(a=>{const c=n.get(a)||0;n.set(a,c+1)})}),Array.from(n.entries()).sort((s,o)=>o[1]-s[1]).map(s=>s[0])}function getAllRelaysForAllPubkeys(t,e,n="read"){const r=new Map,s=new Set;return e.forEach(o=>{const a=getRelaysForSync(t,o,n);a&&a.size>0?(a.forEach(c=>{(r.get(c)||new Set).add(o)}),r.set(o,a)):s.add(o)}),{pubkeysToRelays:r,authorsMissingRelays:s}}function chooseRelayCombinationForPubkeys(t,e,n,{count:r,preferredRelays:s}={}){r??(r=2),s??(s=new Set);const o=t.pool,a=o.connectedRelays();a.forEach(p=>{s.add(p.url)});const c=new Map,{pubkeysToRelays:l,authorsMissingRelays:h}=getAllRelaysForAllPubkeys(t,e,n),f=getTopRelaysForAuthors(t,e),u=(p,g)=>{const A=c.get(g)||[];A.push(p),c.set(g,A)};for(const[p,g]of l.entries()){let A=r;for(const w of a)g.has(w.url)&&(u(p,w.url),A--);for(const w of g)c.has(w)&&(u(p,w),A--);if(!(A<=0))for(const w of f){if(A<=0)break;g.has(w)&&(u(p,w),A--)}}for(const p of h)o.permanentAndConnectedRelays().forEach(g=>{const A=c.get(g.url)||[];A.push(p),c.set(g.url,A)});return c}function getRelaysForFilterWithAuthors(t,e,n=2){return chooseRelayCombinationForPubkeys(t,e,"write",{count:n})}function tryNormalizeRelayUrl(t){try{return normalizeRelayUrl(t)}catch{return}}function normalizeRelayUrl(t){let e=normalizeUrl(t.toLowerCase(),{stripAuthentication:!1,stripWWW:!1,stripHash:!0});return e.endsWith("/")||(e+="/"),e}function normalize(t){const e=new Set;for(const n of t)try{e.add(normalizeRelayUrl(n))}catch{}return Array.from(e)}var DATA_URL_DEFAULT_MIME_TYPE="text/plain",DATA_URL_DEFAULT_CHARSET="us-ascii",testParameter=(t,e)=>e.some(n=>n instanceof RegExp?n.test(t):n===t),supportedProtocols=new Set(["https:","http:","file:"]),hasCustomProtocol=t=>{try{const{protocol:e}=new URL(t);return e.endsWith(":")&&!e.includes(".")&&!supportedProtocols.has(e)}catch{return!1}},normalizeDataURL=(t,{stripHash:e})=>{var u,p,g,A;const n=/^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(t);if(!n)throw new Error(`Invalid URL: ${t}`);let r=((u=n.groups)==null?void 0:u.type)??"",s=((p=n.groups)==null?void 0:p.data)??"",o=((g=n.groups)==null?void 0:g.hash)??"";const a=r.split(";");o=e?"":o;let c=!1;a[a.length-1]==="base64"&&(a.pop(),c=!0);const l=((A=a.shift())==null?void 0:A.toLowerCase())??"",f=[...a.map(w=>{let[y,_=""]=w.split("=").map(N=>N.trim());return y==="charset"&&(_=_.toLowerCase(),_===DATA_URL_DEFAULT_CHARSET)?"":`${y}${_?`=${_}`:""}`}).filter(Boolean)];return c&&f.push("base64"),(f.length>0||l&&l!==DATA_URL_DEFAULT_MIME_TYPE)&&f.unshift(l),`data:${f.join(";")},${c?s.trim():s}${o?`#${o}`:""}`};function normalizeUrl(t,e){if(e={defaultProtocol:"http",normalizeProtocol:!0,forceHttp:!1,forceHttps:!1,stripAuthentication:!0,stripHash:!1,stripTextFragment:!0,stripWWW:!0,removeQueryParameters:[/^utm_\w+/i],removeTrailingSlash:!0,removeSingleSlash:!0,removeDirectoryIndex:!1,removeExplicitPort:!1,sortQueryParameters:!0,...e},typeof e.defaultProtocol=="string"&&!e.defaultProtocol.endsWith(":")&&(e.defaultProtocol=`${e.defaultProtocol}:`),t=t.trim(),/^data:/i.test(t))return normalizeDataURL(t,e);if(hasCustomProtocol(t))return t;const n=t.startsWith("//");!n&&/^\.*\//.test(t)||(t=t.replace(/^(?!(?:\w+:)?\/\/)|^\/\//,e.defaultProtocol));const s=new URL(t);if(e.forceHttp&&e.forceHttps)throw new Error("The `forceHttp` and `forceHttps` options cannot be used together");if(e.forceHttp&&s.protocol==="https:"&&(s.protocol="http:"),e.forceHttps&&s.protocol==="http:"&&(s.protocol="https:"),e.stripAuthentication&&(s.username="",s.password=""),e.stripHash?s.hash="":e.stripTextFragment&&(s.hash=s.hash.replace(/#?:~:text.*?$/i,"")),s.pathname){const a=/\b[a-z][a-z\d+\-.]{1,50}:\/\//g;let c=0,l="";for(;;){const f=a.exec(s.pathname);if(!f)break;const u=f[0],p=f.index,g=s.pathname.slice(c,p);l+=g.replace(/\/{2,}/g,"/"),l+=u,c=p+u.length}const h=s.pathname.slice(c,s.pathname.length);l+=h.replace(/\/{2,}/g,"/"),s.pathname=l}if(s.pathname)try{s.pathname=decodeURI(s.pathname)}catch{}if(e.removeDirectoryIndex===!0&&(e.removeDirectoryIndex=[/^index\.[a-z]+$/]),Array.isArray(e.removeDirectoryIndex)&&e.removeDirectoryIndex.length>0){let a=s.pathname.split("/");const c=a[a.length-1];testParameter(c,e.removeDirectoryIndex)&&(a=a.slice(0,-1),s.pathname=a.slice(1).join("/")+"/")}if(s.hostname&&(s.hostname=s.hostname.replace(/\.$/,""),e.stripWWW&&/^www\.(?!www\.)[a-z\-\d]{1,63}\.[a-z.\-\d]{2,63}$/.test(s.hostname)&&(s.hostname=s.hostname.replace(/^www\./,""))),Array.isArray(e.removeQueryParameters))for(const a of[...s.searchParams.keys()])testParameter(a,e.removeQueryParameters)&&s.searchParams.delete(a);if(!Array.isArray(e.keepQueryParameters)&&e.removeQueryParameters===!0&&(s.search=""),Array.isArray(e.keepQueryParameters)&&e.keepQueryParameters.length>0)for(const a of[...s.searchParams.keys()])testParameter(a,e.keepQueryParameters)||s.searchParams.delete(a);if(e.sortQueryParameters){s.searchParams.sort();try{s.search=decodeURIComponent(s.search)}catch{}}e.removeTrailingSlash&&(s.pathname=s.pathname.replace(/\/$/,"")),e.removeExplicitPort&&s.port&&(s.port="");const o=t;return t=s.toString(),!e.removeSingleSlash&&s.pathname==="/"&&!o.endsWith("/")&&s.hash===""&&(t=t.replace(/\/$/,"")),(e.removeTrailingSlash||s.pathname==="/")&&s.hash===""&&e.removeSingleSlash&&(t=t.replace(/\/$/,"")),n&&!e.normalizeProtocol&&(t=t.replace(/^http:\/\//,"//")),e.stripProtocol&&(t=t.replace(/^(?:https?:)?\/\//,"")),t}var MAX_RECONNECT_ATTEMPTS=5,FLAPPING_THRESHOLD_MS=1e3,NDKRelayConnectivity=class{constructor(t,e){x(this,"ndkRelay");x(this,"ws");x(this,"_status");x(this,"timeoutMs");x(this,"connectedAt");x(this,"_connectionStats",{attempts:0,success:0,durations:[]});x(this,"debug");x(this,"netDebug");x(this,"connectTimeout");x(this,"reconnectTimeout");x(this,"ndk");x(this,"openSubs",new Map);x(this,"openCountRequests",new Map);x(this,"openEventPublishes",new Map);x(this,"serial",0);x(this,"baseEoseTimeout",4400);x(this,"updateConnectionStats",{connected:()=>{this._connectionStats.success++,this._connectionStats.connectedAt=Date.now()},disconnected:()=>{this._connectionStats.connectedAt&&(this._connectionStats.durations.push(Date.now()-this._connectionStats.connectedAt),this._connectionStats.durations.length>100&&this._connectionStats.durations.shift()),this._connectionStats.connectedAt=void 0},attempt:()=>{this._connectionStats.attempts++,this._connectionStats.connectedAt=Date.now()}});this.ndkRelay=t,this._status=1;const n=Math.floor(Math.random()*1e3);this.debug=this.ndkRelay.debug.extend("connectivity"+n),this.ndk=e}async connect(t,e=!0){if(this._status!==2&&this._status!==1||this.reconnectTimeout){this.debug("Relay requested to be connected but was in state %s or it had a reconnect timeout",this._status);return}this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),t??(t=this.timeoutMs),!this.timeoutMs&&t&&(this.timeoutMs=t),this.timeoutMs&&(this.connectTimeout=setTimeout(()=>this.onConnectionError(e),this.timeoutMs));try{this.updateConnectionStats.attempt(),this._status===1?this._status=4:this._status=2,this.ws=new WebSocket(this.ndkRelay.url),this.ws.onopen=this.onConnect.bind(this),this.ws.onclose=this.onDisconnect.bind(this),this.ws.onmessage=this.onMessage.bind(this),this.ws.onerror=this.onError.bind(this)}catch(n){throw this.debug(`Failed to connect to ${this.ndkRelay.url}`,n),this._status=1,e?this.handleReconnection():this.ndkRelay.emit("delayed-connect",2*24*60*60*1e3),n}}disconnect(){var t;this._status=0;try{(t=this.ws)==null||t.close()}catch(e){this.debug("Failed to disconnect",e),this._status=1}}onConnectionError(t){this.debug(`Error connecting to ${this.ndkRelay.url}`,this.timeoutMs),t&&!this.reconnectTimeout&&this.handleReconnection()}onConnect(){var t;(t=this.netDebug)==null||t.call(this,"connected",this.ndkRelay),this.reconnectTimeout&&(clearTimeout(this.reconnectTimeout),this.reconnectTimeout=void 0),this.connectTimeout&&(clearTimeout(this.connectTimeout),this.connectTimeout=void 0),this.updateConnectionStats.connected(),this._status=5,this.ndkRelay.emit("connect"),this.ndkRelay.emit("ready")}onDisconnect(){var t;(t=this.netDebug)==null||t.call(this,"disconnected",this.ndkRelay),this.updateConnectionStats.disconnected(),this._status===5&&this.handleReconnection(),this._status=1,this.ndkRelay.emit("disconnect")}onMessage(t){var e;(e=this.netDebug)==null||e.call(this,t.data,this.ndkRelay,"recv");try{const n=JSON.parse(t.data),[r,s,...o]=n;switch(r){case"EVENT":{const a=this.openSubs.get(s),c=n[2];if(!a){this.debug(`Received event for unknown subscription ${s}`);return}a.onevent(c);return}case"COUNT":{const a=n[2],c=this.openCountRequests.get(s);c&&(c.resolve(a.count),this.openCountRequests.delete(s));return}case"EOSE":{const a=this.openSubs.get(s);if(!a)return;a.oneose(s);return}case"OK":{const a=n[2],c=n[3],l=this.openEventPublishes.get(s),h=l==null?void 0:l.pop();if(!l||!h){this.debug("Received OK for unknown event publish",s);return}a?h.resolve(c):h.reject(new Error(c)),l.length===0?this.openEventPublishes.delete(s):this.openEventPublishes.set(s,l);return}case"CLOSED":{const a=this.openSubs.get(s);if(!a)return;a.onclosed(n[2]);return}case"NOTICE":this.onNotice(n[1]);return;case"AUTH":{this.onAuthRequested(n[1]);return}}}catch(n){this.debug(`Error parsing message from ${this.ndkRelay.url}: ${n.message}`,n==null?void 0:n.stack);return}}async onAuthRequested(t){var n,r,s;const e=this.ndkRelay.authPolicy??((n=this.ndk)==null?void 0:n.relayAuthDefaultPolicy);if(this.debug("Relay requested authentication",{havePolicy:!!e}),this._status===7){this.debug("Already authenticating, ignoring");return}if(this._status=6,e){if(this._status>=5){this._status=7;let o;try{o=await e(this.ndkRelay,t)}catch(a){this.debug("Authentication policy threw an error",a),o=!1}if(this.debug("Authentication policy returned",!!o),o instanceof NDKEvent||o===!0){o instanceof NDKEvent&&await this.auth(o);const a=async()=>{if(this._status>=5&&this._status<8){const c=new NDKEvent(this.ndk);c.kind=22242,c.tags=[["relay",this.ndkRelay.url],["challenge",t]],await c.sign(),this.auth(c).then(()=>{this._status=8,this.ndkRelay.emit("authed"),this.debug("Authentication successful")}).catch(l=>{this._status=6,this.ndkRelay.emit("auth:failed",l),this.debug("Authentication failed",l)})}else this.debug("Authentication failed, it changed status, status is %d",this._status)};o===!0&&((r=this.ndk)!=null&&r.signer?a().catch(c=>{console.error("Error authenticating",c)}):(this.debug("No signer available for authentication localhost"),(s=this.ndk)==null||s.once("signer:ready",a))),this._status=5,this.ndkRelay.emit("authed")}}}else this.ndkRelay.emit("auth",t)}onError(t){this.debug(`WebSocket error on ${this.ndkRelay.url}:`,t)}get status(){return this._status}isAvailable(){return this._status===5}isFlapping(){const t=this._connectionStats.durations;if(t.length%3!==0)return!1;const n=t.reduce((a,c)=>a+c,0)/t.length,r=t.map(a=>Math.pow(a-n,2)).reduce((a,c)=>a+c,0)/t.length;return Math.sqrt(r)<FLAPPING_THRESHOLD_MS}async onNotice(t){this.ndkRelay.emit("notice",t)}handleReconnection(t=0){if(this.reconnectTimeout)return;if(this.isFlapping()){this.ndkRelay.emit("flapping",this._connectionStats),this._status=3;return}const e=this.connectedAt?Math.max(0,6e4-(Date.now()-this.connectedAt)):5e3*(this._connectionStats.attempts+1);this.reconnectTimeout=setTimeout(()=>{this.reconnectTimeout=void 0,this._status=2,this.connect().catch(n=>{t<MAX_RECONNECT_ATTEMPTS?setTimeout(()=>{this.handleReconnection(t+1)},1e3*(t+1)^4):this.debug("Reconnect failed")})},e),this.ndkRelay.emit("delayed-connect",e),this.debug("Reconnecting in",e),this._connectionStats.nextReconnectAt=Date.now()+e}async send(t){var e,n,r;this._status>=5&&((e=this.ws)==null?void 0:e.readyState)===WebSocket.OPEN?((n=this.ws)==null||n.send(t),(r=this.netDebug)==null||r.call(this,t,this.ndkRelay,"send")):this.debug(`Not connected to ${this.ndkRelay.url} (%d), not sending message ${t}`,this._status)}async auth(t){const e=new Promise((n,r)=>{const s=this.openEventPublishes.get(t.id)??[];s.push({resolve:n,reject:r}),this.openEventPublishes.set(t.id,s)});return this.send('["AUTH",'+JSON.stringify(t.rawEvent())+"]"),e}async publish(t){const e=new Promise((n,r)=>{const s=this.openEventPublishes.get(t.id)??[];s.length>0&&console.warn("Duplicate event publishing detected, you are publishing event "+t.id+" twice"),s.push({resolve:n,reject:r}),this.openEventPublishes.set(t.id,s)});return this.send('["EVENT",'+JSON.stringify(t)+"]"),e}async count(t,e){this.serial++;const n=(e==null?void 0:e.id)||"count:"+this.serial,r=new Promise((s,o)=>{this.openCountRequests.set(n,{resolve:s,reject:o})});return this.send('["COUNT","'+n+'",'+JSON.stringify(t).substring(1)),r}close(t,e){this.send('["CLOSE","'+t+'"]');const n=this.openSubs.get(t);this.openSubs.delete(t),n&&n.onclose(e)}req(t){this.send('["REQ","'+t.subId+'",'+JSON.stringify(t.executeFilters).substring(1))+"",this.openSubs.set(t.subId,t)}get connectionStats(){return this._connectionStats}get url(){return this.ndkRelay.url}get connected(){var t;return this._status>=5&&((t=this.ws)==null?void 0:t.readyState)===WebSocket.OPEN}},NDKRelayPublisher=class{constructor(t){x(this,"ndkRelay");x(this,"debug");this.ndkRelay=t,this.debug=t.debug.extend("publisher")}async publish(t,e=2500){let n;const r=()=>new Promise((f,u)=>{try{this.publishEvent(t).then(p=>{this.ndkRelay.emit("published",t),t.emit("relay:published",this.ndkRelay),f(!0)}).catch(u)}catch(p){u(p)}}),s=new Promise((f,u)=>{n=setTimeout(()=>{n=void 0,u(new Error("Timeout: "+e+"ms"))},e)}),o=()=>{r().then(f=>a(f)).catch(f=>c(f))};let a,c;const l=f=>{throw this.ndkRelay.debug("Publish failed",f,t.id),this.ndkRelay.emit("publish:failed",t,f),t.emit("relay:publish:failed",this.ndkRelay,f),f},h=()=>{n&&clearTimeout(n),this.ndkRelay.removeListener("connect",o)};return this.ndkRelay.status>=5?Promise.race([r(),s]).catch(l).finally(h):(this.ndkRelay.status<=1?(console.warn("Relay is disconnected, trying to connect to publish an event",this.ndkRelay.url),this.ndkRelay.connect()):console.warn("Relay not connected, waiting for connection to publish an event",this.ndkRelay.url),Promise.race([new Promise((f,u)=>{a=f,c=u,this.ndkRelay.once("connect",o)}),s]).catch(l).finally(h))}async publishEvent(t){return this.ndkRelay.connectivity.publish(t.rawEvent())}};function filterFingerprint(t,e){const n=[];for(const s of t){const o=Object.entries(s||{}).map(([a,c])=>["since","until"].includes(a)?a+":"+c:a).sort().join("-");n.push(o)}let r=e?"+":"";return r+=n.join("|"),r}function mergeFilters(t){const e=[],n={};return t.filter(r=>!!r.limit).forEach(r=>e.push(r)),t=t.filter(r=>!r.limit),t.length===0?e:(t.forEach(r=>{Object.entries(r).forEach(([s,o])=>{Array.isArray(o)?n[s]===void 0?n[s]=[...o]:n[s]=Array.from(new Set([...n[s],...o])):n[s]=o})}),[...e,n])}var NDKRelaySubscription=class{constructor(t,e){x(this,"fingerprint");x(this,"items",new Map);x(this,"topSubscriptionManager");x(this,"debug");x(this,"status",0);x(this,"onClose");x(this,"relay");x(this,"eosed",!1);x(this,"executionTimer");x(this,"fireTime");x(this,"delayType");x(this,"executeFilters");x(this,"id",Math.random().toString(36).substring(7));x(this,"_subId");x(this,"subIdParts",new Set);x(this,"executeOnRelayReady",()=>{this.status===2&&(this.status=1,this.execute())});x(this,"reExecuteAfterAuth",(()=>{const t=this.subId;this.debug("Re-executing after auth",this.items.size),this.eosed?this.relay.close(this.subId):this.debug("We are abandoning an opened subscription, once it EOSE's, the handler will close it",{oldSubId:t}),this._subId=void 0,this.status=1,this.execute(),this.debug("Re-executed after auth %s 👉 %s",t,this.subId)}).bind(this));this.relay=t,this.debug=t.debug.extend("subscription-"+this.id),this.fingerprint=e||Math.random().toString(36).substring(7)}get subId(){return this._subId?this._subId:(this._subId=this.fingerprint.slice(0,15),this._subId)}addSubIdPart(t){this.subIdParts.add(t)}addItem(t,e){if(!this.items.has(t.internalId))switch(t.on("close",this.removeItem.bind(this,t)),this.items.set(t.internalId,{subscription:t,filters:e}),this.status!==3&&t.subId&&(!this._subId||this._subId.length<48)&&(this.status===0||this.status===1)&&this.addSubIdPart(t.subId),this.status){case 0:this.evaluateExecutionPlan(t);break;case 3:console.log("BUG: This should not happen: This subscription needs to catch up with a subscription that was already running",e);break;case 1:this.evaluateExecutionPlan(t);break;case 4:throw this.debug("Subscription is closed, cannot add new items %o (%o)",t,e),new Error("Cannot add new items to a closed subscription")}}removeItem(t){if(this.items.delete(t.internalId),this.items.size===0){if(!this.eosed)return;this.close()}}close(){if(this.status===4)return;const t=this.status;if(this.status=4,t===3)try{this.relay.close(this.subId)}catch(e){this.debug("Error closing subscription",e,this)}else this.debug("Subscription wanted to close but it wasn't running, this is probably ok",{subId:this.subId,prevStatus:t,sub:this});this.cleanup()}cleanup(){this.executionTimer&&clearTimeout(this.executionTimer),this.relay.off("ready",this.executeOnRelayReady),this.relay.off("authed",this.reExecuteAfterAuth),this.onClose&&this.onClose(this)}evaluateExecutionPlan(t){if(!t.isGroupable()){this.status=1,this.execute();return}if(t.filters.find(r=>!!r.limit)&&(this.executeFilters=this.compileFilters(),this.executeFilters.length>=10)){this.status=1,this.execute();return}const e=t.groupableDelay,n=t.groupableDelayType;if(!e)throw new Error("Cannot group a subscription without a delay");if(this.status===0)this.schedule(e,n);else{const r=this.delayType,s=this.fireTime-Date.now();if(r==="at-least"&&n==="at-least")s<e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else if(r==="at-least"&&n==="at-most")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else if(r==="at-most"&&n==="at-most")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else if(r==="at-most"&&n==="at-least")s>e&&(this.executionTimer&&clearTimeout(this.executionTimer),this.schedule(e,n));else throw new Error("Unknown delay type combination "+r+" "+n)}}schedule(t,e){this.status=1;const n=Date.now();this.fireTime=n+t,this.delayType=e;const r=setTimeout(this.execute.bind(this),t);e==="at-least"&&(this.executionTimer=r)}finalizeSubId(){this.subIdParts.size>0?this._subId=Array.from(this.subIdParts).join("-"):this._subId=this.fingerprint.slice(0,15),this._subId+="-"+Math.random().toString(36).substring(2,7)}execute(){if(this.status===1){if(this.relay.connected)this.relay.status<8&&this.relay.once("authed",this.reExecuteAfterAuth);else{this.status=2,this.relay.once("ready",this.executeOnRelayReady);return}this.status=3,this.finalizeSubId(),this.executeFilters=this.compileFilters(),this.relay.req(this)}}onstart(){}onevent(t){var e;(e=this.topSubscriptionManager)==null||e.seenEvent(t.id,this.relay);for(const{subscription:n}of this.items.values())matchFilters(n.filters,t)&&n.eventReceived(t,this.relay,!1)}oneose(t){if(this.eosed=!0,t!==this.subId){this.debug("Received EOSE for an abandoned subscription",t,this.subId),this.relay.close(t);return}this.items.size===0&&this.close();for(const{subscription:e}of this.items.values())e.eoseReceived(this.relay),e.closeOnEose&&this.removeItem(e)}onclose(t){this.status=4}onclosed(t){if(t)for(const{subscription:e}of this.items.values())e.closedReceived(this.relay,t)}compileFilters(){const t=[],e=Array.from(this.items.values()).map(r=>r.filters);if(!e[0])return this.debug("👀 No filters to merge",this.items),console.error("BUG: No filters to merge!",this.items),[];const n=e[0].length;for(let r=0;r<n;r++){const s=e.map(o=>o[r]);t.push(...mergeFilters(s))}return t}},NDKRelaySubscriptionManager=class{constructor(t,e){x(this,"relay");x(this,"subscriptions");x(this,"topSubscriptionManager");this.relay=t,this.subscriptions=new Map,this.topSubscriptionManager=e}addSubscription(t,e){let n;if(!t.isGroupable())n=this.createSubscription(t,e);else{const r=filterFingerprint(e,t.closeOnEose);r&&(n=(this.subscriptions.get(r)||[]).find(o=>o.status<3)),n??(n=this.createSubscription(t,e,r))}n.addItem(t,e)}createSubscription(t,e,n){const r=new NDKRelaySubscription(this.relay,n);r.topSubscriptionManager=this.topSubscriptionManager,r.onClose=this.onRelaySubscriptionClose.bind(this);const s=this.subscriptions.get(r.fingerprint)??[];return this.subscriptions.set(r.fingerprint,[...s,r]),r}onRelaySubscriptionClose(t){let e=this.subscriptions.get(t.fingerprint)??[];e?e.length===1?this.subscriptions.delete(t.fingerprint):(e=e.filter(n=>n.id!==t.id),this.subscriptions.set(t.fingerprint,e),console.log("removing a subscription",{fingerprint:t.fingerprint,id:t.id,newSize:this.subscriptions.size})):console.warn("Unexpectedly did not find a subscription with fingerprint",t.fingerprint)}},se,NDKRelay=(se=class extends libExports.EventEmitter{constructor(n,r,s){super();x(this,"url");x(this,"scores");x(this,"connectivity");x(this,"subs");x(this,"publisher");x(this,"authPolicy");x(this,"lowestValidationRatio");x(this,"targetValidationRatio");x(this,"validationRatioFn");x(this,"validatedEventCount",0);x(this,"nonValidatedEventCount",0);x(this,"trusted",!1);x(this,"complaining",!1);x(this,"debug");x(this,"req");x(this,"close");this.url=normalizeRelayUrl(n),this.scores=new Map,this.debug=debug7(`ndk:relay:${n}`),this.connectivity=new NDKRelayConnectivity(this,s),this.connectivity.netDebug=s==null?void 0:s.netDebug,this.req=this.connectivity.req.bind(this.connectivity),this.close=this.connectivity.close.bind(this.connectivity),this.subs=new NDKRelaySubscriptionManager(this,s==null?void 0:s.subManager),this.publisher=new NDKRelayPublisher(this),this.authPolicy=r,this.targetValidationRatio=s==null?void 0:s.initialValidationRatio,this.lowestValidationRatio=s==null?void 0:s.lowestValidationRatio,this.validationRatioFn=((s==null?void 0:s.validationRatioFn)??se.defaultValidationRatioUpdateFn).bind(this),this.updateValidationRatio(),s||console.trace("relay created without ndk")}updateValidationRatio(){setTimeout(()=>{this.updateValidationRatio()},3e4)}get status(){return this.connectivity.status}get connectionStats(){return this.connectivity.connectionStats}async connect(n,r=!0){return this.connectivity.connect(n,r)}disconnect(){this.status!==1&&this.connectivity.disconnect()}subscribe(n,r){this.subs.addSubscription(n,r)}async publish(n,r=2500){return this.publisher.publish(n,r)}referenceTags(){return[["r",this.url]]}addValidatedEvent(){this.validatedEventCount++}addNonValidatedEvent(){this.nonValidatedEventCount++}get validationRatio(){return this.nonValidatedEventCount===0?1:this.validatedEventCount/(this.validatedEventCount+this.nonValidatedEventCount)}shouldValidateEvent(){return this.trusted?!1:this.targetValidationRatio===void 0?!0:this.validationRatio<this.targetValidationRatio}get connected(){return this.connectivity.connected}},x(se,"defaultValidationRatioUpdateFn",(n,r,s)=>{if(n.lowestValidationRatio===void 0||n.targetValidationRatio===void 0)return 1;let o=n.validationRatio;if(n.validationRatio>n.targetValidationRatio){const a=r/100;o=Math.max(n.lowestValidationRatio,n.validationRatio-a)}return o<n.validationRatio?o:n.validationRatio}),se),NDKPublishError=class extends Error{constructor(e,n,r,s){super(e);x(this,"errors");x(this,"publishedToRelays");x(this,"intendedRelaySet");this.errors=n,this.publishedToRelays=r,this.intendedRelaySet=s}get relayErrors(){const e=[];for(const[n,r]of this.errors)e.push(`${n.url}: ${r}`);return e.join(`
`)}},NDKRelaySet=class ae{constructor(e,n,r){x(this,"relays");x(this,"debug");x(this,"ndk");x(this,"pool");this.relays=e,this.ndk=n,this.pool=r??n.pool,this.debug=n.debug.extend("relayset")}addRelay(e){this.relays.add(e)}get relayUrls(){return Array.from(this.relays).map(e=>e.url)}static fromRelayUrls(e,n,r=!0,s){if(s=s??n.pool,!s)throw new Error("No pool provided");const o=new Set;for(const a of e){const c=s.relays.get(normalizeRelayUrl(a));if(c)c.status<5&&r&&c.connect(),o.add(c);else{const l=new NDKRelay(normalizeRelayUrl(a),n==null?void 0:n.relayAuthDefaultPolicy,n);s.useTemporaryRelay(l,void 0,"requested from fromRelayUrls "+e),o.add(l)}}return new ae(new Set(o),n,s)}async publish(e,n,r=1){const s=new Set,o=new Map,a=e.isEphemeral();e.publishStatus="pending";const c=Array.from(this.relays).map(l=>new Promise(h=>{l.publish(e,n).then(f=>{s.add(l),h()}).catch(f=>{a||o.set(l,f),h()})}));if(await Promise.all(c),s.size<r){if(!a){const l=new NDKPublishError("Not enough relays received the event",o,s,this);throw e.publishStatus="error",e.publishError=l,this.ndk.emit("event:publish-failed",e,l,this.relayUrls),l}}else e.emit("published",{relaySet:this,publishedToRelays:s});return s}get size(){return this.relays.size}},d=debug7("ndk:outbox:calculate");async function calculateRelaySetFromEvent(t,e){var a;const n=new Set,r=await getWriteRelaysFor(t,e.pubkey);r&&r.forEach(c=>{var h;const l=(h=t.pool)==null?void 0:h.getRelay(c);l&&n.add(l)});let s=e.tags.filter(c=>["a","e"].includes(c[0])).map(c=>c[2]).filter(c=>c&&c.startsWith("wss://")).filter(c=>{try{return new URL(c),!0}catch{return!1}}).map(c=>normalizeRelayUrl(c));s=Array.from(new Set(s)).slice(0,5),s.forEach(c=>{var h;const l=(h=t.pool)==null?void 0:h.getRelay(c,!0,!0);l&&(d("Adding relay hint %s",c),n.add(l))});const o=e.getMatchingTags("p").map(c=>c[1]);return o.length<5?Array.from(chooseRelayCombinationForPubkeys(t,o,"read",{preferredRelays:new Set(r)}).keys()).forEach(l=>{var f;const h=(f=t.pool)==null?void 0:f.getRelay(l,!1,!0);h&&(d("Adding p-tagged relay %s",l),n.add(h))}):d("Too many p-tags to consider %d",o.length),(a=t.pool)==null||a.permanentAndConnectedRelays().forEach(c=>n.add(c)),new NDKRelaySet(n,t)}function calculateRelaySetsFromFilter(t,e,n){const r=new Map,s=new Set;if(e.forEach(o=>{o.authors&&o.authors.forEach(a=>s.add(a))}),s.size>0){const o=getRelaysForFilterWithAuthors(t,Array.from(s));for(const a of o.keys())r.set(a,[]);for(const a of e)if(a.authors)for(const[c,l]of o.entries()){const h=a.authors.filter(f=>l.includes(f));r.set(c,[...r.get(c),{...a,authors:h}])}else for(const c of o.keys())r.set(c,[...r.get(c),a])}else t.explicitRelayUrls&&t.explicitRelayUrls.forEach(o=>{r.set(o,e)});return r.size===0&&n.permanentAndConnectedRelays().slice(0,5).forEach(o=>{r.set(o.url,e)}),r}function calculateRelaySetsFromFilters(t,e,n){return calculateRelaySetsFromFilter(t,e,n)}function mergeTags(t,e){const n=new Map,r=a=>a.join(","),s=(a,c)=>a.every((l,h)=>l===c[h]),o=a=>{for(const[c,l]of n)if(s(l,a)||s(a,l)){a.length>=l.length&&n.set(c,a);return}n.set(r(a),a)};return t.concat(e).forEach(o),Array.from(n.values())}async function generateContentTags(t,e=[]){const n=/(@|nostr:)(npub|nprofile|note|nevent|naddr)[a-zA-Z0-9]+/g,r=new RegExp(`(?<=\\s|^)(#[^\\s!@#$%^&*()=+./,[{\\]};:'"?><]+)`,"g"),s=[],o=a=>{e.find(c=>["q",a[0]].includes(c[0])&&c[1]===a[1])||e.push(a)};return t=t.replace(n,a=>{try{const c=a.split(/(@|nostr:)/)[2],{type:l,data:h}=nip19_exports.decode(c);let f;switch(l){case"npub":f=["p",h];break;case"nprofile":f=["p",h.pubkey];break;case"note":s.push(new Promise(async u=>{o(["e",h,await maybeGetEventRelayUrl(c),"mention"]),u()}));break;case"nevent":s.push(new Promise(async u=>{const{id:p,author:g}=h;let{relays:A}=h;(!A||A.length===0)&&(A=[await maybeGetEventRelayUrl(c)]),o(["e",p,A[0],"mention"]),g&&o(["p",g]),u()}));break;case"naddr":s.push(new Promise(async u=>{const p=[h.kind,h.pubkey,h.identifier].join(":");let g=h.relays??[];g.length===0&&(g=[await maybeGetEventRelayUrl(c)]),o(["a",p,g[0],"mention"]),o(["p",h.pubkey]),u()}));break;default:return a}return f&&o(f),`nostr:${c}`}catch{return a}}),await Promise.all(s),t=t.replace(r,(a,c)=>{const l=["t",c.slice(1)];return e.find(h=>h[0]===l[0]&&h[1]===l[1])||e.push(l),a}),{content:t,tags:e}}async function maybeGetEventRelayUrl(t){return""}function isReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return[0,3].includes(this.kind)||this.kind>=1e4&&this.kind<2e4||this.kind>=3e4&&this.kind<4e4}function isEphemeral(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=2e4&&this.kind<3e4}function isParamReplaceable(){if(this.kind===void 0)throw new Error("Kind not set");return this.kind>=3e4&&this.kind<4e4}var DEFAULT_ENCRYPTION_SCHEME="nip04";async function encrypt(t,e,n=DEFAULT_ENCRYPTION_SCHEME){if(!this.ndk)throw new Error("No NDK instance found!");if(e||(await this.ndk.assertSigner(),e=this.ndk.signer),!t){const r=this.getMatchingTags("p");if(r.length!==1)throw new Error("No recipient could be determined and no explicit recipient was provided");t=this.ndk.getUser({pubkey:r[0][1]})}this.content=await(e==null?void 0:e.encrypt(t,this.content,n))}async function decrypt(t,e,n=DEFAULT_ENCRYPTION_SCHEME){if(!this.ndk)throw new Error("No NDK instance found!");e||(await this.ndk.assertSigner(),e=this.ndk.signer),t||(t=this.author),this.content=await(e==null?void 0:e.decrypt(t,this.content,n))}function encode(t=5){let e=[];return this.onRelays.length>0?e=this.onRelays.map(n=>n.url):this.relay&&(e=[this.relay.url]),e.length>t&&(e=e.slice(0,t)),this.isParamReplaceable()?nip19_exports.naddrEncode({kind:this.kind,pubkey:this.pubkey,identifier:this.replaceableDTag(),relays:e}):e.length>0?nip19_exports.neventEncode({id:this.tagId(),relays:e,author:this.pubkey}):nip19_exports.noteEncode(this.tagId())}async function repost(t=!0,e){if(!e&&t){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),e=this.ndk.signer}const n=new NDKEvent(this.ndk,{kind:getKind(this),content:""});return n.tag(this),n.kind===16?n.tags.push(["k",`${this.kind}`]):n.content=JSON.stringify(this.rawEvent()),e&&await n.sign(e),t&&await n.publish(),n}function getKind(t){return t.kind===1?6:16}function eventHasETagMarkers(t){return t.getMatchingTags("e").some(e=>e[3])}function getRootTag(t,e){e??(e=t.tagType());const n=t.tags.find(r=>r[3]==="root");if(!n){if(eventHasETagMarkers(t))return;const r=t.getMatchingTags(e);if(r.length<3)return r[0]}return n}function getReplyTag(t,e){e??(e=t.tagType());let n=t.tags.find(r=>r[3]==="reply");if(n)return n;if(n||(n=t.tags.find(r=>r[3]==="root")),!n){if(eventHasETagMarkers(t))return;const r=t.getMatchingTags(e);if(r.length===1)return r[0];if(r.length===2)return r[1]}}async function fetchTaggedEvent(t,e){if(!this.ndk)throw new Error("NDK instance not found");const n=this.getMatchingTags(t,e);if(n.length===0)return;const[r,s,o]=n[0];return await this.ndk.fetchEvent(s,{},void 0)}async function fetchRootEvent(t){if(!this.ndk)throw new Error("NDK instance not found");const e=getRootTag(this);if(e)return this.ndk.fetchEventFromTag(e,this,t)}async function fetchReplyEvent(t){if(!this.ndk)throw new Error("NDK instance not found");const e=getReplyTag(this);if(e)return this.ndk.fetchEventFromTag(e,this,t)}function serialize(t=!1,e=!1){const n=[0,this.pubkey,this.created_at,this.kind,this.tags,this.content];return t&&n.push(this.sig),e&&n.push(this.id),JSON.stringify(n)}function deserialize(t){const e=JSON.parse(t),n={pubkey:e[1],created_at:e[2],kind:e[3],tags:e[4],content:e[5]};return e.length===7&&(n.sig=e[6]),e.length===8&&(n.id=e[7]),n}var worker,processingQueue={};function signatureVerificationInit(t){worker=t,worker.onmessage=e=>{const[n,r]=e.data,s=processingQueue[n];if(!s){console.error("No record found for event",n);return}delete processingQueue[n];for(const o of s.resolves)o(r)}}async function verifySignatureAsync(t,e){return new Promise(r=>{const s=t.serialize();let o=!1;processingQueue[t.id]||(processingQueue[t.id]={event:t,resolves:[]},o=!0),processingQueue[t.id].resolves.push(r),o&&worker.postMessage({serialized:s,id:t.id,sig:t.sig,pubkey:t.pubkey})})}var PUBKEY_REGEX=/^[a-f0-9]{64}$/;function validate(){if(typeof this.kind!="number"||typeof this.content!="string"||typeof this.created_at!="number"||typeof this.pubkey!="string"||!this.pubkey.match(PUBKEY_REGEX)||!Array.isArray(this.tags))return!1;for(let t=0;t<this.tags.length;t++){const e=this.tags[t];if(!Array.isArray(e))return!1;for(let n=0;n<e.length;n++)if(typeof e[n]=="object")return!1}return!0}var verifiedSignatures=new distExports.LRUCache({maxSize:1e3,entryExpirationTimeInMS:6e4});function verifySignature(t){var n;if(typeof this.signatureVerified=="boolean")return this.signatureVerified;const e=verifiedSignatures.get(this.id);if(e!==null)return this.signatureVerified=!!e;try{if((n=this.ndk)!=null&&n.asyncSigVerification)verifySignatureAsync(this,t).then(r=>{t&&(this.signatureVerified=r,r&&verifiedSignatures.set(this.id,this.sig)),r||(this.ndk.emit("event:invalid-sig",this),verifiedSignatures.set(this.id,!1))});else{const r=sha256$1(new TextEncoder().encode(this.serialize())),s=schnorr.verify(this.sig,r,this.pubkey);return s?verifiedSignatures.set(this.id,this.sig):verifiedSignatures.set(this.id,!1),this.signatureVerified=s}}catch{return this.signatureVerified=!1}}function getEventHash(){return getEventHashFromSerializedEvent(this.serialize())}function getEventHashFromSerializedEvent(t){const e=sha256$1(new TextEncoder().encode(t));return bytesToHex$1(e)}var skipClientTagOnKinds=[3],NDKEvent=class ie extends libExports.EventEmitter{constructor(n,r){var s;super();x(this,"ndk");x(this,"created_at");x(this,"content","");x(this,"tags",[]);x(this,"kind");x(this,"id","");x(this,"sig");x(this,"pubkey","");x(this,"signatureVerified");x(this,"_author");x(this,"relay");x(this,"publishStatus","success");x(this,"publishError");x(this,"serialize",serialize.bind(this));x(this,"getEventHash",getEventHash.bind(this));x(this,"validate",validate.bind(this));x(this,"verifySignature",verifySignature.bind(this));x(this,"isReplaceable",isReplaceable.bind(this));x(this,"isEphemeral",isEphemeral.bind(this));x(this,"isParamReplaceable",isParamReplaceable.bind(this));x(this,"encode",encode.bind(this));x(this,"encrypt",encrypt.bind(this));x(this,"decrypt",decrypt.bind(this));x(this,"fetchTaggedEvent",fetchTaggedEvent.bind(this));x(this,"fetchRootEvent",fetchRootEvent.bind(this));x(this,"fetchReplyEvent",fetchReplyEvent.bind(this));x(this,"repost",repost.bind(this));this.ndk=n,this.created_at=r==null?void 0:r.created_at,this.content=(r==null?void 0:r.content)||"",this.tags=(r==null?void 0:r.tags)||[],this.id=(r==null?void 0:r.id)||"",this.sig=r==null?void 0:r.sig,this.pubkey=(r==null?void 0:r.pubkey)||"",this.kind=r==null?void 0:r.kind,r instanceof ie&&(this.relay&&(this.relay=r.relay,(s=this.ndk)==null||s.subManager.seenEvent(r.id,this.relay)),this.publishStatus=r.publishStatus,this.publishError=r.publishError)}get onRelays(){let n=[];return this.ndk?n=this.ndk.subManager.seenEvents.get(this.id)||[]:this.relay&&n.push(this.relay),n}static deserialize(n,r){return new ie(n,deserialize(r))}rawEvent(){return{created_at:this.created_at,content:this.content,tags:this.tags,kind:this.kind,pubkey:this.pubkey,id:this.id,sig:this.sig}}set author(n){var r;this.pubkey=n.pubkey,this._author=n,(r=this._author).ndk??(r.ndk=this.ndk)}get author(){if(this._author)return this._author;if(!this.ndk)throw new Error("No NDK instance found");const n=this.ndk.getUser({pubkey:this.pubkey});return this._author=n,n}tagExternal(n,r,s){let o=["i"],a=["k"];switch(r){case"url":const c=new URL(n);c.hash="",o.push(c.toString()),a.push(`${c.protocol}//${c.host}`);break;case"hashtag":o.push(`#${n.toLowerCase()}`),a.push("#");break;case"geohash":o.push(`geo:${n.toLowerCase()}`),a.push("geo");break;case"isbn":o.push(`isbn:${n.replace(/-/g,"")}`),a.push("isbn");break;case"podcast:guid":o.push(`podcast:guid:${n}`),a.push("podcast:guid");break;case"podcast:item:guid":o.push(`podcast:item:guid:${n}`),a.push("podcast:item:guid");break;case"podcast:publisher:guid":o.push(`podcast:publisher:guid:${n}`),a.push("podcast:publisher:guid");break;case"isan":o.push(`isan:${n.split("-").slice(0,4).join("-")}`),a.push("isan");break;case"doi":o.push(`doi:${n.toLowerCase()}`),a.push("doi");break;default:throw new Error(`Unsupported NIP-73 entity type: ${r}`)}s&&o.push(s),this.tags.push(o),this.tags.push(a)}tag(n,r,s,o){let a=[];if(n.fetchProfile!==void 0){o??(o="p");const l=[o,n.pubkey];r&&l.push("",r),a.push(l)}else if(n instanceof ie){const l=n;s??(s=(l==null?void 0:l.pubkey)===this.pubkey),a=l.referenceTags(r,s,o);for(const h of l.getMatchingTags("p"))h[1]!==this.pubkey&&(this.tags.find(f=>f[0]==="p"&&f[1]===h[1])||this.tags.push(["p",h[1]]))}else if(Array.isArray(n))a=[n];else throw new Error("Invalid argument",n);this.tags=mergeTags(this.tags,a)}async toNostrEvent(n){var o,a;if(!n&&this.pubkey===""){const c=await((a=(o=this.ndk)==null?void 0:o.signer)==null?void 0:a.user());this.pubkey=(c==null?void 0:c.pubkey)||""}this.created_at||(this.created_at=Math.floor(Date.now()/1e3));const{content:r,tags:s}=await this.generateTags();this.content=r||"",this.tags=s;try{this.id=this.getEventHash()}catch{}return this.rawEvent()}getMatchingTags(n,r){const s=this.tags.filter(o=>o[0]===n);return r===void 0?s:s.filter(o=>o[3]===r)}hasTag(n,r){return this.tags.some(s=>s[0]===n&&(!r||s[3]===r))}tagValue(n){const r=this.getMatchingTags(n);if(r.length!==0)return r[0][1]}get alt(){return this.tagValue("alt")}set alt(n){this.removeTag("alt"),n&&this.tags.push(["alt",n])}get dTag(){return this.tagValue("d")}set dTag(n){this.removeTag("d"),n&&this.tags.push(["d",n])}removeTag(n){const r=Array.isArray(n)?n:[n];this.tags=this.tags.filter(s=>!r.includes(s[0]))}async sign(n){var s;n?this.author=await n.user():((s=this.ndk)==null||s.assertSigner(),n=this.ndk.signer);const r=await this.toNostrEvent();return this.sig=await n.sign(r),this.sig}async publishReplaceable(n,r,s){return this.id="",this.created_at=Math.floor(Date.now()/1e3),this.sig="",this.publish(n,r,s)}async publish(n,r,s){var c,l;if(this.sig||await this.sign(),!this.ndk)throw new Error("NDKEvent must be associated with an NDK instance to publish");n||(n=this.ndk.devWriteRelaySet||await calculateRelaySetFromEvent(this.ndk,this)),this.kind===5&&((c=this.ndk.cacheAdapter)!=null&&c.deleteEvent)&&this.ndk.cacheAdapter.deleteEvent(this);const o=this.rawEvent();if((l=this.ndk.cacheAdapter)!=null&&l.addUnpublishedEvent)try{this.ndk.cacheAdapter.addUnpublishedEvent(this,n.relayUrls)}catch(h){console.error("Error adding unpublished event to cache",h)}this.ndk.subManager.subscriptions.forEach(h=>{h.filters.some(f=>matchFilter(f,o))&&h.eventReceived(this,void 0,!1,!0)});const a=await n.publish(this,r,s);return a.forEach(h=>{var f;return(f=this.ndk)==null?void 0:f.subManager.seenEvent(this.id,h)}),a}async generateTags(){var o,a;let n=[];const r=await generateContentTags(this.content,this.tags),s=r.content;if(n=r.tags,this.kind&&this.isParamReplaceable()&&!this.getMatchingTags("d")[0]){const l=this.tagValue("title");let f=[...Array(l?6:16)].map(()=>Math.random().toString(36)[2]).join("");l&&l.length>0&&(f=l.replace(/[^a-z0-9]+/gi,"-").replace(/^-|-$/g,"")+"-"+f),n.push(["d",f])}if(((o=this.ndk)!=null&&o.clientName||(a=this.ndk)!=null&&a.clientNip89)&&skipClientTagOnKinds.includes(this.kind)&&!this.tags.some(c=>c[0]==="client")){const c=["client",this.ndk.clientName??""];this.ndk.clientNip89&&c.push(this.ndk.clientNip89),n.push(c)}return{content:s||"",tags:n}}muted(){var o,a;const n=(o=this.ndk)==null?void 0:o.mutedIds.get(this.pubkey);if(n&&n==="p")return"author";const r=this.tagReference(),s=(a=this.ndk)==null?void 0:a.mutedIds.get(r[1]);return s&&s===r[0]?"event":null}replaceableDTag(){if(this.kind&&this.kind>=3e4&&this.kind<=4e4){const n=this.getMatchingTags("d")[0];return n?n[1]:""}throw new Error("Event is not a parameterized replaceable event")}deduplicationKey(){return this.kind===0||this.kind===3||this.kind&&this.kind>=1e4&&this.kind<2e4?`${this.kind}:${this.pubkey}`:this.tagId()}tagId(){return this.isParamReplaceable()?this.tagAddress():this.id}tagAddress(){if(!this.isParamReplaceable())throw new Error("This must only be called on replaceable events");const n=this.replaceableDTag();return`${this.kind}:${this.pubkey}:${n}`}tagType(){return this.isParamReplaceable()?"a":"e"}tagReference(n){let r;return this.isParamReplaceable()?r=["a",this.tagAddress()]:r=["e",this.tagId()],this.relay?r.push(this.relay.url):r.push(""),n&&r.push(n),r}referenceTags(n,r,s){var a;let o=[];return this.isParamReplaceable()?o=[[s??"a",this.tagAddress()],[s??"e",this.id]]:o=[[s??"e",this.id]],(a=this.relay)!=null&&a.url?o=o.map(c=>{var l;return c.push((l=this.relay)==null?void 0:l.url),c}):n&&(o=o.map(c=>(c.push(""),c))),n&&o.forEach(c=>c.push(n)),o=[...o,...this.getMatchingTags("h")],r||o.push(...this.author.referenceTags()),o}filter(){return this.isParamReplaceable()?{"#a":[this.tagId()]}:{"#e":[this.tagId()]}}async delete(n,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new ie(this.ndk,{kind:5,content:n||""});return s.tag(this,void 0,!0),s.tags.push(["k",this.kind.toString()]),r&&await s.publish(),s}async react(n,r=!0){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner();const s=new ie(this.ndk,{kind:7,content:n});return s.tag(this),r?await s.publish():await s.sign(),s}get isValid(){return this.validate()}};function queryFullyFilled(t){return!!(filterIncludesIds(t.filter)&&resultHasAllRequestedIds(t))}function filterIncludesIds(t){return!!t.ids}function resultHasAllRequestedIds(t){const e=t.filter.ids;return!!e&&e.length===t.eventFirstSeen.size}function filterFromId(t){let e;if(t.match(NIP33_A_REGEX)){const[n,r,s]=t.split(":"),o={authors:[r],kinds:[parseInt(n)]};return s&&(o["#d"]=[s]),o}if(t.match(BECH32_REGEX))try{switch(e=nip19_exports.decode(t),e.type){case"nevent":{const r={ids:[e.data.id]};return e.data.author&&(r.authors=[e.data.author]),e.data.kind&&(r.kinds=[e.data.kind]),r}case"note":return{ids:[e.data]};case"naddr":const n={authors:[e.data.pubkey],kinds:[e.data.kind]};return e.data.identifier&&(n["#d"]=[e.data.identifier]),n}}catch(n){console.error("Error decoding",t,n)}return{ids:[t]}}function isNip33AValue(t){return t.match(NIP33_A_REGEX)!==null}var NIP33_A_REGEX=/^(\d+):([0-9A-Fa-f]+)(?::(.*))?$/,BECH32_REGEX=/^n(event|ote|profile|pub|addr)1[\d\w]+$/;function relaysFromBech32(t,e){try{const n=nip19_exports.decode(t);if(["naddr","nevent"].includes(n==null?void 0:n.type)){const r=n.data;if(r!=null&&r.relays)return r.relays.map(s=>new NDKRelay(s,e==null?void 0:e.relayAuthDefaultPolicy,e))}}catch{}return[]}var defaultOpts={closeOnEose:!1,cacheUsage:"CACHE_FIRST",groupable:!0,groupableDelay:100,groupableDelayType:"at-most"},NDKSubscription=class extends libExports.EventEmitter{constructor(e,n,r,s,o){super();x(this,"subId");x(this,"filters");x(this,"opts");x(this,"pool");x(this,"skipVerification",!1);x(this,"skipValidation",!1);x(this,"relayFilters");x(this,"relaySet");x(this,"ndk");x(this,"debug");x(this,"eventFirstSeen",new Map);x(this,"eosesSeen",new Set);x(this,"lastEventReceivedAt");x(this,"internalId");x(this,"closeOnEose");x(this,"poolMonitor");x(this,"skipOptimisticPublishEvent",!1);x(this,"eoseTimeout");x(this,"eosed",!1);if(this.ndk=e,this.pool=(r==null?void 0:r.pool)||e.pool,this.opts={...defaultOpts,...r||{}},this.filters=n instanceof Array?n:[n],this.subId=o||(r==null?void 0:r.subId),this.internalId=Math.random().toString(36).substring(7),this.relaySet=s,this.debug=e.debug.extend(`subscription[${(r==null?void 0:r.subId)??this.internalId}]`),this.skipVerification=(r==null?void 0:r.skipVerification)||!1,this.skipValidation=(r==null?void 0:r.skipValidation)||!1,this.closeOnEose=(r==null?void 0:r.closeOnEose)||!1,this.skipOptimisticPublishEvent=(r==null?void 0:r.skipOptimisticPublishEvent)||!1,this.opts.cacheUsage==="ONLY_CACHE"&&!this.opts.closeOnEose)throw new Error("Cannot use cache-only options with a persistent subscription")}relaysMissingEose(){return this.relayFilters?Array.from(this.relayFilters.keys()).filter(n=>!this.eosesSeen.has(this.pool.getRelay(n,!1,!1))):[]}get filter(){return this.filters[0]}get groupableDelay(){var e;if(this.isGroupable())return(e=this.opts)==null?void 0:e.groupableDelay}get groupableDelayType(){var e;return((e=this.opts)==null?void 0:e.groupableDelayType)||"at-most"}isGroupable(){var e;return((e=this.opts)==null?void 0:e.groupable)||!1}shouldQueryCache(){var e;return((e=this.opts)==null?void 0:e.cacheUsage)!=="ONLY_RELAY"}shouldQueryRelays(){var e;return((e=this.opts)==null?void 0:e.cacheUsage)!=="ONLY_CACHE"}shouldWaitForCache(){var e;return this.opts.closeOnEose&&!!((e=this.ndk.cacheAdapter)!=null&&e.locking)&&this.opts.cacheUsage!=="PARALLEL"}async start(){let e;if(this.shouldQueryCache()&&(e=this.startWithCache(),this.shouldWaitForCache()&&(await e,queryFullyFilled(this)))){this.emit("eose",this);return}this.shouldQueryRelays()?(this.startWithRelays(),this.startPoolMonitor()):this.emit("eose",this)}startPoolMonitor(){this.debug.extend("pool-monitor"),this.poolMonitor=e=>{var r,s;if((r=this.relayFilters)!=null&&r.has(e.url))return;calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool).get(e.url)&&((s=this.relayFilters)==null||s.set(e.url,this.filters),e.subscribe(this,this.filters))},this.pool.on("relay:connect",this.poolMonitor)}stop(){this.emit("close",this),this.poolMonitor&&this.pool.off("relay:connect",this.poolMonitor),this.removeAllListeners()}hasAuthorsFilter(){return this.filters.some(e=>{var n;return(n=e.authors)==null?void 0:n.length})}async startWithCache(){var e;if((e=this.ndk.cacheAdapter)!=null&&e.query){const n=this.ndk.cacheAdapter.query(this);this.ndk.cacheAdapter.locking&&await n}}startWithRelays(){if(!this.relaySet||this.relaySet.relays.size===0)this.relayFilters=calculateRelaySetsFromFilters(this.ndk,this.filters,this.pool);else{this.relayFilters=new Map;for(const e of this.relaySet.relays)this.relayFilters.set(e.url,this.filters)}if(!(!this.relayFilters||this.relayFilters.size===0))for(const[e,n]of this.relayFilters)this.pool.getRelay(e,!0,!0,n).subscribe(this,n)}eventReceived(e,n,r=!1,s=!1){const o=e.id,a=this.eventFirstSeen.has(o);let c;if(e instanceof NDKEvent&&(c=e),a){const l=Date.now()-(this.eventFirstSeen.get(o)||0);if(this.emit("event:dup",o,n,l,this),n){const h=verifiedSignatures.get(o);h&&typeof h=="string"&&e.sig===h&&n.addValidatedEvent()}}else{if(c??(c=new NDKEvent(this.ndk,e)),c.ndk=this.ndk,c.relay=n,!r&&!s){if(!this.skipValidation&&!c.isValid){this.debug("Event failed validation %s from relay %s",o,n==null?void 0:n.url);return}if(n)if((n==null?void 0:n.shouldValidateEvent())!==!1){if(!this.skipVerification)if(!c.verifySignature(!0)&&!this.ndk.asyncSigVerification){this.debug("Event failed signature validation",e);return}else n&&n.addValidatedEvent()}else n.addNonValidatedEvent();this.ndk.cacheAdapter&&this.ndk.cacheAdapter.setEvent(c,this.filters,n)}!r&&n&&this.ndk.emit("event",c,n),(!s||this.skipOptimisticPublishEvent!==!0)&&(this.emit("event",c,n,this),this.eventFirstSeen.set(o,Date.now()))}this.lastEventReceivedAt=Date.now()}closedReceived(e,n){this.emit("closed",e,n)}eoseReceived(e){var a;this.debug("EOSE received from %s",e.url),this.eosesSeen.add(e);let n=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0;const r=this.eosesSeen.size===((a=this.relayFilters)==null?void 0:a.size),s=queryFullyFilled(this),o=c=>{var l;this.debug("Performing EOSE: %s %d",c,this.eosed),!this.eosed&&(this.eoseTimeout&&clearTimeout(this.eoseTimeout),this.emit("eose",this),this.eosed=!0,(l=this.opts)!=null&&l.closeOnEose&&this.stop())};if(s||r)o("query filled or seen all");else if(this.relayFilters){let c=1e3;const l=new Set(this.pool.connectedRelays().map(u=>u.url)),h=Array.from(this.relayFilters.keys()).filter(u=>l.has(u));if(h.length===0)return;const f=this.eosesSeen.size/h.length;if(this.eosesSeen.size>=2&&f>=.5){if(c=c*(1-f),c===0){o("tiem to wait was 0");return}this.eoseTimeout&&clearTimeout(this.eoseTimeout);const u=()=>{n=this.lastEventReceivedAt?Date.now()-this.lastEventReceivedAt:void 0,n!==void 0&&n<20?this.eoseTimeout=setTimeout(u,c):o("send eose timeout: "+c)};this.eoseTimeout=setTimeout(u,c)}}}};async function follows(t,e,n=3){var s,o;if(!this.ndk)throw new Error("NDK not set");const r=await this.ndk.fetchEvent({kinds:[n],authors:[this.pubkey]},t||{groupable:!1});if(r){const a=new Set;return r.tags.forEach(c=>{c[0]==="p"&&a.add(c[1])}),e&&((o=(s=this.ndk)==null?void 0:s.outboxTracker)==null||o.trackUsers(Array.from(a))),[...a].reduce((c,l)=>{const h=new NDKUser({pubkey:l});return h.ndk=this.ndk,c.add(h),c},new Set)}return new Set}function profileFromEvent(t){const e={};let n;try{n=JSON.parse(t.content)}catch(r){throw new Error(`Failed to parse profile event: ${r}`)}return e.created_at=t.created_at,e.profileEvent=JSON.stringify(t.rawEvent()),Object.keys(n).forEach(r=>{switch(r){case"name":e.name=n.name;break;case"display_name":e.displayName=n.display_name;break;case"image":case"picture":e.image=n.picture||n.image;break;case"banner":e.banner=n.banner;break;case"bio":e.bio=n.bio;break;case"nip05":e.nip05=n.nip05;break;case"lud06":e.lud06=n.lud06;break;case"lud16":e.lud16=n.lud16;break;case"about":e.about=n.about;break;case"zapService":e.zapService=n.zapService;break;case"website":e.website=n.website;break;default:e[r]=n[r];break}}),e}function serializeProfile(t){const e={};for(const[n,r]of Object.entries(t))switch(n){case"username":case"name":e.name=r;break;case"displayName":e.display_name=r;break;case"image":case"picture":e.picture=r;break;case"bio":case"about":e.about=r;break;default:e[n]=r;break}return JSON.stringify(e)}var NIP05_REGEX=/^(?:([\w.+-]+)@)?([\w.-]+)$/;async function getNip05For(t,e,n=fetch,r={}){return await t.queuesNip05.add({id:e,func:async()=>{if(t.cacheAdapter&&t.cacheAdapter.loadNip05){const l=await t.cacheAdapter.loadNip05(e);if(l!=="missing"){if(l){const h=new NDKUser({pubkey:l.pubkey,relayUrls:l.relays,nip46Urls:l.nip46});return h.ndk=t,h}else if(r.cache!=="no-cache")return null}}const s=e.match(NIP05_REGEX);if(!s)return null;const[o,a="_",c]=s;try{const l=await n(`https://${c}/.well-known/nostr.json?name=${a}`,r),{names:h,relays:f,nip46:u}=parseNIP05Result(await l.json()),p=h[a.toLowerCase()];let g=null;return p&&(g={pubkey:p,relays:f==null?void 0:f[p],nip46:u==null?void 0:u[p]}),t!=null&&t.cacheAdapter&&t.cacheAdapter.saveNip05&&t.cacheAdapter.saveNip05(e,g),g}catch(l){return t!=null&&t.cacheAdapter&&t.cacheAdapter.saveNip05&&(t==null||t.cacheAdapter.saveNip05(e,null)),console.error("Failed to fetch NIP05 for",e,l),null}}})}function parseNIP05Result(t){const e={names:{}};for(const[n,r]of Object.entries(t.names))typeof n=="string"&&typeof r=="string"&&(e.names[n.toLowerCase()]=r);if(t.relays){e.relays={};for(const[n,r]of Object.entries(t.relays))typeof n=="string"&&Array.isArray(r)&&(e.relays[n]=r.filter(s=>typeof s=="string"))}if(t.nip46){e.nip46={};for(const[n,r]of Object.entries(t.nip46))typeof n=="string"&&Array.isArray(r)&&(e.nip46[n]=r.filter(s=>typeof s=="string"))}return e}var ne,NDKCashuMintList=(ne=class extends NDKEvent{constructor(n,r){super(n,r);x(this,"_p2pk");this.kind??(this.kind=10019)}static from(n){return new ne(n.ndk,n)}set relays(n){this.tags=this.tags.filter(r=>r[0]!=="relay");for(const r of n)this.tags.push(["relay",r])}get relays(){const n=[];for(const r of this.tags)r[0]==="relay"&&n.push(r[1]);return n}set mints(n){this.tags=this.tags.filter(r=>r[0]!=="mint");for(const r of n)this.tags.push(["mint",r])}get mints(){const n=[];for(const r of this.tags)r[0]==="mint"&&n.push(r[1]);return Array.from(new Set(n))}get p2pk(){return this._p2pk?this._p2pk:(this._p2pk=this.tagValue("pubkey")??this.pubkey,this._p2pk)}set p2pk(n){this._p2pk=n,this.removeTag("pubkey"),n&&this.tags.push(["pubkey",n])}get relaySet(){return NDKRelaySet.fromRelayUrls(this.relays,this.ndk)}},x(ne,"kind",10019),x(ne,"kinds",[10019]),ne),d2=debug7("ndk:zapper:ln");async function getNip57ZapSpecFromLud({lud06:t,lud16:e},n){let r;if(e&&!e.startsWith("LNURL")){const[s,o]=e.split("@");r=`https://${o}/.well-known/lnurlp/${s}`}else if(t){const{words:s}=bech32.decode(t,1e3),o=bech32.fromWords(s);r=new TextDecoder("utf-8").decode(o)}if(!r)throw d2("No zap endpoint found %o",{lud06:t,lud16:e}),new Error("No zap endpoint found");try{const o=await(n.httpFetch||fetch)(r);if(o.status!==200){const a=await o.text();throw new Error(`Unable to fetch zap endpoint ${r}: ${a}`)}return await o.json()}catch(s){throw new Error(`Unable to fetch zap endpoint ${r}: ${s}`)}}var NDKUser=class ce{constructor(e){x(this,"ndk");x(this,"profile");x(this,"_npub");x(this,"_pubkey");x(this,"relayUrls",[]);x(this,"nip46Urls",[]);x(this,"follows",follows.bind(this));e.npub&&(this._npub=e.npub),e.hexpubkey&&(this._pubkey=e.hexpubkey),e.pubkey&&(this._pubkey=e.pubkey),e.relayUrls&&(this.relayUrls=e.relayUrls),e.nip46Urls&&(this.nip46Urls=e.nip46Urls)}get npub(){if(!this._npub){if(!this._pubkey)throw new Error("pubkey not set");this._npub=nip19_exports.npubEncode(this.pubkey)}return this._npub}set npub(e){this._npub=e}get hexpubkey(){return this.pubkey}set hexpubkey(e){this._pubkey=e}get pubkey(){if(!this._pubkey){if(!this._npub)throw new Error("npub not set");this._pubkey=nip19_exports.decode(this.npub).data}return this._pubkey}set pubkey(e){this._pubkey=e}async getZapInfo(e=!0,n=["nip61","nip57"]){if(!this.ndk)throw new Error("No NDK instance found");const r=[];if(n.includes("nip61")&&r.push(10019),n.includes("nip57")&&r.push(0),r.length===0)return[];let s=await this.ndk.fetchEvents({kinds:r,authors:[this.pubkey]},{cacheUsage:"ONLY_CACHE",groupable:!1});s.size<n.length&&(s=await this.ndk.fetchEvents({kinds:r,authors:[this.pubkey]},{cacheUsage:"ONLY_RELAY"}));const o=[],a=Array.from(s).find(l=>l.kind===10019),c=Array.from(s).find(l=>l.kind===0);if(a){const l=NDKCashuMintList.from(a);if(l.mints.length>0&&o.push({type:"nip61",data:{mints:l.mints,relays:l.relays,p2pk:l.p2pk}}),!e)return o}if(c){const l=profileFromEvent(c),{lud06:h,lud16:f}=l;try{const u=await getNip57ZapSpecFromLud({lud06:h,lud16:f},this.ndk);u&&o.push({type:"nip57",data:u})}catch(u){console.error("Error getting NIP-57 zap spec",u)}}return o}async getZapConfiguration(e){if(e??(e=this.ndk),!e)throw new Error("No NDK instance found");const n=async()=>{var s,o,a,c;if((o=(s=this.ndk)==null?void 0:s.cacheAdapter)!=null&&o.loadUsersLNURLDoc){const l=await this.ndk.cacheAdapter.loadUsersLNURLDoc(this.pubkey);if(l!=="missing"){if(l===null)return;if(l)return l}}let r;try{if(await this.fetchProfile({groupable:!1}),this.profile){const{lud06:l,lud16:h}=this.profile;r=await getNip57ZapSpecFromLud({lud06:l,lud16:h},e)}}catch{}if((c=(a=this.ndk)==null?void 0:a.cacheAdapter)!=null&&c.saveUsersLNURLDoc&&this.ndk.cacheAdapter.saveUsersLNURLDoc(this.pubkey,r||null),!!r)return r};return await e.queuesZapConfig.add({id:this.pubkey,func:n})}async getZapperPubkey(){const e=await this.getZapConfiguration();return e==null?void 0:e.nostrPubkey}static async fromNip05(e,n,r=!1){if(!n)throw new Error("No NDK instance found");const s={};r&&(s.cache="no-cache");const o=await getNip05For(n,e,n==null?void 0:n.httpFetch,s);if(o){const a=new ce({pubkey:o.pubkey,relayUrls:o.relays,nip46Urls:o.nip46});return a.ndk=n,a}}async fetchProfile(e,n=!1){if(!this.ndk)throw new Error("NDK not set");this.profile||(this.profile={});let r=null;if(this.ndk.cacheAdapter&&this.ndk.cacheAdapter.fetchProfile&&(e==null?void 0:e.cacheUsage)!=="ONLY_RELAY"){const a=await this.ndk.cacheAdapter.fetchProfile(this.pubkey);if(a)return this.profile=a,a}!e&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.locking&&(r=await this.ndk.fetchEvents({kinds:[0],authors:[this.pubkey]},{cacheUsage:"ONLY_CACHE",closeOnEose:!0,groupable:!1}),e={cacheUsage:"ONLY_RELAY",closeOnEose:!0,groupable:!0,groupableDelay:250}),(!r||r.size===0)&&(r=await this.ndk.fetchEvents({kinds:[0],authors:[this.pubkey]},e));const s=Array.from(r).sort((a,c)=>a.created_at-c.created_at);if(s.length===0)return null;const o=s[0];return this.profile=profileFromEvent(o),n&&(this.profile.profileEvent=JSON.stringify(o)),this.profile&&this.ndk.cacheAdapter&&this.ndk.cacheAdapter.saveProfile&&this.ndk.cacheAdapter.saveProfile(this.pubkey,this.profile),this.profile}tagReference(){return["p",this.pubkey]}referenceTags(e){const n=[["p",this.pubkey]];return e&&n[0].push("",e),n}async publish(){if(!this.ndk)throw new Error("No NDK instance found");if(!this.profile)throw new Error("No profile available");this.ndk.assertSigner(),await new NDKEvent(this.ndk,{kind:0,content:serializeProfile(this.profile)}).publish()}async follow(e,n,r=3){if(!this.ndk)throw new Error("No NDK instance found");if(this.ndk.assertSigner(),n||(n=await this.follows(void 0,void 0,r)),n.has(e))return!1;n.add(e);const s=new NDKEvent(this.ndk,{kind:r});for(const o of n)s.tag(o);return await s.publish(),!0}async unfollow(e,n,r=3){if(!this.ndk)throw new Error("No NDK instance found");this.ndk.assertSigner(),n||(n=await this.follows(void 0,void 0,r));const s=new Set;let o=!1;for(const c of n)c.pubkey!==e.pubkey?s.add(c):o=!0;if(!o)return!1;const a=new NDKEvent(this.ndk,{kind:r});for(const c of s)a.tag(c);return await a.publish()}async validateNip05(e){if(!this.ndk)throw new Error("No NDK instance found");const n=await getNip05For(this.ndk,e);return n===null?null:n.pubkey===this.pubkey}async zap(e,n,r,s){return new Promise((o,a)=>{var h;if(!this.ndk){a("No NDK instance found");return}let c=(h=this.ndk.walletConfig)==null?void 0:h.onLnPay;c??(c=async({pr:f})=>{o(f)}),this.ndk.zap(this,e,{comment:n,tags:r,signer:s,onLnPay:c}).zap().then(o).catch(a)})}},NDKList=class le extends NDKEvent{constructor(n,r){super(n,r);x(this,"_encryptedTags");x(this,"encryptedTagsLength");this.kind??(this.kind=30001)}static from(n){return new le(n.ndk,n)}get title(){const n=this.tagValue("title")||this.tagValue("name");return n||(this.kind===3?"Contacts":this.kind===1e4?"Mute":this.kind===10001?"Pinned Notes":this.kind===10002?"Relay Metadata":this.kind===10003?"Bookmarks":this.kind===10004?"Communities":this.kind===10005?"Public Chats":this.kind===10006?"Blocked Relays":this.kind===10007?"Search Relays":this.kind===10050?"Direct Message Receive Relays":this.kind===10015?"Interests":this.kind===10030?"Emojis":this.tagValue("d"))}set title(n){this.removeTag(["title","name"]),n&&this.tags.push(["title",n])}get name(){return this.title}set name(n){this.title=n}get description(){return this.tagValue("description")}set description(n){this.removeTag("description"),n&&this.tags.push(["description",n])}get image(){return this.tagValue("image")}set image(n){this.removeTag("image"),n&&this.tags.push(["image",n])}isEncryptedTagsCacheValid(){return!!(this._encryptedTags&&this.encryptedTagsLength===this.content.length)}async encryptedTags(n=!0){if(n&&this.isEncryptedTagsCacheValid())return this._encryptedTags;if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const r=await this.ndk.signer.user();try{if(this.content.length>0)try{const s=await this.ndk.signer.decrypt(r,this.content),o=JSON.parse(s);return o&&o[0]?(this.encryptedTagsLength=this.content.length,this._encryptedTags=o):(this.encryptedTagsLength=this.content.length,this._encryptedTags=[])}catch{console.log(`error decrypting ${this.content}`)}}catch{}return[]}validateTag(n){return!0}getItems(n){return this.tags.filter(r=>r[0]===n)}get items(){return this.tags.filter(n=>!["d","L","l","title","name","description","published_at","summary","image","thumb","alt","expiration","subject","client"].includes(n[0]))}async addItem(n,r=void 0,s=!1,o="bottom"){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");let a;if(n instanceof NDKEvent)a=[n.tagReference(r)];else if(n instanceof NDKUser)a=n.referenceTags();else if(n instanceof NDKRelay)a=n.referenceTags();else if(Array.isArray(n))a=[n];else throw new Error("Invalid object type");if(r&&a[0].push(r),s){const c=await this.ndk.signer.user(),l=await this.encryptedTags();o==="top"?l.unshift(...a):l.push(...a),this._encryptedTags=l,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(l),await this.encrypt(c)}else o==="top"?this.tags.unshift(...a):this.tags.push(...a);this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItemByValue(n,r=!0){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");const s=this.tags.findIndex(l=>l[1]===n);s>=0&&this.tags.splice(s,1);const o=await this.ndk.signer.user(),a=await this.encryptedTags(),c=a.findIndex(l=>l[1]===n);if(c>=0&&(a.splice(c,1),this._encryptedTags=a,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(a),await this.encrypt(o)),r)return this.publishReplaceable();this.created_at=Math.floor(Date.now()/1e3),this.emit("change")}async removeItem(n,r){if(!this.ndk)throw new Error("NDK instance not set");if(!this.ndk.signer)throw new Error("NDK signer not set");if(r){const s=await this.ndk.signer.user(),o=await this.encryptedTags();o.splice(n,1),this._encryptedTags=o,this.encryptedTagsLength=this.content.length,this.content=JSON.stringify(o),await this.encrypt(s)}else this.tags.splice(n,1);return this.created_at=Math.floor(Date.now()/1e3),this.emit("change"),this}has(n){return this.items.some(r=>r[1]===n)}filterForItems(){const n=new Set,r=new Map,s=[];for(const o of this.items)if(o[0]==="e"&&o[1])n.add(o[1]);else if(o[0]==="a"&&o[1]){const[a,c,l]=o[1].split(":");if(!a||!c)continue;const h=`${a}:${c}`,f=r.get(h)||[];f.push(l||""),r.set(h,f)}if(n.size>0&&s.push({ids:Array.from(n)}),r.size>0)for(const[o,a]of r.entries()){const[c,l]=o.split(":");s.push({kinds:[parseInt(c)],authors:[l],"#d":a})}return s}},lists_default=NDKList,READ_MARKER="read",WRITE_MARKER="write",NDKRelayList=class ue extends NDKEvent{constructor(e,n){super(e,n),this.kind??(this.kind=10002)}static from(e){return new ue(e.ndk,e.rawEvent())}get readRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]||e[2]&&e[2]===READ_MARKER).map(e=>tryNormalizeRelayUrl(e[1])).filter(e=>!!e)}set readRelayUrls(e){for(const n of e)this.tags.push(["r",n,READ_MARKER])}get writeRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]||e[2]&&e[2]===WRITE_MARKER).map(e=>tryNormalizeRelayUrl(e[1])).filter(e=>!!e)}set writeRelayUrls(e){for(const n of e)this.tags.push(["r",n,WRITE_MARKER])}get bothRelayUrls(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").filter(e=>!e[2]).map(e=>e[1])}set bothRelayUrls(e){for(const n of e)this.tags.push(["r",n])}get relays(){return this.tags.filter(e=>e[0]==="r"||e[0]==="relay").map(e=>e[1])}get relaySet(){if(!this.ndk)throw new Error("NDKRelayList has no NDK instance");return new NDKRelaySet(new Set(this.relays.map(e=>this.ndk.pool.getRelay(e))),this.ndk)}};function relayListFromKind3(t,e){try{const n=JSON.parse(e.content),r=new NDKRelayList(t),s=new Set,o=new Set;for(let[a,c]of Object.entries(n)){try{a=normalizeRelayUrl(a)}catch{continue}if(!c)s.add(a),o.add(a);else{const l=c;l.write&&o.add(a),l.read&&s.add(a)}}return r.readRelayUrls=Array.from(s),r.writeRelayUrls=Array.from(o),r}catch{}}var re,NDKNutzap=(re=class extends NDKEvent{constructor(n,r){super(n,r);x(this,"debug");x(this,"_proofs",[]);x(this,"sender",this.author);this.kind??(this.kind=9321),this.debug=(n==null?void 0:n.debug.extend("nutzap"))??debug7("ndk:nutzap"),this.alt||(this.alt="This is a nutzap")}static from(n){const r=new this(n.ndk,n);try{const s=r.getMatchingTags("proof");s.length?r._proofs=s.map(o=>JSON.parse(o[1])):r._proofs=JSON.parse(r.content)}catch{return}if(!(!r._proofs||!r._proofs.length))return r}set comment(n){this.content=n??""}get comment(){const n=this.tagValue("comment");return n||this.content}set proofs(n){this._proofs=n,this.tags=this.tags.filter(r=>r[0]!=="proof");for(const r of n)this.tags.push(["proof",JSON.stringify(r)]);this.removeTag("amount"),this.tags.push(["amount",this.amount.toString()])}get proofs(){return this._proofs}get p2pk(){var r;const n=this.proofs[0];try{const s=JSON.parse(n.secret);let o={};if(typeof s=="string"?(o=JSON.parse(s),this.debug("stringified payload",n.secret)):typeof s=="object"&&(o=s),o[0]==="P2PK"&&((r=o[1])==null?void 0:r.data)){const l=o[1].data.slice(2,-1);if(l)return l}}catch(s){this.debug("error parsing p2pk pubkey",s,this.proofs[0])}}get mint(){return this.tagValue("u")}set mint(n){this.removeTag("u"),this.tag(["u",n])}get unit(){return this.tagValue("unit")??"msat"}set unit(n){this.removeTag("unit"),n&&this.tag(["unit",n])}get amount(){return this.proofs.reduce((r,s)=>r+s.amount,0)*1e3}set target(n){this.tags=this.tags.filter(r=>r[0]!=="p"),n instanceof NDKEvent&&this.tags.push()}set recipientPubkey(n){this.removeTag("p"),this.tag(["p",n])}get recipientPubkey(){return this.tagValue("p")}get recipient(){const n=this.recipientPubkey;return this.ndk?this.ndk.getUser({pubkey:n}):new NDKUser({pubkey:n})}get isValid(){let n=0,r=0;for(const s of this.tags)s[0]==="p"&&n++,s[0]==="u"&&r++;return n===1&&r===1&&this.proofs.length>0}},x(re,"kind",9321),x(re,"kinds",[re.kind]),re);async function payInvoice(t){return await this.sendReq("pay_invoice",{invoice:t})}var NDKPrivateKeySigner=class he{constructor(e){x(this,"_user");x(this,"_privateKey");if(e){if(typeof e=="string")if(e.startsWith("nsec1")){const{type:n,data:r}=nip19_exports.decode(e);n==="nsec"&&(this._privateKey=r)}else if(e.length===64)this._privateKey=hexToBytes$1(e);else throw new Error("Invalid private key provided.");else this._privateKey=e;this._privateKey&&(this._user=new NDKUser({pubkey:getPublicKey(this._privateKey)}))}}get privateKey(){if(this._privateKey)return bytesToHex$1(this._privateKey)}static generate(){const e=generateSecretKey();return new he(e)}async blockUntilReady(){if(!this._user)throw new Error("NDKUser not initialized");return this._user}async user(){return await this.blockUntilReady(),this._user}async sign(e){if(!this._privateKey)throw Error("Attempted to sign without a private key");return finalizeEvent(e,this._privateKey).sig}getConversationKey(e){if(!this._privateKey)throw Error("Attempted to get conversation key without a private key");const n=e.pubkey;return nip44_exports.getConversationKey(this._privateKey,n)}async nip44Encrypt(e,n){const r=this.getConversationKey(e);return await nip44_exports.encrypt(n,r)}async nip44Decrypt(e,n){const r=this.getConversationKey(e);return await nip44_exports.decrypt(n,r)}async encrypt(e,n,r=DEFAULT_ENCRYPTION_SCHEME){return r==="nip44"?this.nip44Encrypt(e,n):this.nip04Encrypt(e,n)}async decrypt(e,n,r=DEFAULT_ENCRYPTION_SCHEME){return r==="nip44"?this.nip44Decrypt(e,n):this.nip04Decrypt(e,n)}async nip04Encrypt(e,n){if(!this._privateKey)throw Error("Attempted to encrypt without a private key");const r=e.pubkey;return await nip04_exports.encrypt(this._privateKey,r,n)}async nip04Decrypt(e,n){if(!this._privateKey)throw Error("Attempted to decrypt without a private key");const r=e.pubkey;return await nip04_exports.decrypt(this._privateKey,r,n)}};async function sendReq(t,e){const n=new NDKEvent(this.ndk,{kind:23194,tags:[["p",this.walletService.pubkey]],content:JSON.stringify({method:t,params:e})});return this.debug("Sending request",n.content),await n.encrypt(this.walletService,this.signer),await n.sign(this.signer),this.debug("Request encrypted and signed"),new Promise(async(r,s)=>{try{const o=n.tagId();if(!o)throw new Error("Failed to get e-tag");const a=l=>{this.off(o,a),this.off("event",a),this.debug("Received response",l);try{const h=JSON.parse(l);h.error&&s(h),r(h)}catch(h){this.debug("Failed to parse response",h),s({result_type:"error",error:{code:"failed_to_parse_response",message:h.message}})}},c=this.ndk.subscribe({kinds:[23195],"#e":[o],limit:1},{groupable:!1,subId:`nwc-${t}`},this.relaySet);c.on("event",async l=>{await l.decrypt(l.author,this.signer),a(l.content),c.stop()}),this.once(o,a),this.once("event",a),this.debug("Sending request to relay",n.rawEvent()),await n.publish(this.relaySet)}catch(o){this.debug("Failed to send request",o,o.relayErrors),s({result_type:"error",error:{code:"failed_to_send_request",message:o.message}})}})}async function getBalance(){return await this.sendReq("get_balance",{})}async function getInfo(){return await this.sendReq("get_info",{})}var NDKNwc=class de extends libExports.EventEmitter{constructor({ndk:n,pubkey:r,relayUrls:s,secret:o}){super();x(this,"ndk");x(this,"debug");x(this,"walletService");x(this,"relaySet");x(this,"signer");x(this,"active",!1);x(this,"getBalance",getBalance.bind(this));this.ndk=n,this.walletService=n.getUser({pubkey:r}),this.relaySet=new NDKRelaySet(new Set(s.map(a=>n.pool.getRelay(a))),n),this.signer=new NDKPrivateKeySigner(o instanceof Uint8Array?o:hexToBytes$1(o)),this.debug=n.debug.extend("nwc"),this.debug(`Starting with wallet service ${this.walletService.npub}`)}static async fromURI(n,r){const s=new URL(r);if(s.protocol!=="nostr+walletconnect:")throw new Error("Invalid protocol");return new de({ndk:n,pubkey:s.host??s.pathname,relayUrls:s.searchParams.getAll("relay")??[""],secret:s.searchParams.get("secret")??""})}async blockUntilReady(n){const r=await this.signer.user(),s=new Promise((c,l)=>{setTimeout(()=>{l(new Error("Timeout"))},n)}),a=[new Promise(c=>{const l=this.ndk.subscribe({kinds:[23195],"#p":[r.pubkey],limit:1},{groupable:!1,subId:"nwc"},this.relaySet);l.on("event",async h=>{this.debug("received response",h.rawEvent());const f=h.tagValue("e");if(!f){this.debug("Received an event without an e-tag");return}this.debug("received an event",f);try{await h.decrypt(h.author,this.signer),this.emit(f,h.content)}catch(u){this.debug("Failed to decrypt event",u);return}}),l.on("eose",()=>{this.debug("Subscription ready"),this.active=!0,c()}),l.on("close",()=>{this.debug("Subscription closed"),this.active=!1})})];return n&&a.push(s),await Promise.race(a)}async sendReq(n,r){return await sendReq.call(this,n,r)}async payInvoice(n){return await payInvoice.call(this,n)}async getInfo(){return await getInfo.call(this)}},NDKPool=class extends libExports.EventEmitter{constructor(e=[],n=[],r,s){super();x(this,"_relays",new Map);x(this,"autoConnectRelays",new Set);x(this,"blacklistRelayUrls");x(this,"debug");x(this,"temporaryRelayTimers",new Map);x(this,"flappingRelays",new Set);x(this,"backoffTimes",new Map);x(this,"ndk");this.debug=s??r.debug.extend("pool"),this.ndk=r,this.relayUrls=e,this.blacklistRelayUrls=new Set(n)}get relays(){return this._relays}set relayUrls(e){this._relays.clear();for(const n of e){const r=new NDKRelay(n,void 0,this.ndk);r.connectivity.netDebug=this.ndk.netDebug,this.addRelay(r,!1)}}set name(e){this.debug=this.debug.extend(e)}useTemporaryRelay(e,n=3e4,r){const s=this.relays.has(e.url);s||(this.addRelay(e),this.debug("Adding temporary relay %s for filters %o",e.url,r));const o=this.temporaryRelayTimers.get(e.url);if(o&&clearTimeout(o),!s||o){const a=setTimeout(()=>{var c;(c=this.ndk.explicitRelayUrls)!=null&&c.includes(e.url)||this.removeRelay(e.url)},n);this.temporaryRelayTimers.set(e.url,a)}}addRelay(e,n=!0){var w,y;const r=this.relays.has(e.url),s=(w=this.blacklistRelayUrls)==null?void 0:w.has(e.url),o=e.url.includes("/npub1");let a=!0;const c=e.url;if(r)return;if(s){this.debug(`Refusing to add relay ${c}: blacklisted`);return}if(o){this.debug(`Refusing to add relay ${c}: is a filter relay`);return}if((y=this.ndk.cacheAdapter)!=null&&y.getRelayStatus){const _=this.ndk.cacheAdapter.getRelayStatus(c);if(_&&_.dontConnectBefore)if(_.dontConnectBefore>Date.now()){const N=_.dontConnectBefore-Date.now();this.debug(`Refusing to add relay ${c}: delayed connect for ${N}ms`),setTimeout(()=>{this.addRelay(e,n)},N);return}else a=!1}const l=_=>this.emit("notice",e,_),h=()=>this.handleRelayConnect(c),f=()=>this.handleRelayReady(e),u=()=>this.emit("relay:disconnect",e),p=()=>this.handleFlapping(e),g=_=>this.emit("relay:auth",e,_),A=()=>this.emit("relay:authed",e);e.off("notice",l),e.off("connect",h),e.off("ready",f),e.off("disconnect",u),e.off("flapping",p),e.off("auth",g),e.off("authed",A),e.on("notice",l),e.on("connect",h),e.on("ready",f),e.on("disconnect",u),e.on("flapping",p),e.on("auth",g),e.on("authed",A),e.on("delayed-connect",_=>{var N;(N=this.ndk.cacheAdapter)!=null&&N.updateRelayStatus&&this.ndk.cacheAdapter.updateRelayStatus(e.url,{dontConnectBefore:Date.now()+_})}),this.relays.set(c,e),n&&this.autoConnectRelays.add(c),n&&(this.emit("relay:connecting",e),e.connect(void 0,a).catch(_=>{this.debug(`Failed to connect to relay ${c}`,_)}))}removeRelay(e){const n=this.relays.get(e);if(n)return n.disconnect(),this.relays.delete(e),this.autoConnectRelays.delete(e),this.emit("relay:disconnect",n),!0;const r=this.temporaryRelayTimers.get(e);return r&&(clearTimeout(r),this.temporaryRelayTimers.delete(e)),!1}isRelayConnected(e){const n=normalizeRelayUrl(e),r=this.relays.get(n);return r?r.status===5:!1}getRelay(e,n=!0,r=!1,s){let o=this.relays.get(normalizeRelayUrl(e));return o||(o=new NDKRelay(e,void 0,this.ndk),o.connectivity.netDebug=this.ndk.netDebug,r?this.useTemporaryRelay(o,3e4,s):this.addRelay(o,n)),o}handleRelayConnect(e){this.emit("relay:connect",this.relays.get(e)),this.stats().connected===this.relays.size&&this.emit("connect")}handleRelayReady(e){this.emit("relay:ready",e)}async connect(e){var s;const n=[];this.debug(`Connecting to ${this.relays.size} relays${e?`, timeout ${e}...`:""}`);const r=new Set(this.autoConnectRelays.keys());(s=this.ndk.explicitRelayUrls)==null||s.forEach(o=>{const a=normalizeRelayUrl(o);r.add(a)});for(const o of r){const a=this.relays.get(o);if(!a)continue;const c=new Promise((l,h)=>(this.emit("relay:connecting",a),a.connect(e).then(l).catch(h)));if(e){const l=new Promise((h,f)=>{setTimeout(()=>f(`Timed out after ${e}ms`),e)});n.push(Promise.race([c,l]).catch(h=>{this.debug(`Failed to connect to relay ${a.url}: ${h??"No reason specified"}`)}))}else n.push(c)}e&&setTimeout(()=>{const o=this.stats().connected===this.relays.size,a=this.stats().connected>0;!o&&a&&this.emit("connect")},e),await Promise.all(n)}checkOnFlappingRelays(){const e=this.flappingRelays.size,n=this.relays.size;if(e/n>=.8)for(const r of this.flappingRelays)this.backoffTimes.set(r,0)}handleFlapping(e){this.debug(`Relay ${e.url} is flapping`);let n=this.backoffTimes.get(e.url)||5e3;n=n*2,this.backoffTimes.set(e.url,n),this.debug(`Backoff time for ${e.url} is ${n}ms`),setTimeout(()=>{this.debug(`Attempting to reconnect to ${e.url}`),this.emit("relay:connecting",e),e.connect(),this.checkOnFlappingRelays()},n),e.disconnect(),this.emit("flapping",e)}size(){return this.relays.size}stats(){const e={total:0,connected:0,disconnected:0,connecting:0};for(const n of this.relays.values())e.total++,n.status===5?e.connected++:n.status===1?e.disconnected++:n.status===4&&e.connecting++;return e}connectedRelays(){return Array.from(this.relays.values()).filter(e=>e.status>=5)}permanentAndConnectedRelays(){return Array.from(this.relays.values()).filter(e=>e.status>=5&&!this.temporaryRelayTimers.has(e.url))}urls(){return Array.from(this.relays.keys())}};function dedup(t,e){return t.created_at>e.created_at?t:e}async function getRelayListForUser(t,e){return(await getRelayListForUsers([t],e)).get(t)}async function getRelayListForUsers(t,e,n=!1){var f;const r=e.outboxPool||e.pool,s=new Set;for(const u of r.relays.values())s.add(u);const o=new Map,a=new Map,c=new NDKRelaySet(s,e);if((f=e.cacheAdapter)!=null&&f.locking&&!n){const u=await e.fetchEvents({kinds:[3,10002],authors:t},{cacheUsage:"ONLY_CACHE"});for(const p of u)p.kind===10002&&o.set(p.pubkey,NDKRelayList.from(p));for(const p of u)if(p.kind===3){if(o.has(p.pubkey))continue;const g=relayListFromKind3(e,p);g&&a.set(p.pubkey,g)}t=t.filter(p=>!o.has(p)&&!a.has(p))}if(t.length===0)return o;const l=new Map,h=new Map;return new Promise(async u=>{const p=e.subscribe({kinds:[3,10002],authors:t},{closeOnEose:!0,pool:r,groupable:!0,cacheUsage:"ONLY_RELAY",subId:"ndk-relay-list-fetch"},c,!1);p.on("event",g=>{if(g.kind===10002){const A=l.get(g.pubkey);if(A&&A.created_at>g.created_at)return;l.set(g.pubkey,g)}else if(g.kind===3){const A=h.get(g.pubkey);if(A&&A.created_at>g.created_at)return;h.set(g.pubkey,g)}}),p.on("eose",()=>{for(const g of l.values())o.set(g.pubkey,NDKRelayList.from(g));for(const g of t){if(o.has(g))continue;const A=h.get(g);if(!A)continue;const w=relayListFromKind3(e,A);w&&o.set(g,w)}u(o)}),p.start()})}var OutboxItem=class{constructor(t){x(this,"type");x(this,"relayUrlScores");x(this,"readRelays");x(this,"writeRelays");this.type=t,this.relayUrlScores=new Map,this.readRelays=new Set,this.writeRelays=new Set}},OutboxTracker=class extends libExports.EventEmitter{constructor(e){super();x(this,"data");x(this,"ndk");x(this,"debug");this.ndk=e,this.debug=e.debug.extend("outbox-tracker"),this.data=new distExports.LRUCache({maxSize:1e5,entryExpirationTimeInMS:2*60*1e3})}async trackUsers(e,n=!1){const r=[];for(let s=0;s<e.length;s+=400){const a=e.slice(s,s+400).map(c=>getKeyFromItem(c)).filter(c=>!this.data.has(c));if(a.length!==0){for(const c of a)this.data.set(c,new OutboxItem("user"));r.push(new Promise(c=>{getRelayListForUsers(a,this.ndk,n).then(l=>{for(const[h,f]of l){let u=this.data.get(h);if(u??(u=new OutboxItem("user")),f){u.readRelays=new Set(normalize(f.readRelayUrls)),u.writeRelays=new Set(normalize(f.writeRelayUrls));for(const p of u.readRelays)this.ndk.pool.blacklistRelayUrls.has(p)&&u.readRelays.delete(p);for(const p of u.writeRelays)this.ndk.pool.blacklistRelayUrls.has(p)&&u.writeRelays.delete(p);this.data.set(h,u)}}}).finally(c)}))}}return Promise.all(r)}track(e,n,r=!0){const s=getKeyFromItem(e);n??(n=getTypeFromItem(e));let o=this.data.get(s);return o||(o=new OutboxItem(n),e instanceof NDKUser&&this.trackUsers([e])),o}};function getKeyFromItem(t){return t instanceof NDKUser?t.pubkey:t}function getTypeFromItem(t){return t instanceof NDKUser?"user":"kind"}function correctRelaySet(t,e){const n=e.connectedRelays();if(!Array.from(t.relays).some(s=>n.map(o=>o.url).includes(s.url)))for(const s of n)t.addRelay(s);if(n.length===0)for(const s of e.relays.values())t.addRelay(s);return t}function isValidHint(t){if(!t||t==="")return!1;try{return new URL(t),!0}catch{return!1}}async function fetchEventFromTag(t,e,n,r={type:"timeout"}){const s=this.debug.extend("fetch-event-from-tag"),[o,a,c]=t;n={},s("fetching event from tag",t,n,r);const l=getRelaysForSync(this,e.pubkey);if(l&&l.size>0){s("fetching event from author relays %o",Array.from(l));const w=NDKRelaySet.fromRelayUrls(Array.from(l),this),y=await this.fetchEvent(a,n,w);if(y)return y}else s("no author relays found for %s",e.pubkey,e);const h=calculateRelaySetsFromFilters(this,[{ids:[a]}],this.pool);s("fetching event without relay hint",h);const f=await this.fetchEvent(a,n);if(f)return f;if(c&&c!==""){const w=await this.fetchEvent(a,n,this.pool.getRelay(c,!0,!0,[{ids:[a]}]));if(w)return w}let u;const p=isValidHint(c)?this.pool.getRelay(c,!1,!0,[{ids:[a]}]):void 0,g=new Promise(w=>{this.fetchEvent(a,n,p).then(w)});if(!isValidHint(c)||r.type==="none")return g;const A=new Promise(async w=>{const y=r.relaySet,_=r.timeout??1500,N=new Promise(C=>setTimeout(C,_));if(r.type==="timeout"&&await N,u)w(u);else{s("fallback fetch triggered");const C=await this.fetchEvent(a,n,y);w(C)}});switch(r.type){case"timeout":return Promise.race([g,A]);case"eose":return u=await g,u||A}}var SPEC_PATH="/.well-known/nostr/nip96.json",Nip96=class{constructor(t,e){x(this,"ndk");x(this,"spec");x(this,"url");x(this,"nip98Required",!1);this.url=`https://${t}${SPEC_PATH}`,this.ndk=e}async prepareUpload(t,e="POST"){if(this.validateHttpFetch(),this.spec||await this.fetchSpec(),!this.spec)throw new Error("Failed to fetch NIP96 spec");let n={};return this.nip98Required&&(n={Authorization:await this.generateNip98Header(this.spec.api_url,e,t)}),{url:this.spec.api_url,headers:n}}async xhrUpload(t,e){const n="POST",{url:r,headers:s}=await this.prepareUpload(e,n);t.open(n,r,!0),s.Authorization&&t.setRequestHeader("Authorization",s.Authorization);const o=new FormData;return o.append("file",e),new Promise((a,c)=>{t.onload=function(){t.status>=200&&t.status<300?a(JSON.parse(t.responseText)):c(new Error(t.statusText))},t.onerror=function(){c(new Error("Network Error"))},t.send(o)})}async upload(t){const e="POST",{url:n,headers:r}=await this.prepareUpload(t,e),s=new FormData;s.append("file",t);const o=await this.ndk.httpFetch(this.spec.api_url,{method:e,headers:r,body:s});if(o.status!==200)throw new Error(`Failed to upload file to ${n}`);const a=await o.json();if(a.status!=="success")throw new Error(a.message);return a}validateHttpFetch(){if(!this.ndk)throw new Error("NDK is required to fetch NIP96 spec");if(!this.ndk.httpFetch)throw new Error("NDK must have an httpFetch method to fetch NIP96 spec")}async fetchSpec(){this.validateHttpFetch();const t=await this.ndk.httpFetch(this.url);if(t.status!==200)throw new Error(`Failed to fetch NIP96 spec from ${this.url}`);const e=await t.json();if(!e)throw new Error(`Failed to parse NIP96 spec from ${this.url}`);this.spec=e,this.nip98Required=this.spec.plans.free.is_nip98_required}async generateNip98Header(t,e,n){const r=new NDKEvent(this.ndk,{kind:27235,tags:[["u",t],["method",e]]});if(["POST","PUT","PATCH"].includes(e)){const o=await this.calculateSha256(n);r.tags.push(["payload",o])}return await r.sign(),`Nostr ${btoa(JSON.stringify(r.rawEvent()))}`}async calculateSha256(t){const e=await t.arrayBuffer(),n=await crypto.subtle.digest("SHA-256",e);return Array.from(new Uint8Array(n)).map(o=>o.toString(16).padStart(2,"0")).join("")}},Queue=class{constructor(t,e){x(this,"queue",[]);x(this,"maxConcurrency");x(this,"processing",new Set);x(this,"promises",new Map);this.maxConcurrency=e}add(t){if(this.promises.has(t.id))return this.promises.get(t.id);const e=new Promise((n,r)=>{this.queue.push({...t,func:()=>t.func().then(s=>(n(s),s),s=>{throw r(s),s})}),this.process()});return this.promises.set(t.id,e),e.finally(()=>{this.promises.delete(t.id),this.processing.delete(t.id),this.process()}),e}process(){if(this.processing.size>=this.maxConcurrency||this.queue.length===0)return;const t=this.queue.shift();!t||this.processing.has(t.id)||(this.processing.add(t.id),t.func())}clear(){this.queue=[]}clearProcessing(){this.processing.clear()}clearAll(){this.clear(),this.clearProcessing()}length(){return this.queue.length}},NDKSubscriptionManager=class{constructor(t){x(this,"subscriptions");x(this,"seenEvents",new Map);x(this,"debug");this.subscriptions=new Map,this.debug=t.extend("sub-manager")}add(t){this.subscriptions.set(t.internalId,t),t.on("close",()=>{this.subscriptions.delete(t.internalId)})}seenEvent(t,e){const n=this.seenEvents.get(t)||[];n.push(e),this.seenEvents.set(t,n)}},debug6=debug7("ndk:active-user");async function getUserRelayList(t){if(!this.autoConnectUserRelays)return;const e=await getRelayListForUser(t.pubkey,this);if(e){for(const n of e.relays){let r=this.pool.relays.get(n);r||(r=new NDKRelay(n,this.relayAuthDefaultPolicy,this),this.pool.addRelay(r))}return e}}async function setActiveUser(t){const e=this.outboxPool||this.pool;e.connectedRelays.length>0?setActiveUserConnected.call(this,t):e.once("connect",()=>{setActiveUserConnected.call(this,t)})}async function setActiveUserConnected(t){const e=await getUserRelayList.call(this,t),n=[{kinds:[10006],authors:[t.pubkey]}];this.autoFetchUserMutelist&&n[0].kinds.push(1e4);const r=e?e.relaySet:void 0,s=this.subscribe(n,{subId:"active-user-settings",closeOnEose:!0},r,!1),o=new Map;s.on("event",a=>{const c=o.get(a.kind);c&&c.created_at>=a.created_at||o.set(a.kind,a)}),s.on("eose",()=>{for(const a of o.values())processEvent.call(this,a)}),s.start()}async function processEvent(t){t.kind===10006?processBlockRelayList.call(this,t):t.kind===1e4&&processMuteList.call(this,t)}function processBlockRelayList(t){const e=lists_default.from(t);for(const n of e.items)this.pool.blacklistRelayUrls.add(n[0]);debug6("Added %d relays to relay blacklist",e.items.length)}function processMuteList(t){const e=lists_default.from(t);for(const n of e.items)this.mutedIds.set(n[1],n[0]);debug6("Added %d users to mute list",e.items.length)}async function generateZapRequest(t,e,n,r,s,o,a,c,l){const h=n.callback,f=nip57_exports.makeZapRequest({profile:r,event:null,amount:s,comment:a||"",relays:o.slice(0,4)});if(t instanceof NDKEvent){const g=t.referenceTags().filter(A=>A[0]!=="p");f.tags.push(...g)}f.tags.push(["lnurl",h]);const u=new NDKEvent(e,f);return c&&(u.tags=u.tags.concat(c)),u.tags=u.tags.filter(p=>p[0]!=="p"),u.tags.push(["p",r]),await u.sign(l),u}var d3=debug7("ndk:zapper"),NDKZapper=class extends libExports.EventEmitter{constructor(e,n,r="msat",s,o,a,c){super();x(this,"target");x(this,"ndk");x(this,"comment");x(this,"amount");x(this,"unit");x(this,"tags");x(this,"signer");x(this,"zapMethod");x(this,"onLnPay");x(this,"onCashuPay");x(this,"onComplete");x(this,"maxRelays",3);if(this.target=e,this.ndk=o||e.ndk,!this.ndk)throw new Error("No NDK instance provided");this.amount=n,this.comment=s,this.unit=r,this.tags=a,this.signer=c}async zap(){const e=this.getZapSplits(),n=new Map;return await Promise.all(e.map(async r=>{let s;try{s=await this.zapSplit(r)}catch(o){s=o}this.emit("split:complete",r,s),n.set(r,s)})),this.emit("complete",n),this.onComplete&&this.onComplete(n),n}async zapSplit(e){let n=await this.getZapMethods(this.ndk,e.pubkey),r;if(n.length===0)throw new Error("No zap method available for recipient");n=n.sort((o,a)=>o.type==="nip61"?-1:a.type==="nip61"?1:0);const s=await this.relays(e.pubkey);for(const o of n){d3("Zapping to %s with %d %s using %s",e.pubkey,e.amount,this.unit,o.type);try{switch(o.type){case"nip61":{const a=o.data;let c;if(c=await this.onCashuPay({target:this.target,comment:this.comment,tags:this.tags,recipientPubkey:e.pubkey,amount:e.amount,unit:this.unit,...a}),d3("NIP-61 Zap result: %o",c),c instanceof Error)r=c;else if(c){const{proofs:l,mint:h}=c;if(!l||!h)throw new Error("Invalid zap confirmation: missing proofs or mint: "+c);const f=NDKRelaySet.fromRelayUrls(s,this.ndk),u=new NDKNutzap(this.ndk);return u.tags=[...u.tags,...this.tags||[]],u.proofs=l,u.mint=h,u.comment=this.comment,u.unit=this.unit,u.recipientPubkey=e.pubkey,await u.sign(this.signer),await u.publish(f),u}break}case"nip57":{const a=o.data,c=await generateZapRequest(this.target,this.ndk,a,e.pubkey,e.amount,s,this.comment,this.tags,this.signer);if(!c)throw d3("Unable to generate zap request"),new Error("Unable to generate zap request");const l=await this.getLnInvoice(c,e.amount,a);if(!l)throw d3("Unable to get payment request"),new Error("Unable to get payment request");r=await this.onLnPay({target:this.target,comment:this.comment,recipientPubkey:e.pubkey,amount:e.amount,unit:this.unit,pr:l});break}}}catch(a){a instanceof Error?r=a:r=new Error(a),d3("Error zapping to %s with %d %s using %s: %o",e.pubkey,e.amount,this.unit,o.type,a)}}if(r instanceof Error)throw r;return r}async getLnInvoice(e,n,r){const s=r.callback,o=JSON.stringify(e.rawEvent());d3(`Fetching invoice from ${s}?`+new URLSearchParams({amount:n.toString(),nostr:o}));const a=new URL(s);a.searchParams.append("amount",n.toString()),a.searchParams.append("nostr",o),d3(`Fetching invoice from ${a.toString()}`);const c=await fetch(a.toString());if(d3(`Got response from zap endpoint: ${s}`,{status:c.status}),c.status!==200){d3(`Received non-200 status from zap endpoint: ${s}`,{status:c.status,amount:n,nostr:o});const h=await c.text();throw new Error(`Unable to fetch zap endpoint ${s}: ${h}`)}return(await c.json()).pr}getZapSplits(){if(this.target instanceof NDKUser)return[{pubkey:this.target.pubkey,amount:this.amount}];const e=this.target.getMatchingTags("zap");if(e.length===0)return[{pubkey:this.target.pubkey,amount:this.amount}];const n=[],r=e.reduce((s,o)=>s+parseInt(o[2]),0);for(const s of e){const o=s[1],a=Math.floor(parseInt(s[2])/r*this.amount);n.push({pubkey:o,amount:a})}return n}async getZapMethods(e,n){const r=[];r.push("nip61"),r.push("nip57");const s=e.getUser({pubkey:n}),o=await s.getZapInfo(!1,r);return d3("Zap info for %s: %o",s.npub,o),o}async relays(e){var r,s,o;let n=[];if((r=this.ndk)!=null&&r.activeUser){const a=await getRelayListForUsers([this.ndk.activeUser.pubkey,e],this.ndk),c=new Map;for(const l of a.values())for(const h of l.readRelayUrls){const f=c.get(h)||0;c.set(h,f+1)}n=Array.from(c.entries()).sort((l,h)=>h[1]-l[1]).map(([l])=>l).slice(0,this.maxRelays)}return(o=(s=this.ndk)==null?void 0:s.pool)!=null&&o.permanentAndConnectedRelays().length&&(n=this.ndk.pool.permanentAndConnectedRelays().map(a=>a.url)),n.length||(n=[]),n}},DEFAULT_OUTBOX_RELAYS=["wss://purplepag.es/","wss://nos.lol/"],DEFAULT_BLACKLISTED_RELAYS=["wss://brb.io/","wss://nostr.mutinywallet.com/"],NDK=class extends libExports.EventEmitter{constructor(e={}){super();x(this,"_explicitRelayUrls");x(this,"pool");x(this,"outboxPool");x(this,"_signer");x(this,"_activeUser");x(this,"cacheAdapter");x(this,"debug");x(this,"devWriteRelaySet");x(this,"outboxTracker");x(this,"mutedIds");x(this,"clientName");x(this,"clientNip89");x(this,"queuesZapConfig");x(this,"queuesNip05");x(this,"asyncSigVerification",!1);x(this,"initialValidationRatio",1);x(this,"lowestValidationRatio",1);x(this,"validationRatioFn");x(this,"subManager");x(this,"publishingFailureHandled",!1);x(this,"relayAuthDefaultPolicy");x(this,"httpFetch");x(this,"netDebug");x(this,"autoConnectUserRelays",!0);x(this,"autoFetchUserMutelist",!0);x(this,"walletConfig");x(this,"fetchEventFromTag",fetchEventFromTag.bind(this));this.debug=e.debug||debug7("ndk"),this.netDebug=e.netDebug,this._explicitRelayUrls=e.explicitRelayUrls||[],this.subManager=new NDKSubscriptionManager(this.debug),this.pool=new NDKPool(e.explicitRelayUrls||[],e.blacklistRelayUrls||DEFAULT_BLACKLISTED_RELAYS,this),this.pool.name="main",this.pool.on("relay:auth",async(n,r)=>{this.relayAuthDefaultPolicy&&await this.relayAuthDefaultPolicy(n,r)}),this.autoConnectUserRelays=e.autoConnectUserRelays??!0,this.autoFetchUserMutelist=e.autoFetchUserMutelist??!0,this.clientName=e.clientName,this.clientNip89=e.clientNip89,this.relayAuthDefaultPolicy=e.relayAuthDefaultPolicy,e.enableOutboxModel&&(this.outboxPool=new NDKPool(e.outboxRelayUrls||DEFAULT_OUTBOX_RELAYS,e.blacklistRelayUrls||DEFAULT_BLACKLISTED_RELAYS,this,this.debug.extend("outbox-pool")),this.outboxPool.name="outbox",this.outboxTracker=new OutboxTracker(this)),this.signer=e.signer,this.cacheAdapter=e.cacheAdapter,this.mutedIds=e.mutedIds||new Map,e.devWriteRelayUrls&&(this.devWriteRelaySet=NDKRelaySet.fromRelayUrls(e.devWriteRelayUrls,this)),this.queuesZapConfig=new Queue("zaps",3),this.queuesNip05=new Queue("nip05",10),this.signatureVerificationWorker=e.signatureVerificationWorker,this.initialValidationRatio=e.initialValidationRatio||1,this.lowestValidationRatio=e.lowestValidationRatio||1;try{this.httpFetch=fetch}catch{}}set explicitRelayUrls(e){this._explicitRelayUrls=e,this.pool.relayUrls=e}get explicitRelayUrls(){return this._explicitRelayUrls||[]}set signatureVerificationWorker(e){this.asyncSigVerification=!!e,e&&signatureVerificationInit(e)}addExplicitRelay(e,n,r=!0){let s;return typeof e=="string"?s=new NDKRelay(e,n,this):s=e,this.pool.addRelay(s,r),this.explicitRelayUrls.push(s.url),s}toJSON(){return{relayCount:this.pool.relays.size}.toString()}get activeUser(){return this._activeUser}set activeUser(e){var r;const n=((r=this._activeUser)==null?void 0:r.pubkey)!==(e==null?void 0:e.pubkey);this._activeUser=e,e&&n?setActiveUser.call(this,e):e||(this.mutedIds=new Map)}get signer(){return this._signer}set signer(e){this._signer=e,e&&this.emit("signer:ready",e),e==null||e.user().then(n=>{n.ndk=this,this.activeUser=n})}async connect(e){var r,s;this._signer&&this.autoConnectUserRelays&&(this.debug("Attempting to connect to user relays specified by signer %o",await((s=(r=this._signer).relays)==null?void 0:s.call(r,this))),this._signer.relays&&(await this._signer.relays(this)).forEach(a=>this.pool.addRelay(a)));const n=[this.pool.connect(e)];return this.outboxPool&&n.push(this.outboxPool.connect(e)),this.debug("Connecting to relays %o",{timeoutMs:e}),Promise.allSettled(n).then(()=>{})}getUser(e){const n=new NDKUser(e);return n.ndk=this,n}async getUserFromNip05(e,n=!1){return NDKUser.fromNip05(e,this,n)}subscribe(e,n,r,s=!0){var a;const o=new NDKSubscription(this,e,n,r);if(this.subManager.add(o),r)for(const c of r.relays)this.pool.useTemporaryRelay(c,void 0,o.filters);if(this.outboxPool&&o.hasAuthorsFilter()){const c=o.filters.filter(l=>{var h;return l.authors&&((h=l.authors)==null?void 0:h.length)>0}).map(l=>l.authors).flat();(a=this.outboxTracker)==null||a.trackUsers(c)}return s&&setTimeout(()=>o.start(),0),o}async publish(e,n,r){return this.debug("Deprecated: Use `event.publish()` instead"),e.publish(n,r)}async fetchEvent(e,n,r){let s,o;if(r instanceof NDKRelay?o=new NDKRelaySet(new Set([r]),this):r instanceof NDKRelaySet&&(o=r),!r&&typeof e=="string"&&!isNip33AValue(e)){const a=relaysFromBech32(e,this);a.length>0&&(o=new NDKRelaySet(new Set(a),this),o=correctRelaySet(o,this.pool))}if(typeof e=="string"?s=[filterFromId(e)]:Array.isArray(e)?s=e:s=[e],s.length===0)throw new Error(`Invalid filter: ${JSON.stringify(e)}`);return new Promise(a=>{let c=null;const l=this.subscribe(s,{...n||{},closeOnEose:!0},o,!1),h=setTimeout(()=>{l.stop(),a(c)},1e4);l.on("event",f=>{f.ndk=this,f.isReplaceable()?(!c||c.created_at<f.created_at)&&(c=f):(clearTimeout(h),a(f))}),l.on("eose",()=>{clearTimeout(h),a(c)}),l.start()})}async fetchEvents(e,n,r){return new Promise(s=>{const o=new Map,a=this.subscribe(e,{...n||{},closeOnEose:!0},r,!1),c=l=>{l instanceof NDKEvent||(l=new NDKEvent(void 0,l));const h=l.deduplicationKey(),f=o.get(h);f&&(l=dedup(f,l)),l.ndk=this,o.set(h,l)};a.on("event",c),a.on("eose",()=>{s(new Set(o.values()))}),a.start()})}assertSigner(){if(!this.signer)throw this.emit("signer:required"),new Error("Signer required")}getNip96(e){return new Nip96(e,this)}async nwc(e,n=2e3){const r=await NDKNwc.fromURI(this,e);return n!==!1&&await r.blockUntilReady(n),r}zap(e,n,{comment:r,unit:s,signer:o,tags:a,onLnPay:c,onCashuPay:l,onComplete:h}){var u,p,g;o||this.assertSigner();const f=new NDKZapper(e,n,s,r,this,a,o);return c!==!1&&(f.onLnPay=c??((u=this.walletConfig)==null?void 0:u.onLnPay)),l!==!1&&(f.onCashuPay=l??((p=this.walletConfig)==null?void 0:p.onCashuPay)),f.onComplete=h??((g=this.walletConfig)==null?void 0:g.onPaymentComplete),c&&f.zap(),f}};const ndk=new NDK({explicitRelayUrls:["ws://localhost:7777"]});let refreshInterval;async function init(){await ndk.connect(),console.log("Connected to relay!"),await fetchGroups(),refreshInterval=setInterval(fetchGroups,1e3)}async function fetchGroups(){try{const t=await fetch("/api/groups",{headers:{Accept:"application/json"}});if(!t.ok){console.error("Server error:",{status:t.status,statusText:t.statusText});const r=await t.text();throw console.error("Response body:",r),new Error(`HTTP error! status: ${t.status}`)}const e=await t.text(),n=e?JSON.parse(e):[];for(const r of n)r.content=await fetchGroupContent(r.id);renderGroups(n)}catch(t){console.error("Failed to fetch groups:",t)}}async function fetchGroupContent(t){try{const e=ndk.subscribe({kinds:[9,11,10010].map(r=>r),"#h":[t]},{closeOnEose:!0}),n=[];return e.on("event",r=>{n.push({pubkey:r.pubkey,kind:r.kind,content:r.content,created_at:r.created_at})}),await new Promise(r=>e.on("eose",r)),n}catch(e){return console.error(`Failed to fetch content for group ${t}:`,e),[]}}function renderGroups(t){const e=document.getElementById("app");e&&(e.innerHTML=`
        <header class="site-header">
            <h1>Groups</h1>
        </header>
        <main>
            ${t.map(n=>`
                <article class="group-card">
                    <header class="group-header">
                        <h2 class="group-name">${n.name}</h2>
                    </header>
                    <section class="group-metadata">
                        <div class="meta-row">
                            <div class="meta-block">
                                <span class="meta-label">ID:</span>
                                <span class="meta-value">${n.id}</span>
                            </div>
                            <div class="meta-block">
                                <span class="meta-label">About:</span>
                                <span class="meta-value">${n.about||"No description"}</span>
                            </div>
                        </div>
                        <div class="meta-row">
                            <div class="meta-block">
                                <span class="meta-label">Type:</span>
                                <span class="meta-value">${n.private?"Private":"Public"}, ${n.closed?"Closed":"Open"}</span>
                            </div>
                        </div>
                    </section>
                    <section class="card-section members">
                        <h3><span class="icon">👥</span> Members</h3>
                        <ul>
                            ${n.members.map(r=>`
                                <li>
                                    <div class="list-item-content">
                                        <span class="pubkey">${r.pubkey}</span>
                                        <div class="member-roles">
                                            ${r.roles.map(s=>{const o=s.toLowerCase(),[a,c]=o.includes("admin")?["var(--role-admin)","⭐"]:o.includes("moderator")?["var(--role-moderator)","🛡"]:["var(--role-member)","👤"];return`<span class="role-badge" style="background: ${a};">${c} ${s}</span>`}).join(" ")}
                                        </div>
                                    </div>
                                </li>
                            `).join(`
`)}
                        </ul>
                    </section>
                    <section class="card-section invites">
                        <h3><span class="icon">🎟</span> Invites</h3>
                        <ul>
                            ${!n.invites||Object.entries(n.invites).length===0?'<li><div class="list-item-content">No active invites</div></li>':Object.entries(n.invites).map(([r,s])=>`
                                    <li>
                                        <div class="list-item-content">
                                            <div><strong>Code:</strong> ${r}</div>
                                            <div><strong>Accepted by:</strong> ${s.pubkey||"None"}</div>
                                            <div class="member-roles">
                                                ${s.roles.map(o=>`<span class="role-badge" style="background: var(--role-invite);"> ${o}</span>`).join(" ")}
                                            </div>
                                        </div>
                                    </li>
                                `).join(`
`)}
                        </ul>
                    </section>
                    <section class="card-section requests">
                        <h3><span class="icon">📨</span> Join Requests</h3>
                        <ul>
                            ${!n.join_requests||n.join_requests.length===0?'<li><div class="list-item-content">No pending requests</div></li>':n.join_requests.map(r=>`
                                    <li>
                                        <div class="list-item-content">${r}</div>
                                    </li>
                                `).join(`
`)}
                        </ul>
                    </section>
                    <section class="card-section content">
                        <h3><span class="icon">💬</span> Content</h3>
                        <ul>
                            ${!n.content||n.content.length===0?'<li><div class="list-item-content">No content yet</div></li>':n.content.map(r=>`
                                    <li>
                                        <div class="list-item-content">
                                            <div class="content-header">
                                                <span class="pubkey">${r.pubkey}</span>
                                                <span class="kind-badge">Kind: ${r.kind}</span>
                                            </div>
                                            <div class="content-body">${r.content}</div>
                                        </div>
                                    </li>
                                `).join(`
`)}
                        </ul>
                    </section>
                </article>
            `).join(`
`)}
        </main>
    `)}init().catch(console.error);window.addEventListener("unload",()=>{refreshInterval&&clearInterval(refreshInterval)});
